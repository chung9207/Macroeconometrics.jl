<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Innovation Accounting · MacroEconometricModels.jl</title><meta name="title" content="Innovation Accounting · MacroEconometricModels.jl"/><meta property="og:title" content="Innovation Accounting · MacroEconometricModels.jl"/><meta property="twitter:title" content="Innovation Accounting · MacroEconometricModels.jl"/><meta name="description" content="Documentation for MacroEconometricModels.jl."/><meta property="og:description" content="Documentation for MacroEconometricModels.jl."/><meta property="twitter:description" content="Documentation for MacroEconometricModels.jl."/><meta property="og:url" content="https://chung9207.github.io/MacroEconometricModels.jl/innovation_accounting/"/><meta property="twitter:url" content="https://chung9207.github.io/MacroEconometricModels.jl/innovation_accounting/"/><link rel="canonical" href="https://chung9207.github.io/MacroEconometricModels.jl/innovation_accounting/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MacroEconometricModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Univariate Models</span><ul><li><a class="tocitem" href="../arima/">ARIMA</a></li><li><a class="tocitem" href="../volatility/">Volatility Models</a></li></ul></li><li><span class="tocitem">Frequentist Models</span><ul><li><a class="tocitem" href="../manual/">VAR</a></li><li><a class="tocitem" href="../lp/">Local Projections</a></li><li><a class="tocitem" href="../factormodels/">Factor Models</a></li></ul></li><li><span class="tocitem">Bayesian Models</span><ul><li><a class="tocitem" href="../bayesian/">Bayesian VAR</a></li></ul></li><li class="is-active"><a class="tocitem" href>Innovation Accounting</a><ul class="internal"><li><a class="tocitem" href="#Quick-Start"><span>Quick Start</span></a></li><li><a class="tocitem" href="#Impulse-Response-Functions-(IRF)"><span>Impulse Response Functions (IRF)</span></a></li><li><a class="tocitem" href="#Forecast-Error-Variance-Decomposition-(FEVD)"><span>Forecast Error Variance Decomposition (FEVD)</span></a></li><li><a class="tocitem" href="#Historical-Decomposition-(HD)"><span>Historical Decomposition (HD)</span></a></li><li><a class="tocitem" href="#LP-Based-Innovation-Accounting"><span>LP-Based Innovation Accounting</span></a></li><li><a class="tocitem" href="#Summary-Tables"><span>Summary Tables</span></a></li><li><a class="tocitem" href="#Display-Backends"><span>Display Backends</span></a></li><li><a class="tocitem" href="#Bibliographic-References"><span>Bibliographic References</span></a></li><li><a class="tocitem" href="#Complete-Example"><span>Complete Example</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../nongaussian/">Non-Gaussian Structural Identification</a></li><li><span class="tocitem">Hypothesis Tests</span><ul><li><a class="tocitem" href="../hypothesis_tests/">Unit Root &amp; Cointegration</a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../api/">Overview</a></li><li><a class="tocitem" href="../api_types/">Types</a></li><li><a class="tocitem" href="../api_functions/">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Innovation Accounting</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Innovation Accounting</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/chung9207/MacroEconometricModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/main/docs/src/innovation_accounting.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Innovation-Accounting"><a class="docs-heading-anchor" href="#Innovation-Accounting">Innovation Accounting</a><a id="Innovation-Accounting-1"></a><a class="docs-heading-anchor-permalink" href="#Innovation-Accounting" title="Permalink"></a></h1><p>Innovation accounting refers to the collection of tools for analyzing the dynamic effects of structural shocks in VAR models. This includes Impulse Response Functions (IRF), Forecast Error Variance Decomposition (FEVD), and Historical Decomposition (HD).</p><h2 id="Quick-Start"><a class="docs-heading-anchor" href="#Quick-Start">Quick Start</a><a id="Quick-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Start" title="Permalink"></a></h2><pre><code class="language-julia hljs">irfs = irf(model, 20; method=:cholesky)                          # Frequentist IRF
irfs_ci = irf(model, 20; ci_type=:bootstrap, reps=1000)          # With bootstrap CI
birfs = irf(chain, p, n, 20; method=:cholesky)                   # Bayesian IRF
decomp = fevd(model, 20)                                         # FEVD
hd = historical_decomposition(model, 198)                        # Historical decomposition
report(irfs)                                                      # Publication-quality summary</code></pre><hr/><h2 id="Impulse-Response-Functions-(IRF)"><a class="docs-heading-anchor" href="#Impulse-Response-Functions-(IRF)">Impulse Response Functions (IRF)</a><a id="Impulse-Response-Functions-(IRF)-1"></a><a class="docs-heading-anchor-permalink" href="#Impulse-Response-Functions-(IRF)" title="Permalink"></a></h2><h3 id="Definition"><a class="docs-heading-anchor" href="#Definition">Definition</a><a id="Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Definition" title="Permalink"></a></h3><p>The impulse response function <span>$\Theta_h$</span> measures the effect of a one-unit structural shock at time <span>$t$</span> on the endogenous variables at time <span>$t+h$</span>:</p><p class="math-container">\[\Theta_h = \frac{\partial y_{t+h}}{\partial \varepsilon_t&#39;}\]</p><p>where</p><ul><li><span>$\Theta_h$</span> is the <span>$n \times n$</span> impulse response matrix at horizon <span>$h$</span></li><li><span>$y_{t+h}$</span> is the <span>$n \times 1$</span> vector of endogenous variables at time <span>$t+h$</span></li><li><span>$\varepsilon_t$</span> is the <span>$n \times 1$</span> vector of structural shocks at time <span>$t$</span></li></ul><p>For a VAR, the IRF at horizon <span>$h$</span> is computed recursively:</p><p class="math-container">\[\Theta_h = \sum_{i=1}^{\min(h,p)} A_i \Theta_{h-i}\]</p><p>where</p><ul><li><span>$A_i$</span> are the <span>$n \times n$</span> VAR coefficient matrices for lag <span>$i$</span></li><li><span>$\Theta_0 = B_0$</span> is the <span>$n \times n$</span> structural impact matrix</li><li><span>$p$</span> is the VAR lag order</li></ul><h3 id="Companion-Form-Representation"><a class="docs-heading-anchor" href="#Companion-Form-Representation">Companion Form Representation</a><a id="Companion-Form-Representation-1"></a><a class="docs-heading-anchor-permalink" href="#Companion-Form-Representation" title="Permalink"></a></h3><p>Using the companion form, IRFs can be computed as:</p><p class="math-container">\[\Theta_h = J F^h J&#39; B_0\]</p><p>where</p><ul><li><span>$J = [I_n, 0, \ldots, 0]$</span> is the <span>$n \times np$</span> selection matrix</li><li><span>$F$</span> is the <span>$np \times np$</span> companion matrix</li><li><span>$B_0$</span> is the <span>$n \times n$</span> structural impact matrix</li></ul><h3 id="Cumulative-IRF"><a class="docs-heading-anchor" href="#Cumulative-IRF">Cumulative IRF</a><a id="Cumulative-IRF-1"></a><a class="docs-heading-anchor-permalink" href="#Cumulative-IRF" title="Permalink"></a></h3><p>The cumulative impulse response up to horizon <span>$H$</span> is:</p><p class="math-container">\[\Theta^{cum}_H = \sum_{h=0}^{H} \Theta_h\]</p><p>where <span>$\Theta^{cum}_H$</span> accumulates the impulse responses from impact through horizon <span>$H$</span>, measuring the total cumulative effect of a structural shock. This is particularly relevant for variables in growth rates, where the cumulative IRF represents the effect on the level.</p><h3 id="Confidence-Intervals"><a class="docs-heading-anchor" href="#Confidence-Intervals">Confidence Intervals</a><a id="Confidence-Intervals-1"></a><a class="docs-heading-anchor-permalink" href="#Confidence-Intervals" title="Permalink"></a></h3><p><strong>Bootstrap (Frequentist)</strong>: Residual bootstrap of Kilian (1998):</p><ol><li>Estimate the VAR and save residuals <span>$\hat{u}_t$</span></li><li>Generate bootstrap sample by resampling residuals with replacement</li><li>Re-estimate the VAR and compute IRFs</li><li>Repeat <span>$B$</span> times to build the distribution</li></ol><p><strong>Credible Intervals (Bayesian)</strong>: For each MCMC draw, compute IRFs and report posterior quantiles (e.g., 16th and 84th percentiles for 68% intervals).</p><h3 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MacroEconometricModels

Y = randn(200, 3)
model = estimate_var(Y, 2)

# Basic IRF (Cholesky identification)
irf_result = irf(model, 20)

# With bootstrap confidence intervals
irf_ci = irf(model, 20; ci_type=:bootstrap, reps=1000)

# Sign restrictions
sign_constraints = [1 1 0; -1 0 0; 0 0 1]
irf_sign = irf(model, 20; method=:sign, sign_restrictions=sign_constraints)</code></pre><p>The basic <code>irf(model, 20)</code> call uses Cholesky identification by default. Adding <code>ci_type=:bootstrap</code> generates pointwise confidence bands via Kilian&#39;s (1998) residual bootstrap — <code>reps=1000</code> draws are recommended for publication-quality bands. Sign restrictions produce a set of admissible IRFs satisfying the constraints; the returned values are the median (or a representative draw), with the set-identified nature reflected in wider credible bands.</p><div class="admonition is-info" id="Technical-Note-8d3a1508b0ffb2c0"><header class="admonition-header">Technical Note<a class="admonition-anchor" href="#Technical-Note-8d3a1508b0ffb2c0" title="Permalink"></a></header><div class="admonition-body"><p>The <code>ci_lower</code> and <code>ci_upper</code> arrays are only populated when <code>ci_type=:bootstrap</code> (frequentist) or when using the Bayesian <code>irf(chain, ...)</code> method. With <code>ci_type=:none</code> (the default), these arrays contain zeros. Always check <code>irf_result.ci_type</code> before interpreting confidence bands.</p></div></div><h3 id="ImpulseResponse-Return-Values"><a class="docs-heading-anchor" href="#ImpulseResponse-Return-Values">ImpulseResponse Return Values</a><a id="ImpulseResponse-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#ImpulseResponse-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>values</code></td><td style="text-align: right"><code>Array{T,3}</code></td><td style="text-align: right"><span>$(H+1) \times n \times n$</span> IRF array: <code>values[h+1, i, j]</code> = response of variable <span>$i$</span> to shock <span>$j$</span> at horizon <span>$h$</span></td></tr><tr><td style="text-align: right"><code>ci_lower</code></td><td style="text-align: right"><code>Array{T,3}</code></td><td style="text-align: right">Lower confidence bound (same shape as <code>values</code>)</td></tr><tr><td style="text-align: right"><code>ci_upper</code></td><td style="text-align: right"><code>Array{T,3}</code></td><td style="text-align: right">Upper confidence bound</td></tr><tr><td style="text-align: right"><code>horizon</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Maximum IRF horizon <span>$H$</span></td></tr><tr><td style="text-align: right"><code>variables</code></td><td style="text-align: right"><code>Vector{String}</code></td><td style="text-align: right">Variable names</td></tr><tr><td style="text-align: right"><code>shocks</code></td><td style="text-align: right"><code>Vector{String}</code></td><td style="text-align: right">Shock names</td></tr><tr><td style="text-align: right"><code>ci_type</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">CI method used (<code>:bootstrap</code>, <code>:none</code>, etc.)</td></tr></table><h3 id="BayesianImpulseResponse-Return-Values"><a class="docs-heading-anchor" href="#BayesianImpulseResponse-Return-Values">BayesianImpulseResponse Return Values</a><a id="BayesianImpulseResponse-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#BayesianImpulseResponse-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>quantiles</code></td><td style="text-align: right"><code>Array{T,4}</code></td><td style="text-align: right"><span>$(H+1) \times n \times n \times 3$</span>: dimension 4 = [16th pctl, median, 84th pctl]</td></tr><tr><td style="text-align: right"><code>mean</code></td><td style="text-align: right"><code>Array{T,3}</code></td><td style="text-align: right"><span>$(H+1) \times n \times n$</span> posterior mean IRF</td></tr><tr><td style="text-align: right"><code>horizon</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Maximum IRF horizon</td></tr><tr><td style="text-align: right"><code>variables</code></td><td style="text-align: right"><code>Vector{String}</code></td><td style="text-align: right">Variable names</td></tr><tr><td style="text-align: right"><code>shocks</code></td><td style="text-align: right"><code>Vector{String}</code></td><td style="text-align: right">Shock names</td></tr><tr><td style="text-align: right"><code>quantile_levels</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Quantile levels (e.g., <code>[0.16, 0.5, 0.84]</code>)</td></tr></table><p><strong>Reference</strong>: Kilian (1998), Lütkepohl (2005, Chapter 3)</p><hr/><h2 id="Forecast-Error-Variance-Decomposition-(FEVD)"><a class="docs-heading-anchor" href="#Forecast-Error-Variance-Decomposition-(FEVD)">Forecast Error Variance Decomposition (FEVD)</a><a id="Forecast-Error-Variance-Decomposition-(FEVD)-1"></a><a class="docs-heading-anchor-permalink" href="#Forecast-Error-Variance-Decomposition-(FEVD)" title="Permalink"></a></h2><h3 id="Definition-2"><a class="docs-heading-anchor" href="#Definition-2">Definition</a><a class="docs-heading-anchor-permalink" href="#Definition-2" title="Permalink"></a></h3><p>The FEVD measures the proportion of the <span>$h$</span>-step ahead forecast error variance of variable <span>$i$</span> attributable to structural shock <span>$j$</span>:</p><p class="math-container">\[\text{FEVD}_{ij}(h) = \frac{\sum_{s=0}^{h-1} (\Theta_s)_{ij}^2}{\sum_{s=0}^{h-1} \sum_{k=1}^{n} (\Theta_s)_{ik}^2}\]</p><p>where</p><ul><li><span>$\text{FEVD}_{ij}(h)$</span> is the share of variable <span>$i$</span>&#39;s <span>$h$</span>-step forecast error variance due to shock <span>$j$</span></li><li><span>$(\Theta_s)_{ij}$</span> is the <span>$(i,j)$</span> element of the impulse response matrix at horizon <span>$s$</span></li><li>The numerator sums the squared contributions of shock <span>$j$</span> through horizon <span>$h-1$</span></li><li>The denominator sums contributions from all <span>$n$</span> shocks, ensuring <span>$\sum_j \text{FEVD}_{ij}(h) = 1$</span></li></ul><h3 id="Properties"><a class="docs-heading-anchor" href="#Properties">Properties</a><a id="Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Properties" title="Permalink"></a></h3><ul><li><span>$0 \leq \text{FEVD}_{ij}(h) \leq 1$</span> for all <span>$i, j, h$</span></li><li><span>$\sum_{j=1}^{n} \text{FEVD}_{ij}(h) = 1$</span> for all <span>$i, h$</span></li><li>As <span>$h \to \infty$</span>, FEVD converges to the unconditional variance decomposition</li></ul><h3 id="Usage-2"><a class="docs-heading-anchor" href="#Usage-2">Usage</a><a class="docs-heading-anchor-permalink" href="#Usage-2" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Basic FEVD
fevd_result = fevd(model, 20)

# With bootstrap CI
fevd_ci = fevd(model, 20; ci_type=:bootstrap, reps=500)

# Access decomposition for variable 1
fevd_var1 = fevd_result.decomposition[:, 1, :]  # horizons × shocks</code></pre><p>The <code>proportions</code> array satisfies <span>$\sum_j \text{proportions}[h, i, j] = 1$</span> for all horizons <span>$h$</span> and variables <span>$i$</span>. At short horizons, own shocks typically dominate (large diagonal entries). As <span>$h \to \infty$</span>, the FEVD converges to the unconditional variance decomposition, revealing which shocks are the dominant long-run drivers of each variable&#39;s fluctuations. Adding <code>ci_type=:bootstrap</code> produces bootstrap CIs that quantify estimation uncertainty in the FEVD shares.</p><h3 id="FEVD-Return-Values"><a class="docs-heading-anchor" href="#FEVD-Return-Values">FEVD Return Values</a><a id="FEVD-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#FEVD-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>decomposition</code></td><td style="text-align: right"><code>Array{T,3}</code></td><td style="text-align: right"><span>$H \times n \times n$</span> raw variance contributions</td></tr><tr><td style="text-align: right"><code>proportions</code></td><td style="text-align: right"><code>Array{T,3}</code></td><td style="text-align: right"><span>$H \times n \times n$</span> proportion of FEV: <code>proportions[h, i, j]</code> = share of variable <span>$i$</span>&#39;s FEV due to shock <span>$j$</span> at horizon <span>$h$</span></td></tr></table><h3 id="BayesianFEVD-Return-Values"><a class="docs-heading-anchor" href="#BayesianFEVD-Return-Values">BayesianFEVD Return Values</a><a id="BayesianFEVD-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#BayesianFEVD-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>quantiles</code></td><td style="text-align: right"><code>Array{T,4}</code></td><td style="text-align: right"><span>$H \times n \times n \times 3$</span>: dimension 4 = [16th pctl, median, 84th pctl]</td></tr><tr><td style="text-align: right"><code>mean</code></td><td style="text-align: right"><code>Array{T,3}</code></td><td style="text-align: right"><span>$H \times n \times n$</span> posterior mean FEVD proportions</td></tr><tr><td style="text-align: right"><code>horizon</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Maximum horizon</td></tr><tr><td style="text-align: right"><code>variables</code></td><td style="text-align: right"><code>Vector{String}</code></td><td style="text-align: right">Variable names</td></tr><tr><td style="text-align: right"><code>shocks</code></td><td style="text-align: right"><code>Vector{String}</code></td><td style="text-align: right">Shock names</td></tr><tr><td style="text-align: right"><code>quantile_levels</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Quantile levels</td></tr></table><p><strong>Reference</strong>: Lütkepohl (2005, Section 2.3.3)</p><hr/><h2 id="Historical-Decomposition-(HD)"><a class="docs-heading-anchor" href="#Historical-Decomposition-(HD)">Historical Decomposition (HD)</a><a id="Historical-Decomposition-(HD)-1"></a><a class="docs-heading-anchor-permalink" href="#Historical-Decomposition-(HD)" title="Permalink"></a></h2><h3 id="Definition-3"><a class="docs-heading-anchor" href="#Definition-3">Definition</a><a class="docs-heading-anchor-permalink" href="#Definition-3" title="Permalink"></a></h3><p>Historical decomposition decomposes observed variable movements into contributions from individual structural shocks over time:</p><p class="math-container">\[y_t = \sum_{s=0}^{t-1} \Theta_s \varepsilon_{t-s} + \text{initial conditions}\]</p><p>where</p><ul><li><span>$y_t$</span> is the <span>$n \times 1$</span> vector of observed variables at time <span>$t$</span></li><li><span>$\Theta_s = \Phi_s P$</span> are the <span>$n \times n$</span> structural MA coefficients at lag <span>$s$</span></li><li><span>$\Phi_s$</span> are the reduced-form MA coefficients (from the VMA representation)</li><li><span>$P = L Q$</span> is the <span>$n \times n$</span> impact matrix (Cholesky factor <span>$L$</span> times rotation <span>$Q$</span>)</li><li><span>$\varepsilon_t = Q&#39; L^{-1} u_t$</span> are the <span>$n \times 1$</span> structural shocks</li><li>The initial conditions capture the contribution of pre-sample values</li></ul><h3 id="Contribution-of-Shock-j-to-Variable-i-at-Time-t"><a class="docs-heading-anchor" href="#Contribution-of-Shock-j-to-Variable-i-at-Time-t">Contribution of Shock j to Variable i at Time t</a><a id="Contribution-of-Shock-j-to-Variable-i-at-Time-t-1"></a><a class="docs-heading-anchor-permalink" href="#Contribution-of-Shock-j-to-Variable-i-at-Time-t" title="Permalink"></a></h3><p class="math-container">\[\text{HD}_{ij}(t) = \sum_{s=0}^{t-1} (\Theta_s)_{ij} \, \varepsilon_j(t-s)\]</p><p>where</p><ul><li><span>$\text{HD}_{ij}(t)$</span> is the contribution of shock <span>$j$</span> to variable <span>$i$</span> at time <span>$t$</span></li><li><span>$(\Theta_s)_{ij}$</span> is the <span>$(i,j)$</span> element of the structural MA coefficient at lag <span>$s$</span></li><li><span>$\varepsilon_j(t-s)$</span> is the realized structural shock <span>$j$</span> at time <span>$t-s$</span></li></ul><p>The decomposition satisfies the identity:</p><p class="math-container">\[y_t = \sum_{j=1}^{n} \text{HD}_{ij}(t) + \text{initial}_i(t)\]</p><h3 id="Usage-3"><a class="docs-heading-anchor" href="#Usage-3">Usage</a><a class="docs-heading-anchor-permalink" href="#Usage-3" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Basic historical decomposition
hd = historical_decomposition(model, 198)

# Verify decomposition identity
verify_decomposition(hd)  # returns true if identity holds

# Get contribution of shock 1 to variable 2
contrib = contribution(hd, 2, 1)

# Total shock contribution (excluding initial conditions)
total = total_shock_contribution(hd, 1)

# With different identification
hd_sign = historical_decomposition(model, 198; method=:sign,
    sign_restrictions=sign_constraints)</code></pre><p>The <code>contributions[t, i, j]</code> array gives the contribution of shock <span>$j$</span> to variable <span>$i$</span> at time <span>$t$</span>. Summing across shocks plus the initial conditions recovers the actual data: <code>verify_decomposition(hd)</code> checks this identity holds to numerical precision. The <code>total_shock_contribution(hd, i)</code> function sums all shock contributions for variable <span>$i$</span>, providing the &quot;shock-driven&quot; component of the series with initial conditions removed.</p><h3 id="HistoricalDecomposition-Return-Values"><a class="docs-heading-anchor" href="#HistoricalDecomposition-Return-Values">HistoricalDecomposition Return Values</a><a id="HistoricalDecomposition-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#HistoricalDecomposition-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>contributions</code></td><td style="text-align: right"><code>Array{T,3}</code></td><td style="text-align: right"><span>$T_{eff} \times n \times n$</span> shock contributions: <code>contributions[t, i, j]</code> = contribution of shock <span>$j$</span> to variable <span>$i$</span> at time <span>$t$</span></td></tr><tr><td style="text-align: right"><code>initial_conditions</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$T_{eff} \times n$</span> initial condition component</td></tr><tr><td style="text-align: right"><code>actual</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$T_{eff} \times n$</span> actual data values</td></tr><tr><td style="text-align: right"><code>shocks</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$T_{eff} \times n$</span> structural shocks</td></tr><tr><td style="text-align: right"><code>T_eff</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Effective number of time periods</td></tr><tr><td style="text-align: right"><code>variables</code></td><td style="text-align: right"><code>Vector{String}</code></td><td style="text-align: right">Variable names</td></tr><tr><td style="text-align: right"><code>shock_names</code></td><td style="text-align: right"><code>Vector{String}</code></td><td style="text-align: right">Shock names</td></tr><tr><td style="text-align: right"><code>method</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Identification method (<code>:cholesky</code>, <code>:sign</code>, etc.)</td></tr></table><h3 id="BayesianHistoricalDecomposition-Return-Values"><a class="docs-heading-anchor" href="#BayesianHistoricalDecomposition-Return-Values">BayesianHistoricalDecomposition Return Values</a><a id="BayesianHistoricalDecomposition-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#BayesianHistoricalDecomposition-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>quantiles</code></td><td style="text-align: right"><code>Array{T,4}</code></td><td style="text-align: right"><span>$T_{eff} \times n \times n \times n_q$</span> contribution quantiles</td></tr><tr><td style="text-align: right"><code>mean</code></td><td style="text-align: right"><code>Array{T,3}</code></td><td style="text-align: right"><span>$T_{eff} \times n \times n$</span> mean contributions</td></tr><tr><td style="text-align: right"><code>initial_quantiles</code></td><td style="text-align: right"><code>Array{T,3}</code></td><td style="text-align: right"><span>$T_{eff} \times n \times n_q$</span> initial condition quantiles</td></tr><tr><td style="text-align: right"><code>initial_mean</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$T_{eff} \times n$</span> mean initial conditions</td></tr><tr><td style="text-align: right"><code>shocks_mean</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$T_{eff} \times n$</span> mean structural shocks</td></tr><tr><td style="text-align: right"><code>actual</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$T_{eff} \times n$</span> actual data values</td></tr><tr><td style="text-align: right"><code>T_eff</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Effective number of time periods</td></tr><tr><td style="text-align: right"><code>variables</code></td><td style="text-align: right"><code>Vector{String}</code></td><td style="text-align: right">Variable names</td></tr><tr><td style="text-align: right"><code>shock_names</code></td><td style="text-align: right"><code>Vector{String}</code></td><td style="text-align: right">Shock names</td></tr><tr><td style="text-align: right"><code>quantile_levels</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Quantile levels</td></tr><tr><td style="text-align: right"><code>method</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Identification method</td></tr></table><p><strong>Reference</strong>: Kilian &amp; Lütkepohl (2017, Chapter 4)</p><hr/><h2 id="LP-Based-Innovation-Accounting"><a class="docs-heading-anchor" href="#LP-Based-Innovation-Accounting">LP-Based Innovation Accounting</a><a id="LP-Based-Innovation-Accounting-1"></a><a class="docs-heading-anchor-permalink" href="#LP-Based-Innovation-Accounting" title="Permalink"></a></h2><p>Structural Local Projections provide the same innovation accounting tools (IRF, FEVD, HD) as standard VAR, but via LP estimation. This offers robustness to VAR dynamic misspecification at the cost of some efficiency. For full theoretical background, see <a href="../lp/">Local Projections</a>.</p><h3 id="IRF-from-Structural-LP"><a class="docs-heading-anchor" href="#IRF-from-Structural-LP">IRF from Structural LP</a><a id="IRF-from-Structural-LP-1"></a><a class="docs-heading-anchor-permalink" href="#IRF-from-Structural-LP" title="Permalink"></a></h3><p>The <code>irf()</code> function dispatches on <code>StructuralLP</code> to return the pre-computed 3D impulse response:</p><pre><code class="language-julia hljs">slp = structural_lp(Y, 20; method=:cholesky, lags=4)
irf_result = irf(slp)   # Returns ImpulseResponse from the StructuralLP

# Access: irf_result.values[h, i, j] = response of var i to shock j at horizon h
println(&quot;Impact of shock 1 on var 2: &quot;, irf_result.values[1, 2, 1])</code></pre><p>The LP-based IRFs are numerically close to VAR-based IRFs under correct specification (Plagborg-Møller &amp; Wolf 2021), but the LP standard errors stored in <code>slp.se</code> are wider because each horizon is estimated independently without imposing cross-horizon restrictions.</p><h3 id="FEVD-from-Structural-LP"><a class="docs-heading-anchor" href="#FEVD-from-Structural-LP">FEVD from Structural LP</a><a id="FEVD-from-Structural-LP-1"></a><a class="docs-heading-anchor-permalink" href="#FEVD-from-Structural-LP" title="Permalink"></a></h3><p>The <code>fevd()</code> method for <code>StructuralLP</code> dispatches to the R²-based LP-FEVD of Gorodnichenko &amp; Lee (2019):</p><pre><code class="language-julia hljs">decomp = fevd(slp, 20)  # Returns LPFEVD

# Bias-corrected shares
println(&quot;Var 1 explained by Shock 1 at h=8: &quot;,
        round(decomp.bias_corrected[1, 1, 8] * 100, digits=1), &quot;%&quot;)</code></pre><p>Unlike VMA-based FEVD, LP-FEVD estimates variance shares directly via R² regressions, so they do not depend on the invertibility of the VAR lag polynomial. See <a href="../lp/#LP-Based-FEVD">LP-Based FEVD</a> for the three estimator variants (R², LP-A, LP-B) and bias correction details.</p><h3 id="Historical-Decomposition-from-Structural-LP"><a class="docs-heading-anchor" href="#Historical-Decomposition-from-Structural-LP">Historical Decomposition from Structural LP</a><a id="Historical-Decomposition-from-Structural-LP-1"></a><a class="docs-heading-anchor-permalink" href="#Historical-Decomposition-from-Structural-LP" title="Permalink"></a></h3><pre><code class="language-julia hljs">hd = historical_decomposition(slp)
verify_decomposition(hd)  # Check additive identity</code></pre><p>The LP-based historical decomposition uses the structural shocks recovered from the VAR identification step (<span>$\hat{\varepsilon}_t = Q&#39;L^{-1}\hat{u}_t$</span>) combined with LP-estimated IRF coefficients to decompose observed variable movements into shock contributions.</p><h3 id="Cumulative-IRF-2"><a class="docs-heading-anchor" href="#Cumulative-IRF-2">Cumulative IRF</a><a class="docs-heading-anchor-permalink" href="#Cumulative-IRF-2" title="Permalink"></a></h3><p>For variables measured in growth rates (e.g., log-differenced GDP), the cumulative IRF shows the effect on the level:</p><pre><code class="language-julia hljs">lp_model = estimate_lp(Y, 1, 20; lags=4)
lp_irfs = lp_irf(lp_model)
cum_irfs = cumulative_irf(lp_irfs)</code></pre><p>The <code>cumulative_irf</code> function sums the pointwise IRF from horizon 0 through <span>$h$</span>, propagating standard errors via the delta method. This is especially useful for comparing LP and VAR results in levels versus differences.</p><hr/><h2 id="Summary-Tables"><a class="docs-heading-anchor" href="#Summary-Tables">Summary Tables</a><a id="Summary-Tables-1"></a><a class="docs-heading-anchor-permalink" href="#Summary-Tables" title="Permalink"></a></h2><p>The package provides publication-quality summary tables using a unified interface with multiple dispatch.</p><h3 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h3><table><tr><th style="text-align: right">Function</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>report(obj)</code></td><td style="text-align: right">Print comprehensive summary to stdout</td></tr><tr><td style="text-align: right"><code>table(obj, ...)</code></td><td style="text-align: right">Extract results as a matrix</td></tr><tr><td style="text-align: right"><code>print_table(io, obj, ...)</code></td><td style="text-align: right">Print formatted table to IO stream</td></tr></table><h3 id="Usage-Examples"><a class="docs-heading-anchor" href="#Usage-Examples">Usage Examples</a><a id="Usage-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Usage-Examples" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MacroEconometricModels

Y = randn(200, 3)
model = estimate_var(Y, 2)
irf_result = irf(model, 20)
fevd_result = fevd(model, 20)
hd_result = historical_decomposition(model, 198)

# Print summaries
report(model)
report(irf_result)
report(fevd_result)
report(hd_result)

# Extract as DataFrames for further analysis
df_irf = table(irf_result, 1, 1)                    # response of var 1 to shock 1
df_irf_sel = table(irf_result, 1, 1; horizons=[1, 4, 8, 12, 20])

df_fevd = table(fevd_result, 1)                     # FEVD for variable 1
df_fevd_sel = table(fevd_result, 1; horizons=[1, 4, 8, 12])

df_hd = table(hd_result, 1)                         # HD for variable 1
df_hd_sel = table(hd_result, 1; periods=180:198)    # specific periods

# Print formatted tables to stdout or file
print_table(stdout, irf_result, 1, 1; horizons=[1, 4, 8, 12])
print_table(stdout, fevd_result, 1; horizons=[1, 4, 8, 12])
print_table(stdout, hd_result, 1; periods=190:198)

# Write to file
open(&quot;results.txt&quot;, &quot;w&quot;) do io
    print_table(io, irf_result, 1, 1)
    print_table(io, fevd_result, 1)
end</code></pre><h3 id="String-Indexing"><a class="docs-heading-anchor" href="#String-Indexing">String Indexing</a><a id="String-Indexing-1"></a><a class="docs-heading-anchor-permalink" href="#String-Indexing" title="Permalink"></a></h3><p>Variables and shocks can be indexed by name:</p><pre><code class="language-julia hljs"># If variable names are set
df = table(irf_result, &quot;GDP&quot;, &quot;Monetary Shock&quot;)
df = table(fevd_result, &quot;Inflation&quot;)
df = table(hd_result, &quot;Output&quot;)</code></pre><hr/><h2 id="Display-Backends"><a class="docs-heading-anchor" href="#Display-Backends">Display Backends</a><a id="Display-Backends-1"></a><a class="docs-heading-anchor-permalink" href="#Display-Backends" title="Permalink"></a></h2><p>All <code>show</code>, <code>print_table</code>, and <code>report</code> methods route through a unified PrettyTables backend. Switching from terminal text to LaTeX or HTML output requires a single call:</p><pre><code class="language-julia hljs"># Switch output format globally
set_display_backend(:text)    # Terminal-friendly (default)
set_display_backend(:latex)   # LaTeX \begin{tabular} output
set_display_backend(:html)    # HTML &lt;table&gt; output

# Check current backend
get_display_backend()         # :text</code></pre><p>This applies to all innovation accounting results — IRF, FEVD, and HD tables:</p><pre><code class="language-julia hljs"># IRF table in LaTeX for a paper
set_display_backend(:latex)
open(&quot;tables/irf_table.tex&quot;, &quot;w&quot;) do io
    print_table(io, irfs, 1, 1; horizons=[1, 4, 8, 12, 20])
end

# FEVD table in HTML for slides
set_display_backend(:html)
open(&quot;slides/fevd.html&quot;, &quot;w&quot;) do io
    print_table(io, fevd_result, 1; horizons=[1, 4, 8, 12, 20])
end

# Reset to text for interactive work
set_display_backend(:text)</code></pre><p>For a comprehensive display backend workflow, see <a href="../examples/#Example-12:-Table-Output-Text,-LaTeX,-and-HTML">Example 12: Table Output</a>.</p><hr/><h2 id="Bibliographic-References"><a class="docs-heading-anchor" href="#Bibliographic-References">Bibliographic References</a><a id="Bibliographic-References-1"></a><a class="docs-heading-anchor-permalink" href="#Bibliographic-References" title="Permalink"></a></h2><p>The <code>refs()</code> function returns bibliographic references for any model or identification method. This integrates with innovation accounting results:</p><pre><code class="language-julia hljs"># References for a VAR model
refs(model)                           # AEA text format (default)
refs(model; format=:bibtex)           # BibTeX format
refs(model; format=:latex)            # LaTeX \bibitem format

# References by identification method
refs(:cholesky)                       # Cholesky decomposition references
refs(:fastica)                        # FastICA references
refs(:sign)                           # Sign restriction references

# Write BibTeX to file
open(&quot;references.bib&quot;, &quot;w&quot;) do io
    refs(io, model; format=:bibtex)
end</code></pre><p>For a comprehensive references workflow, see <a href="../examples/#Example-13:-Bibliographic-References">Example 13: Bibliographic References</a>.</p><div class="admonition is-info" id="Technical-Note-92531c8ca7c328a5"><header class="admonition-header">Technical Note<a class="admonition-anchor" href="#Technical-Note-92531c8ca7c328a5" title="Permalink"></a></header><div class="admonition-body"><p>For non-Gaussian identification methods (ICA, ML, heteroskedasticity-based), see <a href="../nongaussian/">Non-Gaussian Structural Identification</a>. All 18 identification methods work seamlessly with <code>irf()</code>, <code>fevd()</code>, and <code>historical_decomposition()</code> via the <code>method</code> keyword.</p></div></div><hr/><h2 id="Complete-Example"><a class="docs-heading-anchor" href="#Complete-Example">Complete Example</a><a id="Complete-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-Example" title="Permalink"></a></h2><p>This example combines IRF, FEVD, and HD for a three-variable VAR.</p><pre><code class="language-julia hljs">using MacroEconometricModels
using Random

Random.seed!(42)

# Simulate a 3-variable VAR(2)
T, n, p = 200, 3, 2
Y = randn(T, n)
for t in 2:T
    Y[t, :] = 0.5 * Y[t-1, :] + 0.3 * randn(n)
end

model = estimate_var(Y, p)

# IRF with bootstrap confidence intervals
H = 20
irfs = irf(model, H; method=:cholesky, ci_type=:bootstrap, reps=500)
println(&quot;Shock 1 → Var 1 at h=0: &quot;, round(irfs.values[1, 1, 1], digits=3))
println(&quot;Shock 1 → Var 1 at h=8: &quot;, round(irfs.values[9, 1, 1], digits=3))

# FEVD
decomp = fevd(model, H)
println(&quot;\nFEVD for Var 1 at h=1: shock shares = &quot;,
        round.(decomp.proportions[1, 1, :] .* 100, digits=1), &quot;%&quot;)
println(&quot;FEVD for Var 1 at h=20: shock shares = &quot;,
        round.(decomp.proportions[20, 1, :] .* 100, digits=1), &quot;%&quot;)

# Historical decomposition
hd = historical_decomposition(model, size(model.U, 1))
println(&quot;\nDecomposition identity holds: &quot;, verify_decomposition(hd))

# Summary tables
df_irf = table(irfs, 1, 1; horizons=[0, 4, 8, 12, 20])
df_fevd = table(decomp, 1; horizons=[1, 4, 8, 20])</code></pre><p>The IRF values show the dynamic propagation of structural shocks through the system. At impact (<span>$h=0$</span>), the Cholesky identification imposes a lower-triangular structure, so shock 1 affects only the first variable contemporaneously. By <span>$h=8$</span>, cross-variable transmission is visible. The FEVD reveals whether the first variable&#39;s forecast uncertainty is dominated by its own shocks or by spillovers from other variables. At short horizons own shocks typically dominate; as <span>$h \to \infty$</span>, the FEVD converges to the unconditional variance decomposition. The HD passes the verification check, confirming the additive identity <span>$y_t = \sum_j \text{HD}_j(t) + \text{initial}(t)$</span> holds to numerical precision.</p><hr/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><ul><li>Kilian, Lutz. 1998. &quot;Small-Sample Confidence Intervals for Impulse Response Functions.&quot; <em>Review of Economics and Statistics</em> 80 (2): 218–230. <a href="https://doi.org/10.1162/003465398557465">https://doi.org/10.1162/003465398557465</a></li><li>Kilian, Lutz, and Helmut Lütkepohl. 2017. <em>Structural Vector Autoregressive Analysis</em>. Cambridge: Cambridge University Press. <a href="https://doi.org/10.1017/9781108164818">https://doi.org/10.1017/9781108164818</a></li><li>Lütkepohl, Helmut. 2005. <em>New Introduction to Multiple Time Series Analysis</em>. Berlin: Springer. ISBN 978-3-540-40172-8.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../bayesian/">« Bayesian VAR</a><a class="docs-footer-nextpage" href="../nongaussian/">Non-Gaussian Structural Identification »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 7 February 2026 11:44">Saturday 7 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
