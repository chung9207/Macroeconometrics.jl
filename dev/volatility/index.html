<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Volatility Models · MacroEconometricModels.jl</title><meta name="title" content="Volatility Models · MacroEconometricModels.jl"/><meta property="og:title" content="Volatility Models · MacroEconometricModels.jl"/><meta property="twitter:title" content="Volatility Models · MacroEconometricModels.jl"/><meta name="description" content="Documentation for MacroEconometricModels.jl."/><meta property="og:description" content="Documentation for MacroEconometricModels.jl."/><meta property="twitter:description" content="Documentation for MacroEconometricModels.jl."/><meta property="og:url" content="https://chung9207.github.io/MacroEconometricModels.jl/volatility/"/><meta property="twitter:url" content="https://chung9207.github.io/MacroEconometricModels.jl/volatility/"/><link rel="canonical" href="https://chung9207.github.io/MacroEconometricModels.jl/volatility/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MacroEconometricModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Univariate Models</span><ul><li><a class="tocitem" href="../arima/">ARIMA</a></li><li class="is-active"><a class="tocitem" href>Volatility Models</a><ul class="internal"><li><a class="tocitem" href="#Quick-Start"><span>Quick Start</span></a></li><li><a class="tocitem" href="#ARCH-Models"><span>ARCH Models</span></a></li><li><a class="tocitem" href="#GARCH-Models"><span>GARCH Models</span></a></li><li><a class="tocitem" href="#Stochastic-Volatility"><span>Stochastic Volatility</span></a></li><li><a class="tocitem" href="#Volatility-Forecasting"><span>Volatility Forecasting</span></a></li><li><a class="tocitem" href="#Type-Accessors"><span>Type Accessors</span></a></li><li><a class="tocitem" href="#StatsAPI-Interface"><span>StatsAPI Interface</span></a></li><li><a class="tocitem" href="#Complete-Example"><span>Complete Example</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li></ul></li><li><span class="tocitem">Frequentist Models</span><ul><li><a class="tocitem" href="../manual/">VAR</a></li><li><a class="tocitem" href="../lp/">Local Projections</a></li><li><a class="tocitem" href="../factormodels/">Factor Models</a></li></ul></li><li><span class="tocitem">Bayesian Models</span><ul><li><a class="tocitem" href="../bayesian/">Bayesian VAR</a></li></ul></li><li><a class="tocitem" href="../innovation_accounting/">Innovation Accounting</a></li><li><a class="tocitem" href="../nongaussian/">Non-Gaussian Structural Identification</a></li><li><span class="tocitem">Hypothesis Tests</span><ul><li><a class="tocitem" href="../hypothesis_tests/">Unit Root &amp; Cointegration</a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../api/">Overview</a></li><li><a class="tocitem" href="../api_types/">Types</a></li><li><a class="tocitem" href="../api_functions/">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Univariate Models</a></li><li class="is-active"><a href>Volatility Models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Volatility Models</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/chung9207/MacroEconometricModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/main/docs/src/volatility.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Volatility-Models"><a class="docs-heading-anchor" href="#Volatility-Models">Volatility Models</a><a id="Volatility-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Volatility-Models" title="Permalink"></a></h1><p>This page covers univariate volatility modeling: ARCH, GARCH (including EGARCH and GJR-GARCH), and Stochastic Volatility (SV) models. These models capture time-varying conditional variance — a pervasive feature of financial and macroeconomic time series.</p><h2 id="Quick-Start"><a class="docs-heading-anchor" href="#Quick-Start">Quick Start</a><a id="Quick-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Start" title="Permalink"></a></h2><pre><code class="language-julia hljs">using MacroEconometricModels

y = randn(500)  # Replace with your returns data

# ARCH(5) — Engle (1982)
arch = estimate_arch(y, 5)

# GARCH(1,1) — Bollerslev (1986)
garch = estimate_garch(y, 1, 1)

# EGARCH(1,1) — Nelson (1991)
egarch = estimate_egarch(y, 1, 1)

# GJR-GARCH(1,1) — Glosten, Jagannathan &amp; Runkle (1993)
gjr = estimate_gjr_garch(y, 1, 1)

# Stochastic Volatility — Taylor (1986)
sv = estimate_sv(y; n_samples=2000, n_adapts=1000)

# Diagnostics
arch_lm_test(y, 5)         # ARCH-LM test
ljung_box_squared(y, 10)   # Ljung-Box on squared residuals
nic = news_impact_curve(garch)  # News impact curve

# Forecast 20 steps ahead
fc = forecast(garch, 20; conf_level=0.95)</code></pre><hr/><h2 id="ARCH-Models"><a class="docs-heading-anchor" href="#ARCH-Models">ARCH Models</a><a id="ARCH-Models-1"></a><a class="docs-heading-anchor-permalink" href="#ARCH-Models" title="Permalink"></a></h2><h3 id="Theory"><a class="docs-heading-anchor" href="#Theory">Theory</a><a id="Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Theory" title="Permalink"></a></h3><p>The Autoregressive Conditional Heteroskedasticity (ARCH) model of Engle (1982) allows the conditional variance to depend on past squared innovations. The ARCH(<span>$q$</span>) specification is:</p><p class="math-container">\[y_t = \mu + \varepsilon_t, \qquad \varepsilon_t = \sigma_t z_t, \qquad z_t \sim \mathcal{N}(0, 1)\]</p><p class="math-container">\[\sigma^2_t = \omega + \sum_{i=1}^{q} \alpha_i \varepsilon^2_{t-i}\]</p><p>where</p><ul><li><span>$y_t$</span> is the observed time series</li><li><span>$\mu$</span> is the conditional mean (intercept)</li><li><span>$\varepsilon_t$</span> is the mean-corrected innovation</li><li><span>$\sigma^2_t$</span> is the conditional variance at time <span>$t$</span></li><li><span>$\omega &gt; 0$</span> is the variance intercept</li><li><span>$\alpha_i \geq 0$</span> are the ARCH coefficients</li><li><span>$z_t$</span> is a standardized innovation</li></ul><p><strong>Stationarity condition</strong>: The ARCH(<span>$q$</span>) process is covariance stationary if <span>$\sum_{i=1}^{q} \alpha_i &lt; 1$</span>.</p><p><strong>Unconditional variance</strong>: Under stationarity, <span>$\text{Var}(\varepsilon_t) = \omega / (1 - \sum_{i=1}^{q} \alpha_i)$</span>.</p><h3 id="Estimation"><a class="docs-heading-anchor" href="#Estimation">Estimation</a><a id="Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Estimation" title="Permalink"></a></h3><p>ARCH models are estimated by maximum likelihood (MLE) using two-stage optimization:</p><ol><li><strong>Stage 1</strong> (NelderMead): Derivative-free search to find a good starting region.</li><li><strong>Stage 2</strong> (L-BFGS): Gradient-based refinement from the Stage 1 solution.</li></ol><p>Parameters are log-transformed internally to enforce positivity constraints (<span>$\omega &gt; 0$</span>, <span>$\alpha_i \geq 0$</span>) without constrained optimization.</p><pre><code class="language-julia hljs"># Estimate ARCH(5) model
arch = estimate_arch(y, 5)

# Access estimated parameters
arch.omega      # Variance intercept
arch.alpha      # ARCH coefficients [α₁, ..., α₅]
arch.mu         # Mean
arch.loglik     # Log-likelihood</code></pre><h3 id="Diagnostics"><a class="docs-heading-anchor" href="#Diagnostics">Diagnostics</a><a id="Diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Diagnostics" title="Permalink"></a></h3><p>Two diagnostic tests check whether ARCH effects have been adequately captured:</p><p><strong>ARCH-LM Test</strong> (Engle 1982): Tests for remaining ARCH effects in model residuals or raw data.</p><pre><code class="language-julia hljs"># Test raw data for ARCH effects (H₀: no ARCH effects)
stat, pval, q = arch_lm_test(y, 5)

# Test standardized residuals after fitting (should fail to reject)
stat, pval, q = arch_lm_test(arch, 5)</code></pre><p>The test regresses squared residuals on <span>$q$</span> of their own lags and computes <span>$TR^2 \sim \chi^2(q)$</span>. Rejection of <span>$H_0$</span> indicates ARCH effects are present (or remain after fitting).</p><p><strong>Ljung-Box Test on Squared Residuals</strong>: Tests for serial correlation in <span>$z_t^2$</span>.</p><pre><code class="language-julia hljs">stat, pval, K = ljung_box_squared(arch, 10)</code></pre><p>The test statistic is <span>$Q = n(n+2) \sum_{k=1}^{K} \hat{\rho}^2_k / (n - k) \sim \chi^2(K)$</span>, where <span>$\hat{\rho}_k$</span> is the sample autocorrelation of squared standardized residuals at lag <span>$k$</span>. Failure to reject indicates the model has adequately captured the variance dynamics.</p><h3 id="ARCHModel-Return-Values"><a class="docs-heading-anchor" href="#ARCHModel-Return-Values">ARCHModel Return Values</a><a id="ARCHModel-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#ARCHModel-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>y</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Original data</td></tr><tr><td style="text-align: right"><code>q</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">ARCH order</td></tr><tr><td style="text-align: right"><code>mu</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Estimated mean (intercept)</td></tr><tr><td style="text-align: right"><code>omega</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Variance intercept <span>$\omega$</span></td></tr><tr><td style="text-align: right"><code>alpha</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">ARCH coefficients <span>$[\alpha_1, \ldots, \alpha_q]$</span></td></tr><tr><td style="text-align: right"><code>conditional_variance</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Estimated <span>$\hat{\sigma}^2_t$</span> at each <span>$t$</span></td></tr><tr><td style="text-align: right"><code>standardized_residuals</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right"><span>$\hat{z}_t = \hat{\varepsilon}_t / \hat{\sigma}_t$</span></td></tr><tr><td style="text-align: right"><code>residuals</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Raw residuals <span>$\hat{\varepsilon}_t = y_t - \hat{\mu}$</span></td></tr><tr><td style="text-align: right"><code>fitted</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Fitted values (mean)</td></tr><tr><td style="text-align: right"><code>loglik</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Maximized log-likelihood</td></tr><tr><td style="text-align: right"><code>aic</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Akaike Information Criterion</td></tr><tr><td style="text-align: right"><code>bic</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Bayesian Information Criterion</td></tr><tr><td style="text-align: right"><code>method</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Estimation method (<code>:mle</code>)</td></tr><tr><td style="text-align: right"><code>converged</code></td><td style="text-align: right"><code>Bool</code></td><td style="text-align: right">Whether optimization converged</td></tr><tr><td style="text-align: right"><code>iterations</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of optimizer iterations</td></tr></table><hr/><h2 id="GARCH-Models"><a class="docs-heading-anchor" href="#GARCH-Models">GARCH Models</a><a id="GARCH-Models-1"></a><a class="docs-heading-anchor-permalink" href="#GARCH-Models" title="Permalink"></a></h2><h3 id="GARCH(p,q)-—-Bollerslev-(1986)"><a class="docs-heading-anchor" href="#GARCH(p,q)-—-Bollerslev-(1986)">GARCH(p,q) — Bollerslev (1986)</a><a id="GARCH(p,q)-—-Bollerslev-(1986)-1"></a><a class="docs-heading-anchor-permalink" href="#GARCH(p,q)-—-Bollerslev-(1986)" title="Permalink"></a></h3><p>The Generalized ARCH model extends ARCH by including lagged conditional variances:</p><p class="math-container">\[\sigma^2_t = \omega + \sum_{i=1}^{q} \alpha_i \varepsilon^2_{t-i} + \sum_{j=1}^{p} \beta_j \sigma^2_{t-j}\]</p><p>where</p><ul><li><span>$\omega &gt; 0$</span> is the variance intercept</li><li><span>$\alpha_i \geq 0$</span> are the ARCH coefficients (impact of past shocks)</li><li><span>$\beta_j \geq 0$</span> are the GARCH coefficients (variance persistence)</li><li><span>$p$</span> is the GARCH order (lagged variances) and <span>$q$</span> is the ARCH order (lagged squared residuals)</li></ul><p><strong>Stationarity condition</strong>: <span>$\sum_{i=1}^{q} \alpha_i + \sum_{j=1}^{p} \beta_j &lt; 1$</span>.</p><p><strong>Unconditional variance</strong>: <span>$\sigma^2 = \omega / (1 - \sum \alpha_i - \sum \beta_j)$</span>.</p><p>The GARCH(1,1) is the most widely used specification in practice, capturing the key empirical regularity of volatility clustering with just three parameters.</p><pre><code class="language-julia hljs"># Estimate GARCH(1,1) — the workhorse specification
garch = estimate_garch(y, 1, 1)

# Persistence: how quickly volatility reverts to its long-run level
persistence(garch)              # α₁ + β₁ (close to 1 = slow reversion)
halflife(garch)                 # Half-life in periods
unconditional_variance(garch)   # Long-run variance level</code></pre><h3 id="EGARCH(p,q)-—-Nelson-(1991)"><a class="docs-heading-anchor" href="#EGARCH(p,q)-—-Nelson-(1991)">EGARCH(p,q) — Nelson (1991)</a><a id="EGARCH(p,q)-—-Nelson-(1991)-1"></a><a class="docs-heading-anchor-permalink" href="#EGARCH(p,q)-—-Nelson-(1991)" title="Permalink"></a></h3><p>The Exponential GARCH models the log of conditional variance, ensuring positivity without parameter constraints and allowing asymmetric responses to positive and negative shocks:</p><p class="math-container">\[\log(\sigma^2_t) = \omega + \sum_{i=1}^{q} \alpha_i (|z_{t-i}| - \mathbb{E}|z|) + \sum_{i=1}^{q} \gamma_i z_{t-i} + \sum_{j=1}^{p} \beta_j \log(\sigma^2_{t-j})\]</p><p>where</p><ul><li><span>$z_t = \varepsilon_t / \sigma_t$</span> are standardized residuals</li><li><span>$\alpha_i$</span> captures the magnitude (symmetric) effect of shocks</li><li><span>$\gamma_i$</span> captures the sign (asymmetric/leverage) effect — typically <span>$\gamma_i &lt; 0$</span> means negative shocks increase volatility more than positive shocks of equal magnitude</li><li><span>$\beta_j$</span> governs persistence of log-variance</li><li><span>$\mathbb{E}|z| = \sqrt{2/\pi}$</span> for standard normal innovations</li></ul><p><strong>Stationarity condition</strong>: <span>$\sum_{j=1}^{p} \beta_j &lt; 1$</span> (in log-variance, unconditional parameters).</p><p><strong>Unconditional variance</strong>: <span>$\sigma^2 = \exp(\omega / (1 - \sum \beta_j))$</span>.</p><pre><code class="language-julia hljs"># Estimate EGARCH(1,1)
egarch = estimate_egarch(y, 1, 1)

# Leverage parameters (γ &lt; 0 → &quot;leverage effect&quot;)
egarch.gamma    # Leverage coefficients</code></pre><h3 id="GJR-GARCH(p,q)-—-Glosten,-Jagannathan-and-Runkle-(1993)"><a class="docs-heading-anchor" href="#GJR-GARCH(p,q)-—-Glosten,-Jagannathan-and-Runkle-(1993)">GJR-GARCH(p,q) — Glosten, Jagannathan &amp; Runkle (1993)</a><a id="GJR-GARCH(p,q)-—-Glosten,-Jagannathan-and-Runkle-(1993)-1"></a><a class="docs-heading-anchor-permalink" href="#GJR-GARCH(p,q)-—-Glosten,-Jagannathan-and-Runkle-(1993)" title="Permalink"></a></h3><p>The GJR-GARCH (also called Threshold GARCH) adds an indicator function for negative shocks:</p><p class="math-container">\[\sigma^2_t = \omega + \sum_{i=1}^{q} (\alpha_i + \gamma_i \mathbb{1}(\varepsilon_{t-i} &lt; 0)) \varepsilon^2_{t-i} + \sum_{j=1}^{p} \beta_j \sigma^2_{t-j}\]</p><p>where</p><ul><li><span>$\gamma_i \geq 0$</span> are leverage parameters</li><li><span>$\mathbb{1}(\varepsilon_{t-i} &lt; 0) = 1$</span> when past shocks are negative</li></ul><p>When <span>$\gamma_i &gt; 0$</span>, negative shocks have a larger impact on future variance than positive shocks of equal magnitude. This captures the empirical &quot;leverage effect&quot; first documented by Black (1976): stock price declines increase financial leverage, which in turn increases equity volatility.</p><p><strong>Stationarity condition</strong>: <span>$\sum \alpha_i + \sum \gamma_i / 2 + \sum \beta_j &lt; 1$</span>.</p><p><strong>Unconditional variance</strong>: <span>$\sigma^2 = \omega / (1 - \sum \alpha_i - \sum \gamma_i / 2 - \sum \beta_j)$</span>.</p><pre><code class="language-julia hljs"># Estimate GJR-GARCH(1,1)
gjr = estimate_gjr_garch(y, 1, 1)

# Leverage effect: γ &gt; 0 means negative shocks increase variance more
gjr.gamma    # Leverage coefficients</code></pre><h3 id="News-Impact-Curve"><a class="docs-heading-anchor" href="#News-Impact-Curve">News Impact Curve</a><a id="News-Impact-Curve-1"></a><a class="docs-heading-anchor-permalink" href="#News-Impact-Curve" title="Permalink"></a></h3><p>The news impact curve (NIC) shows how a shock <span>$\varepsilon_{t-1}$</span> maps to the next-period conditional variance <span>$\sigma^2_t$</span>, holding all other information constant at the unconditional level. For symmetric models (ARCH, GARCH), the NIC is a parabola centered at zero. For asymmetric models (EGARCH, GJR-GARCH), the NIC is steeper for negative shocks.</p><pre><code class="language-julia hljs"># Compute news impact curves
nic_garch  = news_impact_curve(garch)
nic_egarch = news_impact_curve(egarch; range=(-3.0, 3.0), n_points=200)
nic_gjr    = news_impact_curve(gjr)

# Returns named tuple: (shocks=Vector, variance=Vector)
nic_garch.shocks     # Grid of εₜ₋₁ values
nic_garch.variance   # Corresponding σ²ₜ values</code></pre><p>Comparing news impact curves across models reveals whether asymmetric specifications (EGARCH, GJR-GARCH) capture economically important leverage effects that symmetric GARCH misses. If the NIC from GARCH and GJR-GARCH are nearly identical, the leverage effect is negligible and the simpler symmetric model suffices.</p><h3 id="GARCH-Family-Return-Values"><a class="docs-heading-anchor" href="#GARCH-Family-Return-Values">GARCH-Family Return Values</a><a id="GARCH-Family-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#GARCH-Family-Return-Values" title="Permalink"></a></h3><p><strong>GARCHModel Fields</strong></p><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>y</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Original data</td></tr><tr><td style="text-align: right"><code>p</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">GARCH order (lagged variances)</td></tr><tr><td style="text-align: right"><code>q</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">ARCH order (lagged squared residuals)</td></tr><tr><td style="text-align: right"><code>mu</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Estimated mean</td></tr><tr><td style="text-align: right"><code>omega</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Variance intercept <span>$\omega$</span></td></tr><tr><td style="text-align: right"><code>alpha</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">ARCH coefficients <span>$[\alpha_1, \ldots, \alpha_q]$</span></td></tr><tr><td style="text-align: right"><code>beta</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">GARCH coefficients <span>$[\beta_1, \ldots, \beta_p]$</span></td></tr><tr><td style="text-align: right"><code>conditional_variance</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Estimated <span>$\hat{\sigma}^2_t$</span></td></tr><tr><td style="text-align: right"><code>standardized_residuals</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right"><span>$\hat{z}_t$</span></td></tr><tr><td style="text-align: right"><code>residuals</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right"><span>$\hat{\varepsilon}_t$</span></td></tr><tr><td style="text-align: right"><code>fitted</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Fitted values</td></tr><tr><td style="text-align: right"><code>loglik</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Log-likelihood</td></tr><tr><td style="text-align: right"><code>aic</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">AIC</td></tr><tr><td style="text-align: right"><code>bic</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">BIC</td></tr><tr><td style="text-align: right"><code>method</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Estimation method</td></tr><tr><td style="text-align: right"><code>converged</code></td><td style="text-align: right"><code>Bool</code></td><td style="text-align: right">Convergence status</td></tr><tr><td style="text-align: right"><code>iterations</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Optimizer iterations</td></tr></table><p><strong>EGARCHModel Fields</strong></p><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>y</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Original data</td></tr><tr><td style="text-align: right"><code>p</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Log-variance persistence order</td></tr><tr><td style="text-align: right"><code>q</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Shock order</td></tr><tr><td style="text-align: right"><code>mu</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Estimated mean</td></tr><tr><td style="text-align: right"><code>omega</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Log-variance intercept</td></tr><tr><td style="text-align: right"><code>alpha</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Magnitude (symmetric) parameters</td></tr><tr><td style="text-align: right"><code>gamma</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Leverage (asymmetric) parameters</td></tr><tr><td style="text-align: right"><code>beta</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Log-variance persistence parameters</td></tr><tr><td style="text-align: right"><code>conditional_variance</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right"><span>$\hat{\sigma}^2_t$</span></td></tr><tr><td style="text-align: right"><code>standardized_residuals</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right"><span>$\hat{z}_t$</span></td></tr><tr><td style="text-align: right"><code>residuals</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right"><span>$\hat{\varepsilon}_t$</span></td></tr><tr><td style="text-align: right"><code>fitted</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Fitted values</td></tr><tr><td style="text-align: right"><code>loglik</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Log-likelihood</td></tr><tr><td style="text-align: right"><code>aic</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">AIC</td></tr><tr><td style="text-align: right"><code>bic</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">BIC</td></tr><tr><td style="text-align: right"><code>method</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Estimation method</td></tr><tr><td style="text-align: right"><code>converged</code></td><td style="text-align: right"><code>Bool</code></td><td style="text-align: right">Convergence status</td></tr><tr><td style="text-align: right"><code>iterations</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Optimizer iterations</td></tr></table><p><strong>GJRGARCHModel Fields</strong></p><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>y</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Original data</td></tr><tr><td style="text-align: right"><code>p</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">GARCH order</td></tr><tr><td style="text-align: right"><code>q</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">ARCH order</td></tr><tr><td style="text-align: right"><code>mu</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Estimated mean</td></tr><tr><td style="text-align: right"><code>omega</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Variance intercept <span>$\omega$</span></td></tr><tr><td style="text-align: right"><code>alpha</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Symmetric ARCH coefficients</td></tr><tr><td style="text-align: right"><code>gamma</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Leverage parameters <span>$[\gamma_1, \ldots, \gamma_q]$</span></td></tr><tr><td style="text-align: right"><code>beta</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">GARCH coefficients</td></tr><tr><td style="text-align: right"><code>conditional_variance</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right"><span>$\hat{\sigma}^2_t$</span></td></tr><tr><td style="text-align: right"><code>standardized_residuals</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right"><span>$\hat{z}_t$</span></td></tr><tr><td style="text-align: right"><code>residuals</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right"><span>$\hat{\varepsilon}_t$</span></td></tr><tr><td style="text-align: right"><code>fitted</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Fitted values</td></tr><tr><td style="text-align: right"><code>loglik</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Log-likelihood</td></tr><tr><td style="text-align: right"><code>aic</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">AIC</td></tr><tr><td style="text-align: right"><code>bic</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">BIC</td></tr><tr><td style="text-align: right"><code>method</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Estimation method</td></tr><tr><td style="text-align: right"><code>converged</code></td><td style="text-align: right"><code>Bool</code></td><td style="text-align: right">Convergence status</td></tr><tr><td style="text-align: right"><code>iterations</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Optimizer iterations</td></tr></table><hr/><h2 id="Stochastic-Volatility"><a class="docs-heading-anchor" href="#Stochastic-Volatility">Stochastic Volatility</a><a id="Stochastic-Volatility-1"></a><a class="docs-heading-anchor-permalink" href="#Stochastic-Volatility" title="Permalink"></a></h2><h3 id="Theory-2"><a class="docs-heading-anchor" href="#Theory-2">Theory</a><a class="docs-heading-anchor-permalink" href="#Theory-2" title="Permalink"></a></h3><p>The stochastic volatility (SV) model of Taylor (1986) treats the log-variance as a latent autoregressive process:</p><p class="math-container">\[y_t = \exp(h_t / 2) \, \varepsilon_t, \qquad \varepsilon_t \sim \mathcal{N}(0, 1)\]</p><p class="math-container">\[h_t = \mu + \varphi (h_{t-1} - \mu) + \sigma_\eta \eta_t, \qquad \eta_t \sim \mathcal{N}(0, 1)\]</p><p>where</p><ul><li><span>$h_t$</span> is the log-variance at time <span>$t$</span></li><li><span>$\mu$</span> is the log-variance level (unconditional mean of <span>$h_t$</span>)</li><li><span>$\varphi \in (-1, 1)$</span> is the persistence parameter</li><li><span>$\sigma_\eta &gt; 0$</span> is the volatility of volatility</li><li><span>$\varepsilon_t$</span> and <span>$\eta_t$</span> are independent standard normal innovations</li></ul><p>The SV model differs fundamentally from GARCH in that volatility has its own independent source of randomness (<span>$\eta_t$</span>), making it a state-space model with a non-Gaussian observation equation. This provides greater flexibility in capturing empirical volatility dynamics, but precludes closed-form likelihood evaluation.</p><h3 id="Variants"><a class="docs-heading-anchor" href="#Variants">Variants</a><a id="Variants-1"></a><a class="docs-heading-anchor-permalink" href="#Variants" title="Permalink"></a></h3><p>Three SV variants are available:</p><p><strong>Basic SV</strong> (<code>leverage=false</code>, <code>dist=:normal</code>): The standard specification above.</p><p><strong>SV with Leverage</strong> (<code>leverage=true</code>): Allows correlation between return and volatility innovations:</p><p class="math-container">\[\begin{pmatrix} \varepsilon_t \\ \eta_t \end{pmatrix} \sim \mathcal{N}\left(\mathbf{0}, \begin{pmatrix} 1 &amp; \rho \\ \rho &amp; 1 \end{pmatrix}\right)\]</p><p>When <span>$\rho &lt; 0$</span> (the typical case for equities), negative returns are associated with increases in volatility, analogous to the leverage effect in EGARCH and GJR-GARCH models.</p><p><strong>SV with Student-t Errors</strong> (<code>dist=:studentt</code>): Replaces the Gaussian observation equation with Student-t innovations to accommodate heavier tails:</p><p class="math-container">\[y_t = \exp(h_t / 2) \, \varepsilon_t, \qquad \varepsilon_t \sim t_\nu\]</p><p>where <span>$\nu &gt; 2$</span> is the degrees of freedom parameter.</p><h3 id="Priors"><a class="docs-heading-anchor" href="#Priors">Priors</a><a id="Priors-1"></a><a class="docs-heading-anchor-permalink" href="#Priors" title="Permalink"></a></h3><p>The SV model is estimated via Bayesian MCMC using Turing.jl. The default priors are:</p><table><tr><th style="text-align: right">Parameter</th><th style="text-align: right">Prior</th><th style="text-align: right">Rationale</th></tr><tr><td style="text-align: right"><span>$\mu$</span></td><td style="text-align: right"><span>$\mathcal{N}(0, 10)$</span></td><td style="text-align: right">Weakly informative for log-variance level</td></tr><tr><td style="text-align: right"><span>$\varphi$</span></td><td style="text-align: right"><span>$\text{Beta}(20, 1.5) \to (-1, 1)$</span></td><td style="text-align: right">Concentrates mass near 1 (high persistence), ensures stationarity</td></tr><tr><td style="text-align: right"><span>$\sigma_\eta$</span></td><td style="text-align: right"><span>$\text{HalfNormal}(1)$</span></td><td style="text-align: right">Positive, moderately informative for vol-of-vol</td></tr><tr><td style="text-align: right"><span>$\rho$</span> (leverage)</td><td style="text-align: right"><span>$\text{Uniform}(-1, 1)$</span></td><td style="text-align: right">Uninformative over correlation range</td></tr><tr><td style="text-align: right"><span>$\nu$</span> (Student-t)</td><td style="text-align: right"><span>$\text{Exponential}(0.1) + 2$</span></td><td style="text-align: right">Ensures <span>$\nu &gt; 2$</span> (finite variance)</td></tr></table><h3 id="MCMC-Estimation"><a class="docs-heading-anchor" href="#MCMC-Estimation">MCMC Estimation</a><a id="MCMC-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#MCMC-Estimation" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Basic SV model
sv = estimate_sv(y; n_samples=2000, n_adapts=1000)

# SV with leverage effect
sv_lev = estimate_sv(y; leverage=true, n_samples=2000, n_adapts=1000)

# SV with Student-t errors
sv_t = estimate_sv(y; dist=:studentt, n_samples=2000, n_adapts=1000)

# Access posterior summaries
mean(sv.mu_post)          # Posterior mean of μ
mean(sv.phi_post)         # Posterior mean of φ
mean(sv.sigma_eta_post)   # Posterior mean of σ_η

# Posterior volatility (time series)
sv.volatility_mean        # Posterior mean of exp(hₜ) at each t
sv.volatility_quantiles   # Quantiles (T × n_quantiles matrix)
sv.quantile_levels        # Default: [0.025, 0.5, 0.975]

# Full MCMC chain for convergence diagnostics
sv.chain                  # MCMCChains.Chains object</code></pre><div class="admonition is-info" id="Technical-Note-509ebbb7870d17d6"><header class="admonition-header">Technical Note<a class="admonition-anchor" href="#Technical-Note-509ebbb7870d17d6" title="Permalink"></a></header><div class="admonition-body"><p>MCMC estimation of SV models is computationally intensive because the latent log-volatility states <span>$h_1, \ldots, h_T$</span> must be sampled jointly with the model parameters. The NUTS sampler (No-U-Turn Sampler) is used by default for efficient exploration of the posterior. Typical run times are 1–3 minutes for <span>$T = 500$</span> with 2000 posterior draws.</p></div></div><h3 id="SVModel-Return-Values"><a class="docs-heading-anchor" href="#SVModel-Return-Values">SVModel Return Values</a><a id="SVModel-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#SVModel-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>y</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Original data</td></tr><tr><td style="text-align: right"><code>chain</code></td><td style="text-align: right"><code>Chains</code></td><td style="text-align: right">Full MCMC chain (Turing.jl)</td></tr><tr><td style="text-align: right"><code>mu_post</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Posterior draws of <span>$\mu$</span></td></tr><tr><td style="text-align: right"><code>phi_post</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Posterior draws of <span>$\varphi$</span></td></tr><tr><td style="text-align: right"><code>sigma_eta_post</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Posterior draws of <span>$\sigma_\eta$</span></td></tr><tr><td style="text-align: right"><code>volatility_mean</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Posterior mean of <span>$\exp(h_t)$</span> at each <span>$t$</span></td></tr><tr><td style="text-align: right"><code>volatility_quantiles</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$T \times n_q$</span> quantiles of <span>$\exp(h_t)$</span></td></tr><tr><td style="text-align: right"><code>quantile_levels</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Quantile levels (e.g., <span>$[0.025, 0.5, 0.975]$</span>)</td></tr><tr><td style="text-align: right"><code>dist</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Error distribution (<code>:normal</code> or <code>:studentt</code>)</td></tr><tr><td style="text-align: right"><code>leverage</code></td><td style="text-align: right"><code>Bool</code></td><td style="text-align: right">Whether leverage effect was estimated</td></tr><tr><td style="text-align: right"><code>n_samples</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of posterior samples</td></tr></table><hr/><h2 id="Volatility-Forecasting"><a class="docs-heading-anchor" href="#Volatility-Forecasting">Volatility Forecasting</a><a id="Volatility-Forecasting-1"></a><a class="docs-heading-anchor-permalink" href="#Volatility-Forecasting" title="Permalink"></a></h2><p>All volatility models support multi-step ahead forecasting via <code>forecast()</code>. ARCH and GARCH-family models use simulation-based confidence intervals; SV models use posterior predictive simulation from MCMC draws.</p><h3 id="ARCH/GARCH-Forecasts"><a class="docs-heading-anchor" href="#ARCH/GARCH-Forecasts">ARCH/GARCH Forecasts</a><a id="ARCH/GARCH-Forecasts-1"></a><a class="docs-heading-anchor-permalink" href="#ARCH/GARCH-Forecasts" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Forecast 20 steps ahead
fc = forecast(garch, 20; conf_level=0.95, n_sim=10000)

# Point forecasts converge to unconditional variance
fc.forecast     # Vector of length 20
fc.ci_lower     # Lower CI bound
fc.ci_upper     # Upper CI bound
fc.se           # Standard errors

# Compare unconditional variance with long-horizon forecast
unconditional_variance(garch)
fc.forecast[end]  # Should be close for large h</code></pre><p>For stationary GARCH processes, multi-step forecasts converge geometrically to the unconditional variance at rate equal to the persistence parameter. The speed of convergence is measured by the half-life: <span>$\text{halflife} = \log(0.5) / \log(\text{persistence})$</span>.</p><p>Confidence intervals are constructed by simulating <span>$n$</span> paths forward from the last observed state, generating the distribution of future conditional variances. For ARCH models, forecasts beyond horizon <span>$q$</span> equal the unconditional variance exactly (no lagged variance terms to propagate).</p><h3 id="SV-Forecasts"><a class="docs-heading-anchor" href="#SV-Forecasts">SV Forecasts</a><a id="SV-Forecasts-1"></a><a class="docs-heading-anchor-permalink" href="#SV-Forecasts" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Posterior predictive forecast from SV model
fc_sv = forecast(sv, 20; conf_level=0.95)

fc_sv.forecast     # Posterior mean forecast
fc_sv.ci_lower     # 2.5th percentile
fc_sv.ci_upper     # 97.5th percentile</code></pre><p>For SV models, each MCMC draw provides a full parameter vector <span>$(\mu, \varphi, \sigma_\eta)$</span>. The forecast simulates the log-volatility process forward from the last state for each draw, yielding a posterior predictive distribution of future volatility. The reported intervals are posterior predictive quantiles, not frequentist confidence intervals.</p><h3 id="VolatilityForecast-Return-Values"><a class="docs-heading-anchor" href="#VolatilityForecast-Return-Values">VolatilityForecast Return Values</a><a id="VolatilityForecast-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#VolatilityForecast-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>forecast</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Point forecasts of conditional variance <span>$\hat{\sigma}^2_{T+h}$</span></td></tr><tr><td style="text-align: right"><code>ci_lower</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Lower confidence/credible interval bound</td></tr><tr><td style="text-align: right"><code>ci_upper</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Upper confidence/credible interval bound</td></tr><tr><td style="text-align: right"><code>se</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Standard errors of forecasts</td></tr><tr><td style="text-align: right"><code>horizon</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Forecast horizon</td></tr><tr><td style="text-align: right"><code>conf_level</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Confidence level (e.g., 0.95)</td></tr><tr><td style="text-align: right"><code>model_type</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Source model (<code>:arch</code>, <code>:garch</code>, <code>:egarch</code>, <code>:gjr_garch</code>, <code>:sv</code>)</td></tr></table><hr/><h2 id="Type-Accessors"><a class="docs-heading-anchor" href="#Type-Accessors">Type Accessors</a><a id="Type-Accessors-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Accessors" title="Permalink"></a></h2><p>The following accessor functions provide model-specific summary statistics. The formulas differ across model types:</p><table><tr><th style="text-align: right">Function</th><th style="text-align: right">ARCH</th><th style="text-align: right">GARCH</th><th style="text-align: right">EGARCH</th><th style="text-align: right">GJR-GARCH</th><th style="text-align: right">SV</th></tr><tr><td style="text-align: right"><code>persistence(m)</code></td><td style="text-align: right"><span>$\sum \alpha_i$</span></td><td style="text-align: right"><span>$\sum \alpha_i + \sum \beta_j$</span></td><td style="text-align: right"><span>$\sum \beta_j$</span></td><td style="text-align: right"><span>$\sum \alpha_i + \sum \gamma_i/2 + \sum \beta_j$</span></td><td style="text-align: right"><span>$\mathbb{E}[\varphi]$</span></td></tr><tr><td style="text-align: right"><code>halflife(m)</code></td><td style="text-align: right"><span>$\log(0.5)/\log(p)$</span></td><td style="text-align: right"><span>$\log(0.5)/\log(p)$</span></td><td style="text-align: right"><span>$\log(0.5)/\log(p)$</span></td><td style="text-align: right"><span>$\log(0.5)/\log(p)$</span></td><td style="text-align: right"><span>$\log(0.5)/\log(p)$</span></td></tr><tr><td style="text-align: right"><code>unconditional_variance(m)</code></td><td style="text-align: right"><span>$\frac{\omega}{1 - \sum \alpha_i}$</span></td><td style="text-align: right"><span>$\frac{\omega}{1 - \sum \alpha_i - \sum \beta_j}$</span></td><td style="text-align: right"><span>$\exp\!\left(\frac{\omega}{1 - \sum \beta_j}\right)$</span></td><td style="text-align: right"><span>$\frac{\omega}{1 - \sum \alpha_i - \sum \gamma_i/2 - \sum \beta_j}$</span></td><td style="text-align: right"><span>$\exp(\mathbb{E}[\mu])$</span></td></tr><tr><td style="text-align: right"><code>arch_order(m)</code></td><td style="text-align: right"><span>$q$</span></td><td style="text-align: right"><span>$q$</span></td><td style="text-align: right"><span>$q$</span></td><td style="text-align: right"><span>$q$</span></td><td style="text-align: right">—</td></tr><tr><td style="text-align: right"><code>garch_order(m)</code></td><td style="text-align: right">—</td><td style="text-align: right"><span>$p$</span></td><td style="text-align: right"><span>$p$</span></td><td style="text-align: right"><span>$p$</span></td><td style="text-align: right">—</td></tr></table><p>In the table, <span>$p$</span> denotes <code>persistence(m)</code>. The half-life returns <code>Inf</code> if the process is non-stationary (persistence <span>$\geq 1$</span>).</p><pre><code class="language-julia hljs">persistence(garch)              # 0.95 → high persistence
halflife(garch)                 # ≈ 13.5 periods
unconditional_variance(garch)   # Long-run variance
arch_order(garch)               # q
garch_order(garch)              # p</code></pre><hr/><h2 id="StatsAPI-Interface"><a class="docs-heading-anchor" href="#StatsAPI-Interface">StatsAPI Interface</a><a id="StatsAPI-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#StatsAPI-Interface" title="Permalink"></a></h2><p>All volatility models implement the standard StatsAPI interface:</p><table><tr><th style="text-align: right">Function</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>nobs(m)</code></td><td style="text-align: right">Number of observations</td></tr><tr><td style="text-align: right"><code>coef(m)</code></td><td style="text-align: right">Coefficient vector</td></tr><tr><td style="text-align: right"><code>residuals(m)</code></td><td style="text-align: right">Raw residuals <span>$\hat{\varepsilon}_t$</span></td></tr><tr><td style="text-align: right"><code>predict(m)</code></td><td style="text-align: right">Conditional variance series <span>$\hat{\sigma}^2_t$</span> (or posterior mean for SV)</td></tr><tr><td style="text-align: right"><code>loglikelihood(m)</code></td><td style="text-align: right">Maximized log-likelihood (ARCH/GARCH)</td></tr><tr><td style="text-align: right"><code>aic(m)</code></td><td style="text-align: right">Akaike Information Criterion</td></tr><tr><td style="text-align: right"><code>bic(m)</code></td><td style="text-align: right">Bayesian Information Criterion</td></tr><tr><td style="text-align: right"><code>dof(m)</code></td><td style="text-align: right">Number of estimated parameters</td></tr><tr><td style="text-align: right"><code>islinear(m)</code></td><td style="text-align: right"><code>false</code> (all volatility models are nonlinear)</td></tr></table><pre><code class="language-julia hljs">nobs(garch)          # Number of observations
loglikelihood(garch) # Maximized log-likelihood
aic(garch)           # AIC for model comparison
bic(garch)           # BIC for model comparison
coef(garch)          # [μ, ω, α₁, ..., αq, β₁, ..., βp]</code></pre><hr/><h2 id="Complete-Example"><a class="docs-heading-anchor" href="#Complete-Example">Complete Example</a><a id="Complete-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-Example" title="Permalink"></a></h2><p>This example estimates all four GARCH-family models on the same data, compares their news impact curves and forecasts, runs diagnostics, and estimates an SV model for comparison.</p><pre><code class="language-julia hljs">using MacroEconometricModels
using Random
using Statistics

Random.seed!(42)

# === Generate GARCH(1,1) data with leverage ===
T = 1000
y = zeros(T)
h = zeros(T)
h[1] = 1.0

for t in 2:T
    z = randn()
    h[t] = 0.01 + 0.08 * y[t-1]^2 + 0.12 * (y[t-1] &lt; 0 ? 1 : 0) * y[t-1]^2 + 0.85 * h[t-1]
    y[t] = sqrt(h[t]) * z
end

println(&quot;Simulated T=$T observations from GJR-GARCH(1,1)&quot;)
println(&quot;Sample kurtosis: &quot;, round(kurtosis(y), digits=2))

# === Step 1: Test for ARCH effects ===
stat, pval, q = arch_lm_test(y, 5)
println(&quot;\nARCH-LM test (q=5):&quot;)
println(&quot;  Statistic: &quot;, round(stat, digits=2))
println(&quot;  P-value: &quot;, round(pval, digits=6))

stat2, pval2, K = ljung_box_squared(y, 10)
println(&quot;\nLjung-Box squared (K=10):&quot;)
println(&quot;  Statistic: &quot;, round(stat2, digits=2))
println(&quot;  P-value: &quot;, round(pval2, digits=6))

# === Step 2: Estimate competing models ===
garch   = estimate_garch(y, 1, 1)
egarch  = estimate_egarch(y, 1, 1)
gjr     = estimate_gjr_garch(y, 1, 1)

println(&quot;\n&quot; * &quot;=&quot;^60)
println(&quot;Model Comparison&quot;)
println(&quot;=&quot;^60)
println(&quot;              AIC         BIC     Persistence&quot;)
println(&quot;  GARCH:   &quot;, round(aic(garch), digits=1),
        &quot;    &quot;, round(bic(garch), digits=1),
        &quot;    &quot;, round(persistence(garch), digits=4))
println(&quot;  EGARCH:  &quot;, round(aic(egarch), digits=1),
        &quot;    &quot;, round(bic(egarch), digits=1),
        &quot;    &quot;, round(persistence(egarch), digits=4))
println(&quot;  GJR:     &quot;, round(aic(gjr), digits=1),
        &quot;    &quot;, round(bic(gjr), digits=1),
        &quot;    &quot;, round(persistence(gjr), digits=4))

# === Step 3: Compare news impact curves ===
nic_g  = news_impact_curve(garch)
nic_e  = news_impact_curve(egarch)
nic_j  = news_impact_curve(gjr)

println(&quot;\nNews Impact at ε = -2 vs ε = +2:&quot;)
idx_neg = findfirst(x -&gt; x &gt;= -2.0, nic_g.shocks)
idx_pos = findfirst(x -&gt; x &gt;= 2.0, nic_g.shocks)

println(&quot;  GARCH:  σ²(-2) = &quot;, round(nic_g.variance[idx_neg], digits=4),
        &quot;   σ²(+2) = &quot;, round(nic_g.variance[idx_pos], digits=4))
println(&quot;  EGARCH: σ²(-2) = &quot;, round(nic_e.variance[idx_neg], digits=4),
        &quot;   σ²(+2) = &quot;, round(nic_e.variance[idx_pos], digits=4))
println(&quot;  GJR:    σ²(-2) = &quot;, round(nic_j.variance[idx_neg], digits=4),
        &quot;   σ²(+2) = &quot;, round(nic_j.variance[idx_pos], digits=4))

# === Step 4: Check residual diagnostics ===
println(&quot;\nResidual ARCH-LM test (q=5):&quot;)
for (name, m) in [(&quot;GARCH&quot;, garch), (&quot;EGARCH&quot;, egarch), (&quot;GJR&quot;, gjr)]
    _, p, _ = arch_lm_test(m, 5)
    status = p &gt; 0.05 ? &quot;Pass&quot; : &quot;FAIL&quot;
    println(&quot;  $name: p=$(round(p, digits=4))  $status&quot;)
end

# === Step 5: Forecast volatility ===
H = 20
fc_g = forecast(garch, H)
fc_e = forecast(egarch, H)
fc_j = forecast(gjr, H)

println(&quot;\nVolatility forecasts (conditional variance):&quot;)
println(&quot;  h    GARCH    EGARCH   GJR      Uncond&quot;)
for h_idx in [1, 5, 10, 20]
    println(&quot;  $h_idx    &quot;,
            round(fc_g.forecast[h_idx], digits=4), &quot;  &quot;,
            round(fc_e.forecast[h_idx], digits=4), &quot;  &quot;,
            round(fc_j.forecast[h_idx], digits=4), &quot;  &quot;,
            round(unconditional_variance(garch), digits=4))
end

# === Step 6: Stochastic volatility for comparison ===
println(&quot;\nEstimating SV model via MCMC...&quot;)
sv = estimate_sv(y; n_samples=2000, n_adapts=1000)

println(&quot;SV posterior summary:&quot;)
println(&quot;  μ (log-vol level):   &quot;, round(mean(sv.mu_post), digits=3),
        &quot; [&quot;, round(quantile(sv.mu_post, 0.025), digits=3),
        &quot;, &quot;, round(quantile(sv.mu_post, 0.975), digits=3), &quot;]&quot;)
println(&quot;  φ (persistence):    &quot;, round(mean(sv.phi_post), digits=3),
        &quot; [&quot;, round(quantile(sv.phi_post, 0.025), digits=3),
        &quot;, &quot;, round(quantile(sv.phi_post, 0.975), digits=3), &quot;]&quot;)
println(&quot;  σ_η (vol of vol):   &quot;, round(mean(sv.sigma_eta_post), digits=3),
        &quot; [&quot;, round(quantile(sv.sigma_eta_post, 0.025), digits=3),
        &quot;, &quot;, round(quantile(sv.sigma_eta_post, 0.975), digits=3), &quot;]&quot;)

# SV forecast
fc_sv = forecast(sv, H)
println(&quot;\nSV forecast at h=1: &quot;, round(fc_sv.forecast[1], digits=4))
println(&quot;SV forecast at h=20: &quot;, round(fc_sv.forecast[end], digits=4))</code></pre><p>In this example, the GJR-GARCH model should provide the best fit (lowest AIC/BIC) since the data was generated from a GJR-GARCH DGP with a leverage effect. The news impact curves reveal the asymmetry: for EGARCH and GJR-GARCH, <span>$\sigma^2(-2)$</span> exceeds <span>$\sigma^2(+2)$</span>; for symmetric GARCH, they are equal. All models&#39; standardized residuals should pass the ARCH-LM test after fitting, confirming that the conditional variance dynamics are adequately captured. The SV model provides an independent, Bayesian assessment of the volatility dynamics.</p><hr/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><ul><li>Black, Fischer. 1976. &quot;Studies of Stock Price Volatility Changes.&quot; <em>Proceedings of the 1976 Meetings of the American Statistical Association</em>, 171–177.</li><li>Bollerslev, Tim. 1986. &quot;Generalized Autoregressive Conditional Heteroskedasticity.&quot; <em>Journal of Econometrics</em> 31 (3): 307–327. <a href="https://doi.org/10.1016/0304-4076(86)90063-1">https://doi.org/10.1016/0304-4076(86)90063-1</a></li><li>Engle, Robert F. 1982. &quot;Autoregressive Conditional Heteroscedasticity with Estimates of the Variance of United Kingdom Inflation.&quot; <em>Econometrica</em> 50 (4): 987–1007. <a href="https://doi.org/10.2307/1912773">https://doi.org/10.2307/1912773</a></li><li>Glosten, Lawrence R., Ravi Jagannathan, and David E. Runkle. 1993. &quot;On the Relation between the Expected Value and the Volatility of the Nominal Excess Return on Stocks.&quot; <em>Journal of Finance</em> 48 (5): 1779–1801. <a href="https://doi.org/10.1111/j.1540-6261.1993.tb05128.x">https://doi.org/10.1111/j.1540-6261.1993.tb05128.x</a></li><li>Nelson, Daniel B. 1991. &quot;Conditional Heteroskedasticity in Asset Returns: A New Approach.&quot; <em>Econometrica</em> 59 (2): 347–370. <a href="https://doi.org/10.2307/2938260">https://doi.org/10.2307/2938260</a></li><li>Taylor, Stephen J. 1986. <em>Modelling Financial Time Series</em>. Chichester: Wiley. ISBN 978-0-471-90975-7.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../arima/">« ARIMA</a><a class="docs-footer-nextpage" href="../manual/">VAR »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 7 February 2026 11:44">Saturday 7 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
