<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · Macroeconometrics.jl</title><meta name="title" content="Examples · Macroeconometrics.jl"/><meta property="og:title" content="Examples · Macroeconometrics.jl"/><meta property="twitter:title" content="Examples · Macroeconometrics.jl"/><meta name="description" content="Documentation for Macroeconometrics.jl."/><meta property="og:description" content="Documentation for Macroeconometrics.jl."/><meta property="twitter:description" content="Documentation for Macroeconometrics.jl."/><meta property="og:url" content="https://chung9207.github.io/Macroeconometrics.jl/examples/"/><meta property="twitter:url" content="https://chung9207.github.io/Macroeconometrics.jl/examples/"/><link rel="canonical" href="https://chung9207.github.io/Macroeconometrics.jl/examples/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Macroeconometrics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../manual/">VAR &amp; BVAR</a></li><li><a class="tocitem" href="../lp/">Local Projections</a></li><li><a class="tocitem" href="../factormodels/">Factor Models</a></li></ul></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Example-1:-Three-Variable-VAR-Analysis"><span>Example 1: Three-Variable VAR Analysis</span></a></li><li><a class="tocitem" href="#Example-2:-Bayesian-VAR-with-Minnesota-Prior"><span>Example 2: Bayesian VAR with Minnesota Prior</span></a></li><li><a class="tocitem" href="#Example-3:-Local-Projections"><span>Example 3: Local Projections</span></a></li><li><a class="tocitem" href="#Example-4:-Factor-Model-for-Large-Panels"><span>Example 4: Factor Model for Large Panels</span></a></li><li><a class="tocitem" href="#Example-5:-GMM-Estimation"><span>Example 5: GMM Estimation</span></a></li><li><a class="tocitem" href="#Example-6:-Complete-Workflow"><span>Example 6: Complete Workflow</span></a></li><li><a class="tocitem" href="#Best-Practices"><span>Best Practices</span></a></li></ul></li><li><a class="tocitem" href="../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/chung9207/Macroeconometrics.jl/blob/main/docs/src/examples.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><p>This chapter provides comprehensive worked examples demonstrating the main functionality of <strong>Macroeconometrics.jl</strong>. Each example includes complete code, economic interpretation, and best practices.</p><h2 id="Example-1:-Three-Variable-VAR-Analysis"><a class="docs-heading-anchor" href="#Example-1:-Three-Variable-VAR-Analysis">Example 1: Three-Variable VAR Analysis</a><a id="Example-1:-Three-Variable-VAR-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-Three-Variable-VAR-Analysis" title="Permalink"></a></h2><p>This example walks through a complete analysis of a macroeconomic VAR with GDP growth, inflation, and the federal funds rate.</p><h3 id="Setup-and-Data-Generation"><a class="docs-heading-anchor" href="#Setup-and-Data-Generation">Setup and Data Generation</a><a id="Setup-and-Data-Generation-1"></a><a class="docs-heading-anchor-permalink" href="#Setup-and-Data-Generation" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Macroeconometrics
using Random
using LinearAlgebra
using Statistics

Random.seed!(42)

# Generate realistic macro data from a VAR(1) DGP
T = 200
n = 3
p = 2

# True VAR(1) coefficients (persistent, cross-correlated)
A_true = [0.85 0.10 -0.15;   # GDP responds to own lag, inflation, rate
          0.05 0.70  0.00;   # Inflation mainly AR
          0.10 0.20  0.80]   # Rate responds to GDP and inflation

# Shock covariance (correlated shocks)
Σ_true = [1.00 0.50 0.20;
          0.50 0.80 0.10;
          0.20 0.10 0.60]

# Generate data
Y = zeros(T, n)
Y[1, :] = randn(n)
chol_Σ = cholesky(Σ_true).L

for t in 2:T
    Y[t, :] = A_true * Y[t-1, :] + chol_Σ * randn(n)
end

var_names = [&quot;GDP Growth&quot;, &quot;Inflation&quot;, &quot;Fed Funds Rate&quot;]
println(&quot;Data: T=$T observations, n=$n variables&quot;)</code></pre><h3 id="Frequentist-VAR-Estimation"><a class="docs-heading-anchor" href="#Frequentist-VAR-Estimation">Frequentist VAR Estimation</a><a id="Frequentist-VAR-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Frequentist-VAR-Estimation" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Estimate VAR(2) model via OLS
model = fit(VARModel, Y, p)

# Model diagnostics
println(&quot;Log-likelihood: &quot;, loglikelihood(model))
println(&quot;AIC: &quot;, aic(model))
println(&quot;BIC: &quot;, bic(model))

# Check stability (eigenvalues inside unit circle)
F = companion_matrix(model.B, n, p)
eigenvalues = eigvals(F)
println(&quot;Max eigenvalue modulus: &quot;, maximum(abs.(eigenvalues)))
println(&quot;Stable: &quot;, maximum(abs.(eigenvalues)) &lt; 1)</code></pre><h3 id="Cholesky-Identified-IRF"><a class="docs-heading-anchor" href="#Cholesky-Identified-IRF">Cholesky-Identified IRF</a><a id="Cholesky-Identified-IRF-1"></a><a class="docs-heading-anchor-permalink" href="#Cholesky-Identified-IRF" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Compute 20-period IRF with Cholesky identification
# Ordering: GDP → Inflation → Rate (contemporaneous causality)
H = 20
irfs = irf(model, H; method=:cholesky)

# Display impact responses (horizon 0)
println(&quot;\nImpact responses (B₀):&quot;)
println(&quot;  GDP shock → GDP: &quot;, round(irfs.irf[1, 1, 1], digits=3))
println(&quot;  GDP shock → Inflation: &quot;, round(irfs.irf[1, 2, 1], digits=3))
println(&quot;  GDP shock → Rate: &quot;, round(irfs.irf[1, 3, 1], digits=3))

# Long-run responses (horizon H)
println(&quot;\nLong-run responses (h=$H):&quot;)
println(&quot;  GDP shock → GDP: &quot;, round(irfs.irf[H+1, 1, 1], digits=3))</code></pre><h3 id="Sign-Restriction-Identification"><a class="docs-heading-anchor" href="#Sign-Restriction-Identification">Sign Restriction Identification</a><a id="Sign-Restriction-Identification-1"></a><a class="docs-heading-anchor-permalink" href="#Sign-Restriction-Identification" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Sign restrictions: Demand shock raises GDP and inflation on impact
function check_demand_shock(irf_array)
    # irf_array is (H+1) × n × n
    # Check: Shock 1 → Variable 1 (GDP) positive
    #        Shock 1 → Variable 2 (Inflation) positive
    return irf_array[1, 1, 1] &gt; 0 &amp;&amp; irf_array[1, 2, 1] &gt; 0
end

# Estimate with sign restrictions
irfs_sign = irf(model, H; method=:sign, check_func=check_demand_shock, n_draws=1000)

println(&quot;\nSign-identified demand shock:&quot;)
println(&quot;  GDP response: &quot;, round(irfs_sign.irf[1, 1, 1], digits=3))
println(&quot;  Inflation response: &quot;, round(irfs_sign.irf[1, 2, 1], digits=3))</code></pre><h3 id="Forecast-Error-Variance-Decomposition"><a class="docs-heading-anchor" href="#Forecast-Error-Variance-Decomposition">Forecast Error Variance Decomposition</a><a id="Forecast-Error-Variance-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Forecast-Error-Variance-Decomposition" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Compute FEVD
fevd_result = fevd(model, H; method=:cholesky)

# Variance decomposition at horizon 1, 4, and 20
for h in [1, 4, 20]
    println(&quot;\nFEVD at horizon $h:&quot;)
    for i in 1:n
        println(&quot;  $(var_names[i]):&quot;)
        for j in 1:n
            pct = round(fevd_result.fevd[h, i, j] * 100, digits=1)
            println(&quot;    Shock $j: $pct%&quot;)
        end
    end
end</code></pre><hr/><h2 id="Example-2:-Bayesian-VAR-with-Minnesota-Prior"><a class="docs-heading-anchor" href="#Example-2:-Bayesian-VAR-with-Minnesota-Prior">Example 2: Bayesian VAR with Minnesota Prior</a><a id="Example-2:-Bayesian-VAR-with-Minnesota-Prior-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2:-Bayesian-VAR-with-Minnesota-Prior" title="Permalink"></a></h2><p>This example demonstrates Bayesian estimation with automatic hyperparameter optimization.</p><h3 id="Hyperparameter-Optimization"><a class="docs-heading-anchor" href="#Hyperparameter-Optimization">Hyperparameter Optimization</a><a id="Hyperparameter-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Hyperparameter-Optimization" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Macroeconometrics

# Find optimal shrinkage using marginal likelihood (Giannone et al. 2015)
println(&quot;Optimizing hyperparameters...&quot;)
best_hyper = optimize_hyperparameters(Y, p; grid_size=20)

println(&quot;Optimal hyperparameters:&quot;)
println(&quot;  τ (overall tightness): &quot;, round(best_hyper.tau, digits=4))
println(&quot;  d (lag decay): &quot;, best_hyper.d)</code></pre><h3 id="BVAR-Estimation-with-MCMC"><a class="docs-heading-anchor" href="#BVAR-Estimation-with-MCMC">BVAR Estimation with MCMC</a><a id="BVAR-Estimation-with-MCMC-1"></a><a class="docs-heading-anchor-permalink" href="#BVAR-Estimation-with-MCMC" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Estimate BVAR with optimized Minnesota prior
println(&quot;\nEstimating BVAR with MCMC...&quot;)
chain = estimate_bvar(Y, p;
    n_samples = 2000,
    n_adapts = 500,
    prior = :minnesota,
    hyper = best_hyper
)

# Posterior summary (coefficients from first equation)
println(&quot;\nPosterior summary for GDP equation:&quot;)
# Access posterior draws and compute statistics</code></pre><h3 id="Bayesian-IRF-with-Credible-Intervals"><a class="docs-heading-anchor" href="#Bayesian-IRF-with-Credible-Intervals">Bayesian IRF with Credible Intervals</a><a id="Bayesian-IRF-with-Credible-Intervals-1"></a><a class="docs-heading-anchor-permalink" href="#Bayesian-IRF-with-Credible-Intervals" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Bayesian IRF with Cholesky identification
birf_chol = irf(chain, p, n, H; method=:cholesky)

# Extract median and 68% credible intervals
# birf_chol.quantiles is (H+1) × n × n × 3 array
# [:, :, :, 1] = 16th percentile
# [:, :, :, 2] = median
# [:, :, :, 3] = 84th percentile

println(&quot;\nBayesian IRF of GDP to own shock:&quot;)
for h in [0, 4, 8, 12, 20]
    med = round(birf_chol.quantiles[h+1, 1, 1, 2], digits=3)
    lo = round(birf_chol.quantiles[h+1, 1, 1, 1], digits=3)
    hi = round(birf_chol.quantiles[h+1, 1, 1, 3], digits=3)
    println(&quot;  h=$h: $med [$lo, $hi]&quot;)
end</code></pre><h3 id="Bayesian-Sign-Restrictions"><a class="docs-heading-anchor" href="#Bayesian-Sign-Restrictions">Bayesian Sign Restrictions</a><a id="Bayesian-Sign-Restrictions-1"></a><a class="docs-heading-anchor-permalink" href="#Bayesian-Sign-Restrictions" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Bayesian IRF with sign restrictions
birf_sign = irf(chain, p, n, H;
    method = :sign,
    check_func = check_demand_shock
)

println(&quot;\nBayesian sign-restricted demand shock → GDP:&quot;)
for h in [0, 4, 8, 12]
    med = round(birf_sign.quantiles[h+1, 1, 1, 2], digits=3)
    lo = round(birf_sign.quantiles[h+1, 1, 1, 1], digits=3)
    hi = round(birf_sign.quantiles[h+1, 1, 1, 3], digits=3)
    println(&quot;  h=$h: $med [$lo, $hi]&quot;)
end</code></pre><hr/><h2 id="Example-3:-Local-Projections"><a class="docs-heading-anchor" href="#Example-3:-Local-Projections">Example 3: Local Projections</a><a id="Example-3:-Local-Projections-1"></a><a class="docs-heading-anchor-permalink" href="#Example-3:-Local-Projections" title="Permalink"></a></h2><p>This example demonstrates various LP methods for estimating impulse responses.</p><h3 id="Standard-Local-Projection"><a class="docs-heading-anchor" href="#Standard-Local-Projection">Standard Local Projection</a><a id="Standard-Local-Projection-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-Local-Projection" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Macroeconometrics

# Estimate LP-IRF with Newey-West standard errors
H = 20
shock_var = 1  # GDP as the shock variable

lp_model = estimate_lp(Y, shock_var, H;
    lags = 4,
    cov_type = :newey_west,
    bandwidth = 0  # Automatic bandwidth selection
)

# Extract IRF with confidence intervals
lp_result = lp_irf(lp_model; conf_level = 0.95)

println(&quot;LP-IRF of shock to variable 1 → variable 1:&quot;)
for h in 0:4:H
    val = round(lp_result.values[h+1, 1], digits=3)
    se = round(lp_result.se[h+1, 1], digits=3)
    println(&quot;  h=$h: $val (SE: $se)&quot;)
end</code></pre><h3 id="LP-with-Instrumental-Variables"><a class="docs-heading-anchor" href="#LP-with-Instrumental-Variables">LP with Instrumental Variables</a><a id="LP-with-Instrumental-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#LP-with-Instrumental-Variables" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Generate external instrument (e.g., monetary policy shock proxy)
Random.seed!(123)
Z = 0.5 * Y[:, 3] + randn(T, 1)  # Correlated with rate but exogenous

# Estimate LP-IV
shock_var = 3  # Instrument for rate shock
lpiv_model = estimate_lp_iv(Y, shock_var, Z, H;
    lags = 4,
    cov_type = :newey_west
)

# Check instrument strength
weak_test = weak_instrument_test(lpiv_model; threshold = 10.0)
println(&quot;\nFirst-stage F-statistics by horizon:&quot;)
for h in 0:4:H
    F = round(weak_test.F_stats[h+1], digits=2)
    status = F &gt; 10 ? &quot;✓&quot; : &quot;⚠ weak&quot;
    println(&quot;  h=$h: F=$F $status&quot;)
end
println(&quot;All horizons pass F&gt;10: &quot;, weak_test.passes_threshold)

# Extract IRF
lpiv_result = lp_iv_irf(lpiv_model)</code></pre><h3 id="Smooth-Local-Projection"><a class="docs-heading-anchor" href="#Smooth-Local-Projection">Smooth Local Projection</a><a id="Smooth-Local-Projection-1"></a><a class="docs-heading-anchor-permalink" href="#Smooth-Local-Projection" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Estimate smooth LP with B-splines
smooth_model = estimate_smooth_lp(Y, 1, H;
    degree = 3,      # Cubic splines
    n_knots = 4,     # Interior knots
    lambda = 1.0,    # Smoothing parameter
    lags = 4
)

# Cross-validate lambda
optimal_lambda = cross_validate_lambda(Y, 1, H;
    lambda_grid = 10.0 .^ (-4:0.5:2),
    k_folds = 5
)
println(&quot;\nOptimal smoothing parameter: &quot;, round(optimal_lambda, digits=4))

# Compare standard vs smooth LP
comparison = compare_smooth_lp(Y, 1, H; lambda = optimal_lambda)
println(&quot;Variance reduction ratio: &quot;, round(comparison.variance_reduction, digits=3))</code></pre><h3 id="State-Dependent-Local-Projection"><a class="docs-heading-anchor" href="#State-Dependent-Local-Projection">State-Dependent Local Projection</a><a id="State-Dependent-Local-Projection-1"></a><a class="docs-heading-anchor-permalink" href="#State-Dependent-Local-Projection" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Construct state variable (moving average of GDP growth)
gdp_level = cumsum(Y[:, 1])  # Integrate growth to get level
gdp_growth = [NaN; diff(gdp_level)]

# 4-period moving average, standardized
state_var = zeros(T)
for t in 4:T
    state_var[t] = mean(Y[t-3:t, 1])
end
state_var = (state_var .- mean(state_var[4:end])) ./ std(state_var[4:end])

# Estimate state-dependent LP
state_model = estimate_state_lp(Y, 1, state_var, H;
    gamma = 1.5,           # Transition speed
    threshold = :median,    # Threshold at median
    lags = 4
)

# Extract regime-specific IRFs
irf_both = state_irf(state_model; regime = :both)

println(&quot;\nState-dependent IRFs (shock 1 → variable 1):&quot;)
println(&quot;Expansion vs Recession comparison:&quot;)
for h in [0, 4, 8, 12]
    exp_val = round(irf_both.expansion.values[h+1, 1], digits=3)
    rec_val = round(irf_both.recession.values[h+1, 1], digits=3)
    diff = round(exp_val - rec_val, digits=3)
    println(&quot;  h=$h: Expansion=$exp_val, Recession=$rec_val, Diff=$diff&quot;)
end

# Test for regime differences
diff_test = test_regime_difference(state_model)
println(&quot;\nJoint test for regime differences:&quot;)
println(&quot;  Average |t|: &quot;, round(diff_test.joint_test.avg_t_stat, digits=2))
println(&quot;  p-value: &quot;, round(diff_test.joint_test.p_value, digits=4))</code></pre><hr/><h2 id="Example-4:-Factor-Model-for-Large-Panels"><a class="docs-heading-anchor" href="#Example-4:-Factor-Model-for-Large-Panels">Example 4: Factor Model for Large Panels</a><a id="Example-4:-Factor-Model-for-Large-Panels-1"></a><a class="docs-heading-anchor-permalink" href="#Example-4:-Factor-Model-for-Large-Panels" title="Permalink"></a></h2><p>This example demonstrates factor extraction and selection from a large macroeconomic panel.</p><h3 id="Simulate-Large-Panel-Data"><a class="docs-heading-anchor" href="#Simulate-Large-Panel-Data">Simulate Large Panel Data</a><a id="Simulate-Large-Panel-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Simulate-Large-Panel-Data" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Macroeconometrics
using Random
using Statistics

Random.seed!(42)

# Panel dimensions
T = 150   # Time periods
N = 50    # Variables
r_true = 3  # True number of factors

# Generate true factors (with persistence)
F_true = zeros(T, r_true)
for j in 1:r_true
    F_true[1, j] = randn()
    for t in 2:T
        F_true[t, j] = 0.8 * F_true[t-1, j] + 0.3 * randn()
    end
end

# Factor loadings (sparse structure)
Λ_true = randn(N, r_true)
# Make first 15 vars load strongly on factor 1, etc.
Λ_true[1:15, 1] .*= 2
Λ_true[16:30, 2] .*= 2
Λ_true[31:45, 3] .*= 2

# Generate panel
X = F_true * Λ_true&#39; + 0.5 * randn(T, N)

println(&quot;Panel: T=$T, N=$N, true r=$r_true&quot;)</code></pre><h3 id="Determine-Number-of-Factors"><a class="docs-heading-anchor" href="#Determine-Number-of-Factors">Determine Number of Factors</a><a id="Determine-Number-of-Factors-1"></a><a class="docs-heading-anchor-permalink" href="#Determine-Number-of-Factors" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Bai-Ng information criteria
r_max = 10
ic = ic_criteria(X, r_max)

println(&quot;\nBai-Ng information criteria:&quot;)
println(&quot;  IC1 selects: &quot;, ic.r_IC1, &quot; factors&quot;)
println(&quot;  IC2 selects: &quot;, ic.r_IC2, &quot; factors&quot;)
println(&quot;  IC3 selects: &quot;, ic.r_IC3, &quot; factors&quot;)
println(&quot;  (True: $r_true factors)&quot;)

# IC values for each r
println(&quot;\nIC values by number of factors:&quot;)
for r in 1:r_max
    println(&quot;  r=$r: IC1=$(round(ic.IC1[r], digits=4)), IC2=$(round(ic.IC2[r], digits=4))&quot;)
end</code></pre><h3 id="Estimate-Factor-Model"><a class="docs-heading-anchor" href="#Estimate-Factor-Model">Estimate Factor Model</a><a id="Estimate-Factor-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Estimate-Factor-Model" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Use IC2&#39;s recommendation
r_opt = ic.r_IC2

# Estimate factor model
fm = estimate_factors(X, r_opt; standardize = true)

println(&quot;\nEstimated factor model:&quot;)
println(&quot;  Number of factors: &quot;, fm.r)
println(&quot;  Factors dimension: &quot;, size(fm.factors))
println(&quot;  Loadings dimension: &quot;, size(fm.loadings))

# Variance explained
println(&quot;\nVariance explained:&quot;)
for j in 1:r_opt
    pct = round(fm.explained_variance[j] * 100, digits=1)
    cum = round(fm.cumulative_variance[j] * 100, digits=1)
    println(&quot;  Factor $j: $pct% (cumulative: $cum%)&quot;)
end</code></pre><h3 id="Model-Diagnostics"><a class="docs-heading-anchor" href="#Model-Diagnostics">Model Diagnostics</a><a id="Model-Diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Diagnostics" title="Permalink"></a></h3><pre><code class="language-julia hljs"># R² for each variable
r2_vals = r2(fm)

println(&quot;\nR² statistics:&quot;)
println(&quot;  Mean: &quot;, round(mean(r2_vals), digits=3))
println(&quot;  Median: &quot;, round(median(r2_vals), digits=3))
println(&quot;  Min: &quot;, round(minimum(r2_vals), digits=3))
println(&quot;  Max: &quot;, round(maximum(r2_vals), digits=3))

# Variables well-explained (R² &gt; 0.5)
well_explained = sum(r2_vals .&gt; 0.5)
println(&quot;  Variables with R² &gt; 0.5: $well_explained / $N&quot;)

# Factor-true factor correlation (up to rotation)
println(&quot;\nFactor recovery (correlation with true factors):&quot;)
for j in 1:r_opt
    cors = [abs(cor(fm.factors[:, j], F_true[:, k])) for k in 1:r_true]
    best_match = argmax(cors)
    println(&quot;  Estimated factor $j matches true factor $best_match: r=$(round(cors[best_match], digits=3))&quot;)
end</code></pre><hr/><h2 id="Example-5:-GMM-Estimation"><a class="docs-heading-anchor" href="#Example-5:-GMM-Estimation">Example 5: GMM Estimation</a><a id="Example-5:-GMM-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Example-5:-GMM-Estimation" title="Permalink"></a></h2><p>This example demonstrates GMM estimation of a simple model with moment conditions.</p><h3 id="Define-Moment-Conditions"><a class="docs-heading-anchor" href="#Define-Moment-Conditions">Define Moment Conditions</a><a id="Define-Moment-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Define-Moment-Conditions" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Macroeconometrics

# Example: IV regression via GMM
# Model: y = x&#39;β + ε
# Moment conditions: E[z(y - x&#39;β)] = 0

# Generate data with endogeneity
Random.seed!(42)
n_obs = 500
n_params = 2

# Instruments
Z = randn(n_obs, 3)

# Endogenous regressor (correlated with error)
u = randn(n_obs)
X = hcat(ones(n_obs), Z[:, 1] + 0.5 * u + 0.2 * randn(n_obs))

# Outcome
β_true = [1.0, 2.0]
Y = X * β_true + u

# Data bundle
data = (Y = Y, X = X, Z = hcat(ones(n_obs), Z))

# Moment function: E[Z&#39;(Y - Xβ)] = 0
function moment_conditions(theta, data)
    residuals = data.Y - data.X * theta
    data.Z .* residuals  # n_obs × n_moments matrix
end</code></pre><h3 id="GMM-Estimation"><a class="docs-heading-anchor" href="#GMM-Estimation">GMM Estimation</a><a id="GMM-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#GMM-Estimation" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Initial values
theta0 = zeros(n_params)

# Two-step efficient GMM
gmm_result = estimate_gmm(moment_conditions, theta0, data;
    weighting = :two_step,
    hac = true
)

println(&quot;GMM Estimation Results:&quot;)
println(&quot;  True β: &quot;, β_true)
println(&quot;  Estimated β: &quot;, round.(gmm_result.theta, digits=4))
println(&quot;  Converged: &quot;, gmm_result.converged)
println(&quot;  Iterations: &quot;, gmm_result.iterations)

# Standard errors
se = sqrt.(diag(gmm_result.vcov))
println(&quot;\n  Standard errors: &quot;, round.(se, digits=4))

# Confidence intervals
z = 1.96
for i in 1:n_params
    lo = round(gmm_result.theta[i] - z * se[i], digits=4)
    hi = round(gmm_result.theta[i] + z * se[i], digits=4)
    println(&quot;  β[$i]: 95% CI = [$lo, $hi]&quot;)
end</code></pre><h3 id="J-Test-for-Overidentification"><a class="docs-heading-anchor" href="#J-Test-for-Overidentification">J-Test for Overidentification</a><a id="J-Test-for-Overidentification-1"></a><a class="docs-heading-anchor-permalink" href="#J-Test-for-Overidentification" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Test overidentifying restrictions
j_result = j_test(gmm_result)

println(&quot;\nHansen J-test:&quot;)
println(&quot;  J-statistic: &quot;, round(j_result.J_stat, digits=4))
println(&quot;  Degrees of freedom: &quot;, j_result.df)
println(&quot;  p-value: &quot;, round(j_result.p_value, digits=4))
println(&quot;  Reject at 5%: &quot;, j_result.reject_05)</code></pre><hr/><h2 id="Example-6:-Complete-Workflow"><a class="docs-heading-anchor" href="#Example-6:-Complete-Workflow">Example 6: Complete Workflow</a><a id="Example-6:-Complete-Workflow-1"></a><a class="docs-heading-anchor-permalink" href="#Example-6:-Complete-Workflow" title="Permalink"></a></h2><p>This example shows a complete empirical workflow combining multiple techniques.</p><pre><code class="language-julia hljs">using Macroeconometrics
using Random
using Statistics

Random.seed!(2024)

# === Step 1: Data Preparation ===
T, n = 200, 4
Y = randn(T, n)
for t in 2:T
    Y[t, :] = 0.6 * Y[t-1, :] + 0.3 * randn(n)
end
var_names = [&quot;Output&quot;, &quot;Inflation&quot;, &quot;Rate&quot;, &quot;Exchange Rate&quot;]

# === Step 2: Lag Selection ===
println(&quot;=&quot;^50)
println(&quot;Step 1: Lag Selection&quot;)
println(&quot;=&quot;^50)

aics = Float64[]
bics = Float64[]
for p in 1:8
    m = fit(VARModel, Y, p)
    push!(aics, aic(m))
    push!(bics, bic(m))
end
p_aic = argmin(aics)
p_bic = argmin(bics)
println(&quot;AIC selects p=$p_aic, BIC selects p=$p_bic&quot;)
p = p_bic  # Use BIC&#39;s conservative choice

# === Step 3: VAR Estimation ===
println(&quot;\n&quot; * &quot;=&quot;^50)
println(&quot;Step 2: VAR Estimation&quot;)
println(&quot;=&quot;^50)

model = fit(VARModel, Y, p)
println(&quot;Estimated VAR($p)&quot;)
println(&quot;Log-likelihood: &quot;, round(loglikelihood(model), digits=2))

# === Step 4: Frequentist IRF ===
println(&quot;\n&quot; * &quot;=&quot;^50)
println(&quot;Step 3: Impulse Response Analysis&quot;)
println(&quot;=&quot;^50)

H = 20
irfs = irf(model, H; method=:cholesky)
fevd_res = fevd(model, H; method=:cholesky)

# === Step 5: Bayesian Estimation ===
println(&quot;\n&quot; * &quot;=&quot;^50)
println(&quot;Step 4: Bayesian Analysis&quot;)
println(&quot;=&quot;^50)

# Optimize priors
best_hyper = optimize_hyperparameters(Y, p; grid_size=15)
println(&quot;Optimal τ: &quot;, round(best_hyper.tau, digits=4))

# BVAR with MCMC
chain = estimate_bvar(Y, p; n_samples=1000, n_adapts=300,
                      prior=:minnesota, hyper=best_hyper)

# Bayesian IRF
birf = irf(chain, p, n, H; method=:cholesky)

# === Step 6: Local Projections Comparison ===
println(&quot;\n&quot; * &quot;=&quot;^50)
println(&quot;Step 5: LP vs VAR Comparison&quot;)
println(&quot;=&quot;^50)

lp_model = estimate_lp(Y, 1, H; lags=p, cov_type=:newey_west)
lp_result = lp_irf(lp_model)

println(&quot;IRF(1→1) at h=0:&quot;)
println(&quot;  VAR: &quot;, round(irfs.irf[1, 1, 1], digits=3))
println(&quot;  LP: &quot;, round(lp_result.values[1, 1], digits=3))

println(&quot;\nIRF(1→1) at h=8:&quot;)
println(&quot;  VAR: &quot;, round(irfs.irf[9, 1, 1], digits=3))
println(&quot;  LP: &quot;, round(lp_result.values[9, 1], digits=3))

# === Step 7: Robustness Check with Smooth LP ===
smooth_lp = estimate_smooth_lp(Y, 1, H; lambda=1.0, lags=p)
smooth_result = smooth_lp_irf(smooth_lp)

println(&quot;\nSmooth LP variance reduction: &quot;,
        round(mean(smooth_result.se.^2) / mean(lp_result.se.^2), digits=3))

println(&quot;\n&quot; * &quot;=&quot;^50)
println(&quot;Analysis Complete!&quot;)
println(&quot;=&quot;^50)</code></pre><hr/><h2 id="Best-Practices"><a class="docs-heading-anchor" href="#Best-Practices">Best Practices</a><a id="Best-Practices-1"></a><a class="docs-heading-anchor-permalink" href="#Best-Practices" title="Permalink"></a></h2><h3 id="Data-Preparation"><a class="docs-heading-anchor" href="#Data-Preparation">Data Preparation</a><a id="Data-Preparation-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Preparation" title="Permalink"></a></h3><ol><li><strong>Stationarity</strong>: Ensure data is stationary (difference if needed)</li><li><strong>Outliers</strong>: Check for and handle outliers</li><li><strong>Missing data</strong>: Factor models can handle some missing data; VARs require complete data</li><li><strong>Scaling</strong>: For factor models, standardize variables</li></ol><h3 id="Model-Selection"><a class="docs-heading-anchor" href="#Model-Selection">Model Selection</a><a id="Model-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Selection" title="Permalink"></a></h3><ol><li><strong>Lag length</strong>: Use information criteria (BIC is more conservative)</li><li><strong>Number of factors</strong>: Use Bai-Ng criteria; prefer IC2 or IC3</li><li><strong>Prior tightness</strong>: Optimize via marginal likelihood for large models</li></ol><h3 id="Identification"><a class="docs-heading-anchor" href="#Identification">Identification</a><a id="Identification-1"></a><a class="docs-heading-anchor-permalink" href="#Identification" title="Permalink"></a></h3><ol><li><strong>Economic theory</strong>: Base restrictions on economic reasoning</li><li><strong>Robustness</strong>: Try multiple identification schemes</li><li><strong>Narrative</strong>: Use historical knowledge when available</li></ol><h3 id="Inference"><a class="docs-heading-anchor" href="#Inference">Inference</a><a id="Inference-1"></a><a class="docs-heading-anchor-permalink" href="#Inference" title="Permalink"></a></h3><ol><li><strong>HAC standard errors</strong>: Always use for LP at horizons &gt; 0</li><li><strong>Credible intervals</strong>: Report 68% and 90% bands for Bayesian</li><li><strong>Bootstrap</strong>: Use for frequentist VAR confidence intervals</li></ol><h3 id="Reporting"><a class="docs-heading-anchor" href="#Reporting">Reporting</a><a id="Reporting-1"></a><a class="docs-heading-anchor-permalink" href="#Reporting" title="Permalink"></a></h3><ol><li><strong>Present both</strong>: VAR and LP estimates as robustness check</li><li><strong>Horizon selection</strong>: Focus on economically meaningful horizons</li><li><strong>FEVD</strong>: Report at multiple horizons (short, medium, long-run)</li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../factormodels/">« Factor Models</a><a class="docs-footer-nextpage" href="../api/">API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 30 January 2026 21:51">Friday 30 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
