<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Unit Root &amp; Cointegration · MacroEconometricModels.jl</title><meta name="title" content="Unit Root &amp; Cointegration · MacroEconometricModels.jl"/><meta property="og:title" content="Unit Root &amp; Cointegration · MacroEconometricModels.jl"/><meta property="twitter:title" content="Unit Root &amp; Cointegration · MacroEconometricModels.jl"/><meta name="description" content="Documentation for MacroEconometricModels.jl."/><meta property="og:description" content="Documentation for MacroEconometricModels.jl."/><meta property="twitter:description" content="Documentation for MacroEconometricModels.jl."/><meta property="og:url" content="https://chung9207.github.io/MacroEconometricModels.jl/hypothesis_tests/"/><meta property="twitter:url" content="https://chung9207.github.io/MacroEconometricModels.jl/hypothesis_tests/"/><link rel="canonical" href="https://chung9207.github.io/MacroEconometricModels.jl/hypothesis_tests/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MacroEconometricModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Univariate Models</span><ul><li><a class="tocitem" href="../arima/">ARIMA</a></li></ul></li><li><span class="tocitem">Frequentist Models</span><ul><li><a class="tocitem" href="../manual/">VAR</a></li><li><a class="tocitem" href="../lp/">Local Projections</a></li><li><a class="tocitem" href="../factormodels/">Factor Models</a></li></ul></li><li><span class="tocitem">Bayesian Models</span><ul><li><a class="tocitem" href="../bayesian/">Bayesian VAR</a></li></ul></li><li><a class="tocitem" href="../nongaussian/">Non-Gaussian SVAR</a></li><li><a class="tocitem" href="../innovation_accounting/">Innovation Accounting</a></li><li><span class="tocitem">Hypothesis Tests</span><ul><li class="is-active"><a class="tocitem" href>Unit Root &amp; Cointegration</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Quick-Start"><span>Quick Start</span></a></li><li><a class="tocitem" href="#Augmented-Dickey-Fuller-Test"><span>Augmented Dickey-Fuller Test</span></a></li><li><a class="tocitem" href="#KPSS-Stationarity-Test"><span>KPSS Stationarity Test</span></a></li><li><a class="tocitem" href="#Phillips-Perron-Test"><span>Phillips-Perron Test</span></a></li><li><a class="tocitem" href="#Zivot-Andrews-Test"><span>Zivot-Andrews Test</span></a></li><li><a class="tocitem" href="#Ng-Perron-Tests"><span>Ng-Perron Tests</span></a></li><li><a class="tocitem" href="#Johansen-Cointegration-Test"><span>Johansen Cointegration Test</span></a></li><li><a class="tocitem" href="#VAR-Stationarity-Check"><span>VAR Stationarity Check</span></a></li><li><a class="tocitem" href="#Convenience-Functions"><span>Convenience Functions</span></a></li><li><a class="tocitem" href="#Result-Types"><span>Result Types</span></a></li><li><a class="tocitem" href="#Practical-Workflow"><span>Practical Workflow</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../api/">Overview</a></li><li><a class="tocitem" href="../api_types/">Types</a></li><li><a class="tocitem" href="../api_functions/">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Hypothesis Tests</a></li><li class="is-active"><a href>Unit Root &amp; Cointegration</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Unit Root &amp; Cointegration</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/chung9207/MacroEconometricModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/main/docs/src/hypothesis_tests.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Hypothesis-Tests"><a class="docs-heading-anchor" href="#Hypothesis-Tests">Hypothesis Tests</a><a id="Hypothesis-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Hypothesis-Tests" title="Permalink"></a></h1><p>This chapter covers statistical hypothesis tests for time series analysis, including unit root tests for stationarity detection, cointegration tests for multivariate relationships, and VAR stability diagnostics.</p><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>Before fitting dynamic models like VARs or Local Projections, it is essential to understand the stationarity properties of the data. Non-stationary series (those with unit roots) require different treatment than stationary series, as standard regression methods can lead to spurious results.</p><p><strong>MacroEconometricModels.jl</strong> provides a comprehensive suite of unit root and stationarity tests.</p><h2 id="Quick-Start"><a class="docs-heading-anchor" href="#Quick-Start">Quick Start</a><a id="Quick-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Start" title="Permalink"></a></h2><pre><code class="language-julia hljs">adf_result = adf_test(y; lags=:aic, regression=:constant)          # ADF unit root test
kpss_result = kpss_test(y; regression=:constant)                    # KPSS stationarity test
pp_result = pp_test(y; regression=:constant)                        # Phillips-Perron test
za_result = za_test(y; regression=:both, trim=0.15)                 # Zivot-Andrews (structural break)
johansen_result = johansen_test(Y, 2; deterministic=:constant)      # Johansen cointegration</code></pre><h3 id="Univariate-Tests"><a class="docs-heading-anchor" href="#Univariate-Tests">Univariate Tests</a><a id="Univariate-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Univariate-Tests" title="Permalink"></a></h3><ol><li><strong>ADF (Augmented Dickey-Fuller)</strong>: Tests the null of a unit root against stationarity</li><li><strong>KPSS</strong>: Tests the null of stationarity against a unit root</li><li><strong>Phillips-Perron</strong>: Non-parametric unit root test with autocorrelation correction</li><li><strong>Zivot-Andrews</strong>: Unit root test allowing for endogenous structural break</li><li><strong>Ng-Perron</strong>: Modified tests with improved size properties</li></ol><h3 id="Multivariate-Tests"><a class="docs-heading-anchor" href="#Multivariate-Tests">Multivariate Tests</a><a id="Multivariate-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-Tests" title="Permalink"></a></h3><ol><li><strong>Johansen Cointegration</strong>: Tests for cointegrating relationships among variables</li></ol><h3 id="Model-Diagnostics"><a class="docs-heading-anchor" href="#Model-Diagnostics">Model Diagnostics</a><a id="Model-Diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Diagnostics" title="Permalink"></a></h3><ol><li><strong>VAR Stationarity</strong>: Check if an estimated VAR model is stable</li></ol><hr/><h2 id="Augmented-Dickey-Fuller-Test"><a class="docs-heading-anchor" href="#Augmented-Dickey-Fuller-Test">Augmented Dickey-Fuller Test</a><a id="Augmented-Dickey-Fuller-Test-1"></a><a class="docs-heading-anchor-permalink" href="#Augmented-Dickey-Fuller-Test" title="Permalink"></a></h2><h3 id="Theory"><a class="docs-heading-anchor" href="#Theory">Theory</a><a id="Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Theory" title="Permalink"></a></h3><p>The Augmented Dickey-Fuller (ADF) test examines whether a time series has a unit root. Consider the autoregressive model:</p><p class="math-container">\[y_t = \rho y_{t-1} + u_t\]</p><p>The null hypothesis is <span>$H_0: \rho = 1$</span> (unit root) against <span>$H_1: \rho &lt; 1$</span> (stationary).</p><p>The test is performed via the regression:</p><p class="math-container">\[\Delta y_t = \alpha + \beta t + \gamma y_{t-1} + \sum_{j=1}^{p} \delta_j \Delta y_{t-j} + \varepsilon_t\]</p><p>where:</p><ul><li><span>$\gamma = \rho - 1$</span> is the coefficient of interest</li><li><span>$\alpha$</span> is an optional constant</li><li><span>$\beta t$</span> is an optional linear trend</li><li>Lagged differences are included to control for serial correlation</li></ul><p>The ADF statistic is the t-ratio <span>$\tau = \hat{\gamma} / \text{se}(\hat{\gamma})$</span>.</p><p><strong>Critical values</strong> depend on the specification (none, constant, or trend) and are tabulated using MacKinnon (1994, 2010) response surfaces.</p><p><strong>Reference</strong>: Dickey &amp; Fuller (1979), MacKinnon (2010)</p><h3 id="Julia-Implementation"><a class="docs-heading-anchor" href="#Julia-Implementation">Julia Implementation</a><a id="Julia-Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-Implementation" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MacroEconometricModels

# Generate a random walk (has unit root)
y = cumsum(randn(200))

# ADF test with automatic lag selection via AIC
result = adf_test(y; lags=:aic, regression=:constant)

# The result displays with publication-quality formatting:
# - Test statistic and significance stars
# - Critical values at 1%, 5%, 10% levels
# - Automatic conclusion</code></pre><h3 id="Function-Signature"><a class="docs-heading-anchor" href="#Function-Signature">Function Signature</a><a id="Function-Signature-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Signature" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.adf_test"><a class="docstring-binding" href="#MacroEconometricModels.adf_test"><code>MacroEconometricModels.adf_test</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">adf_test(y; lags=:aic, max_lags=nothing, regression=:constant) -&gt; ADFResult</code></pre><p>Augmented Dickey-Fuller test for unit root.</p><p>Tests H₀: y has a unit root (non-stationary) against H₁: y is stationary.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>lags</code>: Number of augmenting lags, or :aic/:bic/:hqic for automatic selection</li><li><code>max_lags</code>: Maximum lags for automatic selection (default: floor(12*(T/100)^0.25))</li><li><code>regression</code>: Deterministic terms - :none, :constant (default), or :trend</li></ul><p><strong>Returns</strong></p><p><code>ADFResult</code> containing test statistic, p-value, critical values, etc.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = cumsum(randn(200))  # Random walk (has unit root)
result = adf_test(y)
result.pvalue &gt; 0.05  # Should fail to reject H₀</code></pre><p><strong>References</strong></p><ul><li>Dickey, D. A., &amp; Fuller, W. A. (1979). Distribution of the estimators for autoregressive time series with a unit root. JASA, 74(366), 427-431.</li><li>MacKinnon, J. G. (2010). Critical values for cointegration tests. Queen&#39;s Economics Department Working Paper No. 1227.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/unitroot.jl#L512-L540">source</a></section></details></article><h3 id="Options"><a class="docs-heading-anchor" href="#Options">Options</a><a id="Options-1"></a><a class="docs-heading-anchor-permalink" href="#Options" title="Permalink"></a></h3><table><tr><th style="text-align: right">Argument</th><th style="text-align: right">Description</th><th style="text-align: right">Default</th></tr><tr><td style="text-align: right"><code>lags</code></td><td style="text-align: right">Number of augmenting lags, or <code>:aic</code>/<code>:bic</code>/<code>:hqic</code> for automatic selection</td><td style="text-align: right"><code>:aic</code></td></tr><tr><td style="text-align: right"><code>max_lags</code></td><td style="text-align: right">Maximum lags for automatic selection</td><td style="text-align: right"><code>floor(12*(T/100)^0.25)</code></td></tr><tr><td style="text-align: right"><code>regression</code></td><td style="text-align: right">Deterministic terms: <code>:none</code>, <code>:constant</code>, or <code>:trend</code></td><td style="text-align: right"><code>:constant</code></td></tr></table><h3 id="ADFResult-Return-Values"><a class="docs-heading-anchor" href="#ADFResult-Return-Values">ADFResult Return Values</a><a id="ADFResult-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#ADFResult-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>statistic</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">ADF test statistic (<span>$\tau$</span>-ratio)</td></tr><tr><td style="text-align: right"><code>pvalue</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Asymptotic p-value (MacKinnon response surface)</td></tr><tr><td style="text-align: right"><code>lags</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of augmenting lags used</td></tr><tr><td style="text-align: right"><code>regression</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Deterministic specification (<code>:none</code>, <code>:constant</code>, <code>:trend</code>)</td></tr><tr><td style="text-align: right"><code>critical_values</code></td><td style="text-align: right"><code>Dict{Int,T}</code></td><td style="text-align: right">Critical values at 1%, 5%, 10% significance levels</td></tr><tr><td style="text-align: right"><code>nobs</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of observations used</td></tr></table><h3 id="Interpreting-Results"><a class="docs-heading-anchor" href="#Interpreting-Results">Interpreting Results</a><a id="Interpreting-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Interpreting-Results" title="Permalink"></a></h3><ul><li><strong>Reject H₀</strong> (p-value &lt; 0.05): Evidence against unit root; series appears stationary</li><li><strong>Fail to reject H₀</strong> (p-value &gt; 0.05): Cannot reject unit root; series may be non-stationary</li></ul><hr/><h2 id="KPSS-Stationarity-Test"><a class="docs-heading-anchor" href="#KPSS-Stationarity-Test">KPSS Stationarity Test</a><a id="KPSS-Stationarity-Test-1"></a><a class="docs-heading-anchor-permalink" href="#KPSS-Stationarity-Test" title="Permalink"></a></h2><h3 id="Theory-2"><a class="docs-heading-anchor" href="#Theory-2">Theory</a><a class="docs-heading-anchor-permalink" href="#Theory-2" title="Permalink"></a></h3><p>The KPSS test (Kwiatkowski, Phillips, Schmidt &amp; Shin, 1992) reverses the hypotheses of the ADF test:</p><ul><li><span>$H_0$</span>: Series is stationary (level or trend stationary)</li><li><span>$H_1$</span>: Series has a unit root</li></ul><p>This complementary approach is valuable because failure to reject in the ADF test does not confirm stationarity—it may simply reflect low power.</p><p>The test decomposes the series:</p><p class="math-container">\[y_t = \xi t + r_t + \varepsilon_t\]</p><p>where <span>$r_t = r_{t-1} + u_t$</span> is a random walk. Under <span>$H_0$</span>, the variance of <span>$u_t$</span> is zero.</p><p>The KPSS statistic is:</p><p class="math-container">\[\text{KPSS} = \frac{\sum_{t=1}^T S_t^2}{T^2 \hat{\sigma}^2_{LR}}\]</p><p>where <span>$S_t = \sum_{s=1}^t \hat{e}_s$</span> are partial sums of residuals and <span>$\hat{\sigma}^2_{LR}$</span> is the long-run variance estimated using a Bartlett kernel.</p><p><strong>Reference</strong>: Kwiatkowski et al. (1992)</p><h3 id="Julia-Implementation-2"><a class="docs-heading-anchor" href="#Julia-Implementation-2">Julia Implementation</a><a class="docs-heading-anchor-permalink" href="#Julia-Implementation-2" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MacroEconometricModels

# Stationary series
y = randn(200)
result = kpss_test(y; regression=:constant)

# For trend stationarity
result_trend = kpss_test(y; regression=:trend)</code></pre><h3 id="Function-Signature-2"><a class="docs-heading-anchor" href="#Function-Signature-2">Function Signature</a><a class="docs-heading-anchor-permalink" href="#Function-Signature-2" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.kpss_test"><a class="docstring-binding" href="#MacroEconometricModels.kpss_test"><code>MacroEconometricModels.kpss_test</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">kpss_test(y; regression=:constant, bandwidth=:auto) -&gt; KPSSResult</code></pre><p>Kwiatkowski-Phillips-Schmidt-Shin test for stationarity.</p><p>Tests H₀: y is stationary against H₁: y has a unit root.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>regression</code>: :constant (level stationarity) or :trend (trend stationarity)</li><li><code>bandwidth</code>: Bartlett kernel bandwidth, or :auto for Newey-West selection</li></ul><p><strong>Returns</strong></p><p><code>KPSSResult</code> containing test statistic, p-value, critical values, etc.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = randn(200)  # Stationary series
result = kpss_test(y)
result.pvalue &gt; 0.05  # Should fail to reject H₀ (stationarity)</code></pre><p><strong>References</strong></p><ul><li>Kwiatkowski, D., Phillips, P. C., Schmidt, P., &amp; Shin, Y. (1992). Testing the null hypothesis of stationarity against the alternative of a unit root. Journal of Econometrics, 54(1-3), 159-178.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/unitroot.jl#L604-L630">source</a></section></details></article><h3 id="Options-2"><a class="docs-heading-anchor" href="#Options-2">Options</a><a class="docs-heading-anchor-permalink" href="#Options-2" title="Permalink"></a></h3><table><tr><th style="text-align: right">Argument</th><th style="text-align: right">Description</th><th style="text-align: right">Default</th></tr><tr><td style="text-align: right"><code>regression</code></td><td style="text-align: right">Stationarity type: <code>:constant</code> (level) or <code>:trend</code></td><td style="text-align: right"><code>:constant</code></td></tr><tr><td style="text-align: right"><code>bandwidth</code></td><td style="text-align: right">Bartlett kernel bandwidth, or <code>:auto</code> for Newey-West selection</td><td style="text-align: right"><code>:auto</code></td></tr></table><h3 id="KPSSResult-Return-Values"><a class="docs-heading-anchor" href="#KPSSResult-Return-Values">KPSSResult Return Values</a><a id="KPSSResult-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#KPSSResult-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>statistic</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">KPSS test statistic</td></tr><tr><td style="text-align: right"><code>pvalue</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Asymptotic p-value</td></tr><tr><td style="text-align: right"><code>regression</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Stationarity type (<code>:constant</code> or <code>:trend</code>)</td></tr><tr><td style="text-align: right"><code>critical_values</code></td><td style="text-align: right"><code>Dict{Int,T}</code></td><td style="text-align: right">Critical values at 1%, 5%, 10%</td></tr><tr><td style="text-align: right"><code>bandwidth</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Bartlett kernel bandwidth used</td></tr><tr><td style="text-align: right"><code>nobs</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of observations</td></tr></table><h3 id="Interpreting-Results-2"><a class="docs-heading-anchor" href="#Interpreting-Results-2">Interpreting Results</a><a class="docs-heading-anchor-permalink" href="#Interpreting-Results-2" title="Permalink"></a></h3><ul><li><strong>Reject H₀</strong> (p-value &lt; 0.05): Evidence against stationarity; series has a unit root</li><li><strong>Fail to reject H₀</strong> (p-value &gt; 0.05): Cannot reject stationarity</li></ul><h3 id="Combining-ADF-and-KPSS"><a class="docs-heading-anchor" href="#Combining-ADF-and-KPSS">Combining ADF and KPSS</a><a id="Combining-ADF-and-KPSS-1"></a><a class="docs-heading-anchor-permalink" href="#Combining-ADF-and-KPSS" title="Permalink"></a></h3><p>Using both tests together provides stronger inference:</p><table><tr><th style="text-align: right">ADF Result</th><th style="text-align: right">KPSS Result</th><th style="text-align: right">Conclusion</th></tr><tr><td style="text-align: right">Reject H₀ (stationary)</td><td style="text-align: right">Fail to reject H₀ (stationary)</td><td style="text-align: right"><strong>Stationary</strong></td></tr><tr><td style="text-align: right">Fail to reject H₀ (unit root)</td><td style="text-align: right">Reject H₀ (unit root)</td><td style="text-align: right"><strong>Unit root</strong></td></tr><tr><td style="text-align: right">Reject H₀</td><td style="text-align: right">Reject H₀</td><td style="text-align: right">Conflicting (possible structural break)</td></tr><tr><td style="text-align: right">Fail to reject H₀</td><td style="text-align: right">Fail to reject H₀</td><td style="text-align: right">Inconclusive</td></tr></table><hr/><h2 id="Phillips-Perron-Test"><a class="docs-heading-anchor" href="#Phillips-Perron-Test">Phillips-Perron Test</a><a id="Phillips-Perron-Test-1"></a><a class="docs-heading-anchor-permalink" href="#Phillips-Perron-Test" title="Permalink"></a></h2><h3 id="Theory-3"><a class="docs-heading-anchor" href="#Theory-3">Theory</a><a class="docs-heading-anchor-permalink" href="#Theory-3" title="Permalink"></a></h3><p>The Phillips-Perron (PP) test is a non-parametric alternative to the ADF test. Instead of augmenting with lagged differences, the PP test corrects the t-statistic for serial correlation using Newey-West standard errors.</p><p>The regression is:</p><p class="math-container">\[y_t = \alpha + \rho y_{t-1} + u_t\]</p><p>The PP <span>$Z_t$</span> statistic adjusts the OLS t-ratio:</p><p class="math-container">\[Z_t = \sqrt{\frac{\hat{\gamma}_0}{\hat{\lambda}^2}} t_\rho - \frac{\hat{\lambda}^2 - \hat{\gamma}_0}{2\hat{\lambda} \cdot \text{se}(\hat{\rho}) \cdot \sqrt{T}}\]</p><p>where <span>$\hat{\gamma}_0$</span> is the short-run variance and <span>$\hat{\lambda}^2$</span> is the long-run variance.</p><p><strong>Advantage</strong>: Does not require specifying the number of lags.</p><p><strong>Reference</strong>: Phillips &amp; Perron (1988)</p><h3 id="Julia-Implementation-3"><a class="docs-heading-anchor" href="#Julia-Implementation-3">Julia Implementation</a><a class="docs-heading-anchor-permalink" href="#Julia-Implementation-3" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MacroEconometricModels

y = cumsum(randn(200))
result = pp_test(y; regression=:constant)</code></pre><h3 id="Function-Signature-3"><a class="docs-heading-anchor" href="#Function-Signature-3">Function Signature</a><a class="docs-heading-anchor-permalink" href="#Function-Signature-3" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.pp_test"><a class="docstring-binding" href="#MacroEconometricModels.pp_test"><code>MacroEconometricModels.pp_test</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pp_test(y; regression=:constant, bandwidth=:auto) -&gt; PPResult</code></pre><p>Phillips-Perron test for unit root with non-parametric correction.</p><p>Tests H₀: y has a unit root against H₁: y is stationary.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>regression</code>: :none, :constant (default), or :trend</li><li><code>bandwidth</code>: Newey-West bandwidth, or :auto for automatic selection</li></ul><p><strong>Returns</strong></p><p><code>PPResult</code> containing test statistic (Zt), p-value, critical values, etc.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = cumsum(randn(200))  # Random walk
result = pp_test(y)
result.pvalue &gt; 0.05  # Should fail to reject H₀</code></pre><p><strong>References</strong></p><ul><li>Phillips, P. C., &amp; Perron, P. (1988). Testing for a unit root in time series regression. Biometrika, 75(2), 335-346.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/unitroot.jl#L676-L701">source</a></section></details></article><h3 id="Options-3"><a class="docs-heading-anchor" href="#Options-3">Options</a><a class="docs-heading-anchor-permalink" href="#Options-3" title="Permalink"></a></h3><table><tr><th style="text-align: right">Argument</th><th style="text-align: right">Description</th><th style="text-align: right">Default</th></tr><tr><td style="text-align: right"><code>regression</code></td><td style="text-align: right">Deterministic terms: <code>:none</code>, <code>:constant</code>, or <code>:trend</code></td><td style="text-align: right"><code>:constant</code></td></tr><tr><td style="text-align: right"><code>bandwidth</code></td><td style="text-align: right">Newey-West bandwidth, or <code>:auto</code></td><td style="text-align: right"><code>:auto</code></td></tr></table><h3 id="PPResult-Return-Values"><a class="docs-heading-anchor" href="#PPResult-Return-Values">PPResult Return Values</a><a id="PPResult-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#PPResult-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>statistic</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Phillips-Perron <span>$Z_t$</span> test statistic</td></tr><tr><td style="text-align: right"><code>pvalue</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Asymptotic p-value</td></tr><tr><td style="text-align: right"><code>regression</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Deterministic specification</td></tr><tr><td style="text-align: right"><code>critical_values</code></td><td style="text-align: right"><code>Dict{Int,T}</code></td><td style="text-align: right">Critical values at 1%, 5%, 10%</td></tr><tr><td style="text-align: right"><code>bandwidth</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Newey-West bandwidth used</td></tr><tr><td style="text-align: right"><code>nobs</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of observations</td></tr></table><hr/><h2 id="Zivot-Andrews-Test"><a class="docs-heading-anchor" href="#Zivot-Andrews-Test">Zivot-Andrews Test</a><a id="Zivot-Andrews-Test-1"></a><a class="docs-heading-anchor-permalink" href="#Zivot-Andrews-Test" title="Permalink"></a></h2><h3 id="Theory-4"><a class="docs-heading-anchor" href="#Theory-4">Theory</a><a class="docs-heading-anchor-permalink" href="#Theory-4" title="Permalink"></a></h3><p>The Zivot-Andrews test extends the ADF test by allowing for an <strong>endogenous structural break</strong> in the series. This is important because standard unit root tests have low power against stationary alternatives with structural breaks.</p><p>Three specifications are available:</p><ol><li><strong>Break in intercept</strong> (<code>:constant</code>):</li></ol><p class="math-container">\[\Delta y_t = \alpha + \beta t + \theta DU_t + \gamma y_{t-1} + \sum_j \delta_j \Delta y_{t-j} + \varepsilon_t\]</p><ol><li><strong>Break in trend</strong> (<code>:trend</code>):</li></ol><p class="math-container">\[\Delta y_t = \alpha + \beta t + \phi DT_t + \gamma y_{t-1} + \sum_j \delta_j \Delta y_{t-j} + \varepsilon_t\]</p><ol><li><strong>Break in both</strong> (<code>:both</code>):</li></ol><p class="math-container">\[\Delta y_t = \alpha + \beta t + \theta DU_t + \phi DT_t + \gamma y_{t-1} + \sum_j \delta_j \Delta y_{t-j} + \varepsilon_t\]</p><p>where:</p><ul><li><span>$DU_t = 1$</span> if <span>$t &gt; T_B$</span> (level shift dummy)</li><li><span>$DT_t = t - T_B$</span> if <span>$t &gt; T_B$</span> (trend shift dummy)</li><li><span>$T_B$</span> is the break point, selected to minimize the t-statistic on <span>$\gamma$</span></li></ul><p><strong>Reference</strong>: Zivot &amp; Andrews (1992)</p><h3 id="Julia-Implementation-4"><a class="docs-heading-anchor" href="#Julia-Implementation-4">Julia Implementation</a><a class="docs-heading-anchor-permalink" href="#Julia-Implementation-4" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MacroEconometricModels

# Series with structural break
y = vcat(randn(100), randn(100) .+ 2)  # Level shift at t=100
result = za_test(y; regression=:constant)

# Access break point
println(&quot;Break detected at observation: &quot;, result.break_index)
println(&quot;Break location: &quot;, result.break_fraction * 100, &quot;% of sample&quot;)</code></pre><h3 id="Function-Signature-4"><a class="docs-heading-anchor" href="#Function-Signature-4">Function Signature</a><a class="docs-heading-anchor-permalink" href="#Function-Signature-4" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.za_test"><a class="docstring-binding" href="#MacroEconometricModels.za_test"><code>MacroEconometricModels.za_test</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">za_test(y; regression=:both, trim=0.15, lags=:aic, max_lags=nothing) -&gt; ZAResult</code></pre><p>Zivot-Andrews test for unit root with endogenous structural break.</p><p>Tests H₀: y has a unit root without break against H₁: y is stationary with break.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>regression</code>: Type of break - :constant (intercept), :trend (slope), or :both</li><li><code>trim</code>: Trimming fraction for break search (default 0.15)</li><li><code>lags</code>: Number of augmenting lags, or :aic/:bic for automatic selection</li><li><code>max_lags</code>: Maximum lags for selection</li></ul><p><strong>Returns</strong></p><p><code>ZAResult</code> containing minimum t-statistic, break point, p-value, etc.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Series with structural break
y = vcat(randn(100), randn(100) .+ 2)
result = za_test(y; regression=:constant)</code></pre><p><strong>References</strong></p><ul><li>Zivot, E., &amp; Andrews, D. W. K. (1992). Further evidence on the great crash, the oil-price shock, and the unit-root hypothesis. JBES, 10(3), 251-270.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/unitroot.jl#L769-L796">source</a></section></details></article><h3 id="Options-4"><a class="docs-heading-anchor" href="#Options-4">Options</a><a class="docs-heading-anchor-permalink" href="#Options-4" title="Permalink"></a></h3><table><tr><th style="text-align: right">Argument</th><th style="text-align: right">Description</th><th style="text-align: right">Default</th></tr><tr><td style="text-align: right"><code>regression</code></td><td style="text-align: right">Break type: <code>:constant</code>, <code>:trend</code>, or <code>:both</code></td><td style="text-align: right"><code>:both</code></td></tr><tr><td style="text-align: right"><code>trim</code></td><td style="text-align: right">Trimming fraction for break search</td><td style="text-align: right"><code>0.15</code></td></tr><tr><td style="text-align: right"><code>lags</code></td><td style="text-align: right">Augmenting lags, or <code>:aic</code>/<code>:bic</code></td><td style="text-align: right"><code>:aic</code></td></tr></table><h3 id="ZAResult-Return-Values"><a class="docs-heading-anchor" href="#ZAResult-Return-Values">ZAResult Return Values</a><a id="ZAResult-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#ZAResult-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>statistic</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Minimum ADF t-statistic over break candidates</td></tr><tr><td style="text-align: right"><code>pvalue</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Asymptotic p-value</td></tr><tr><td style="text-align: right"><code>break_index</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Estimated break point (observation index)</td></tr><tr><td style="text-align: right"><code>break_fraction</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Break location as fraction of sample (0 to 1)</td></tr><tr><td style="text-align: right"><code>regression</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Break type (<code>:constant</code>, <code>:trend</code>, <code>:both</code>)</td></tr><tr><td style="text-align: right"><code>critical_values</code></td><td style="text-align: right"><code>Dict{Int,T}</code></td><td style="text-align: right">Critical values at 1%, 5%, 10%</td></tr><tr><td style="text-align: right"><code>lags</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of augmenting lags</td></tr><tr><td style="text-align: right"><code>nobs</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of observations</td></tr></table><hr/><h2 id="Ng-Perron-Tests"><a class="docs-heading-anchor" href="#Ng-Perron-Tests">Ng-Perron Tests</a><a id="Ng-Perron-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Ng-Perron-Tests" title="Permalink"></a></h2><h3 id="Theory-5"><a class="docs-heading-anchor" href="#Theory-5">Theory</a><a class="docs-heading-anchor-permalink" href="#Theory-5" title="Permalink"></a></h3><p>The Ng-Perron tests (2001) are modified unit root tests with improved size and power properties, especially in small samples. They use GLS detrending and report four test statistics:</p><ol><li><strong>MZα</strong>: Modified Phillips Zα statistic</li><li><strong>MZt</strong>: Modified Phillips Zt statistic (most commonly used)</li><li><strong>MSB</strong>: Modified Sargan-Bhargava statistic</li><li><strong>MPT</strong>: Modified Point-optimal statistic</li></ol><p>The GLS detrending uses the quasi-difference:</p><p class="math-container">\[\tilde{y}_t = y_t - \bar{c}/T \cdot y_{t-1}\]</p><p>where <span>$\bar{c} = -7$</span> (constant) or <span>$\bar{c} = -13.5$</span> (trend).</p><p><strong>Advantage</strong>: Better size properties than ADF when the initial condition is far from zero.</p><p><strong>Reference</strong>: Ng &amp; Perron (2001)</p><h3 id="Julia-Implementation-5"><a class="docs-heading-anchor" href="#Julia-Implementation-5">Julia Implementation</a><a class="docs-heading-anchor-permalink" href="#Julia-Implementation-5" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MacroEconometricModels

y = cumsum(randn(100))
result = ngperron_test(y; regression=:constant)

# All four statistics are reported
println(&quot;MZα: &quot;, result.MZa)
println(&quot;MZt: &quot;, result.MZt)
println(&quot;MSB: &quot;, result.MSB)
println(&quot;MPT: &quot;, result.MPT)</code></pre><h3 id="Function-Signature-5"><a class="docs-heading-anchor" href="#Function-Signature-5">Function Signature</a><a class="docs-heading-anchor-permalink" href="#Function-Signature-5" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.ngperron_test"><a class="docstring-binding" href="#MacroEconometricModels.ngperron_test"><code>MacroEconometricModels.ngperron_test</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ngperron_test(y; regression=:constant) -&gt; NgPerronResult</code></pre><p>Ng-Perron unit root tests with GLS detrending (MZα, MZt, MSB, MPT).</p><p>Tests H₀: y has a unit root against H₁: y is stationary. These tests have better size properties than ADF/PP in small samples.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>regression</code>: :constant (default) or :trend</li></ul><p><strong>Returns</strong></p><p><code>NgPerronResult</code> containing MZα, MZt, MSB, MPT statistics and critical values.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = cumsum(randn(100))
result = ngperron_test(y)
# Check if MZt rejects at 5%
result.MZt &lt; result.critical_values[:MZt][5]</code></pre><p><strong>References</strong></p><ul><li>Ng, S., &amp; Perron, P. (2001). Lag length selection and the construction of unit root tests with good size and power. Econometrica, 69(6), 1519-1554.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/unitroot.jl#L905-L931">source</a></section></details></article><h3 id="NgPerronResult-Return-Values"><a class="docs-heading-anchor" href="#NgPerronResult-Return-Values">NgPerronResult Return Values</a><a id="NgPerronResult-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#NgPerronResult-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>MZa</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Modified Phillips <span>$Z_\alpha$</span> statistic</td></tr><tr><td style="text-align: right"><code>MZt</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Modified Phillips <span>$Z_t$</span> statistic (most commonly reported)</td></tr><tr><td style="text-align: right"><code>MSB</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Modified Sargan-Bhargava statistic</td></tr><tr><td style="text-align: right"><code>MPT</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Modified Point-optimal statistic</td></tr><tr><td style="text-align: right"><code>regression</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Deterministic specification</td></tr><tr><td style="text-align: right"><code>critical_values</code></td><td style="text-align: right"><code>Dict{Symbol,Dict{Int,T}}</code></td><td style="text-align: right">Critical values keyed by statistic name (<code>:MZa</code>, <code>:MZt</code>, <code>:MSB</code>, <code>:MPT</code>)</td></tr><tr><td style="text-align: right"><code>nobs</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of observations</td></tr></table><div class="admonition is-info" id="Technical-Note-c61c7b648d3e0b14"><header class="admonition-header">Technical Note<a class="admonition-anchor" href="#Technical-Note-c61c7b648d3e0b14" title="Permalink"></a></header><div class="admonition-body"><p>The Ng-Perron tests use GLS detrending which provides substantially better size properties than the standard ADF test in small samples (<span>$T &lt; 100$</span>). When the ADF test has borderline results, the Ng-Perron MZt statistic is a more reliable indicator. However, ADF remains preferable when the data-generating process has a large negative MA root, as GLS-based tests can be oversized in that case (Perron &amp; Ng, 1996).</p></div></div><hr/><h2 id="Johansen-Cointegration-Test"><a class="docs-heading-anchor" href="#Johansen-Cointegration-Test">Johansen Cointegration Test</a><a id="Johansen-Cointegration-Test-1"></a><a class="docs-heading-anchor-permalink" href="#Johansen-Cointegration-Test" title="Permalink"></a></h2><h3 id="Theory-6"><a class="docs-heading-anchor" href="#Theory-6">Theory</a><a class="docs-heading-anchor-permalink" href="#Theory-6" title="Permalink"></a></h3><p>The Johansen test examines whether multiple I(1) series share common stochastic trends, i.e., are <strong>cointegrated</strong>. Consider a VAR(p) in levels:</p><p class="math-container">\[y_t = A_1 y_{t-1} + \cdots + A_p y_{t-p} + u_t\]</p><p>This can be rewritten in Vector Error Correction Model (VECM) form:</p><p class="math-container">\[\Delta y_t = \Pi y_{t-1} + \sum_{i=1}^{p-1} \Gamma_i \Delta y_{t-i} + u_t\]</p><p>where <span>$\Pi = \alpha \beta&#39;$</span> is the long-run matrix:</p><ul><li><span>$\beta$</span>: Cointegrating vectors (equilibrium relationships)</li><li><span>$\alpha$</span>: Adjustment coefficients (speed of adjustment to equilibrium)</li><li><span>$\text{rank}(\Pi) = r$</span>: Number of cointegrating relationships</li></ul><p>Two test statistics are computed:</p><p><strong>Trace Test</strong>: Tests <span>$H_0: \text{rank} \leq r$</span> against <span>$H_1: \text{rank} &gt; r$</span></p><p class="math-container">\[\lambda_{trace}(r) = -T \sum_{i=r+1}^{n} \ln(1 - \hat{\lambda}_i)\]</p><p><strong>Maximum Eigenvalue Test</strong>: Tests <span>$H_0: \text{rank} = r$</span> against <span>$H_1: \text{rank} = r+1$</span></p><p class="math-container">\[\lambda_{max}(r) = -T \ln(1 - \hat{\lambda}_{r+1})\]</p><p><strong>Reference</strong>: Johansen (1991), Osterwald-Lenum (1992)</p><h3 id="Julia-Implementation-6"><a class="docs-heading-anchor" href="#Julia-Implementation-6">Julia Implementation</a><a class="docs-heading-anchor-permalink" href="#Julia-Implementation-6" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MacroEconometricModels

# Generate cointegrated system
T, n = 200, 3
Y = randn(T, n)
Y[:, 2] = Y[:, 1] + 0.1 * randn(T)  # Y2 cointegrated with Y1
Y[:, 3] = cumsum(randn(T))           # Y3 independent I(1)

# Johansen test with 2 lags in VECM
result = johansen_test(Y, 2; deterministic=:constant)

# Access results
println(&quot;Estimated cointegration rank: &quot;, result.rank)
println(&quot;Cointegrating vectors:\n&quot;, result.eigenvectors[:, 1:result.rank])
println(&quot;Adjustment coefficients:\n&quot;, result.adjustment)</code></pre><h3 id="Function-Signature-6"><a class="docs-heading-anchor" href="#Function-Signature-6">Function Signature</a><a class="docs-heading-anchor-permalink" href="#Function-Signature-6" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.johansen_test"><a class="docstring-binding" href="#MacroEconometricModels.johansen_test"><code>MacroEconometricModels.johansen_test</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">johansen_test(Y, p; deterministic=:constant) -&gt; JohansenResult</code></pre><p>Johansen cointegration test for VAR system.</p><p>Tests for the number of cointegrating relationships among variables using trace and maximum eigenvalue tests.</p><p><strong>Arguments</strong></p><ul><li><code>Y</code>: Data matrix (T × n)</li><li><code>p</code>: Number of lags in the VECM representation</li><li><code>deterministic</code>: Specification for deterministic terms<ul><li>:none - No deterministic terms</li><li>:constant - Constant in cointegrating relation (default)</li><li>:trend - Linear trend in levels</li></ul></li></ul><p><strong>Returns</strong></p><p><code>JohansenResult</code> containing trace and max-eigenvalue statistics, cointegrating vectors, adjustment coefficients, and estimated rank.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Generate cointegrated system
n, T = 3, 200
Y = randn(T, n)
Y[:, 2] = Y[:, 1] + 0.1 * randn(T)  # Y2 cointegrated with Y1

result = johansen_test(Y, 2)
result.rank  # Should detect 1 or 2 cointegrating relations</code></pre><p><strong>References</strong></p><ul><li>Johansen, S. (1991). Estimation and hypothesis testing of cointegration vectors in Gaussian vector autoregressive models. Econometrica, 59(6), 1551-1580.</li><li>Osterwald-Lenum, M. (1992). A note with quantiles of the asymptotic distribution of the ML cointegration rank test statistics. Oxford BEJM.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/unitroot.jl#L1018-L1054">source</a></section></details></article><h3 id="Options-5"><a class="docs-heading-anchor" href="#Options-5">Options</a><a class="docs-heading-anchor-permalink" href="#Options-5" title="Permalink"></a></h3><table><tr><th style="text-align: right">Argument</th><th style="text-align: right">Description</th><th style="text-align: right">Default</th></tr><tr><td style="text-align: right"><code>p</code></td><td style="text-align: right">Lags in VECM representation</td><td style="text-align: right">Required</td></tr><tr><td style="text-align: right"><code>deterministic</code></td><td style="text-align: right"><code>:none</code>, <code>:constant</code>, or <code>:trend</code></td><td style="text-align: right"><code>:constant</code></td></tr></table><h3 id="JohansenResult-Return-Values"><a class="docs-heading-anchor" href="#JohansenResult-Return-Values">JohansenResult Return Values</a><a id="JohansenResult-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#JohansenResult-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>trace_stats</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Trace test statistics for each rank hypothesis</td></tr><tr><td style="text-align: right"><code>trace_pvalues</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">P-values for trace statistics</td></tr><tr><td style="text-align: right"><code>max_eigen_stats</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Maximum eigenvalue test statistics</td></tr><tr><td style="text-align: right"><code>max_eigen_pvalues</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">P-values for max eigenvalue statistics</td></tr><tr><td style="text-align: right"><code>rank</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Estimated cointegration rank</td></tr><tr><td style="text-align: right"><code>eigenvectors</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$n \times n$</span> matrix of cointegrating vectors (columns)</td></tr><tr><td style="text-align: right"><code>adjustment</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$n \times n$</span> adjustment (loading) matrix <span>$\alpha$</span></td></tr><tr><td style="text-align: right"><code>eigenvalues</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Ordered eigenvalues from reduced-rank regression</td></tr><tr><td style="text-align: right"><code>critical_values_trace</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$n \times 3$</span> critical values for trace test (1%, 5%, 10%)</td></tr><tr><td style="text-align: right"><code>critical_values_max</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$n \times 3$</span> critical values for max eigenvalue test</td></tr><tr><td style="text-align: right"><code>deterministic</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Deterministic specification (<code>:none</code>, <code>:constant</code>, <code>:trend</code>)</td></tr><tr><td style="text-align: right"><code>lags</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of VECM lags</td></tr><tr><td style="text-align: right"><code>nobs</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of observations</td></tr></table><h3 id="Interpreting-Results-3"><a class="docs-heading-anchor" href="#Interpreting-Results-3">Interpreting Results</a><a class="docs-heading-anchor-permalink" href="#Interpreting-Results-3" title="Permalink"></a></h3><p>The test sequentially tests:</p><ol><li><span>$H_0: r = 0$</span> (no cointegration)</li><li><span>$H_0: r \leq 1$</span></li><li><span>$H_0: r \leq 2$</span>, etc.</li></ol><p>Stop at the first non-rejected hypothesis; that gives the cointegration rank.</p><hr/><h2 id="VAR-Stationarity-Check"><a class="docs-heading-anchor" href="#VAR-Stationarity-Check">VAR Stationarity Check</a><a id="VAR-Stationarity-Check-1"></a><a class="docs-heading-anchor-permalink" href="#VAR-Stationarity-Check" title="Permalink"></a></h2><h3 id="Theory-7"><a class="docs-heading-anchor" href="#Theory-7">Theory</a><a class="docs-heading-anchor-permalink" href="#Theory-7" title="Permalink"></a></h3><p>A VAR(p) model is <strong>stable</strong> (stationary) if and only if all eigenvalues of the companion matrix lie strictly inside the unit circle:</p><p class="math-container">\[F = \begin{bmatrix}
A_1 &amp; A_2 &amp; \cdots &amp; A_{p-1} &amp; A_p \\
I_n &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\
0 &amp; I_n &amp; \cdots &amp; 0 &amp; 0 \\
\vdots &amp; &amp; \ddots &amp; &amp; \vdots \\
0 &amp; 0 &amp; \cdots &amp; I_n &amp; 0
\end{bmatrix}\]</p><p><strong>Stability Condition</strong>: <span>$|\lambda_i| &lt; 1$</span> for all eigenvalues <span>$\lambda_i$</span> of <span>$F$</span>.</p><p>If violated, the VAR is explosive or contains unit roots, and standard asymptotic theory does not apply.</p><h3 id="Julia-Implementation-7"><a class="docs-heading-anchor" href="#Julia-Implementation-7">Julia Implementation</a><a class="docs-heading-anchor-permalink" href="#Julia-Implementation-7" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MacroEconometricModels

# Estimate VAR
Y = randn(200, 3)
model = fit(VARModel, Y, 2)

# Check stationarity
result = is_stationary(model)

if result.is_stationary
    println(&quot;VAR is stationary&quot;)
    println(&quot;Maximum eigenvalue modulus: &quot;, result.max_modulus)
else
    println(&quot;WARNING: VAR is non-stationary!&quot;)
    println(&quot;Maximum eigenvalue modulus: &quot;, result.max_modulus)
    println(&quot;Consider differencing or VECM specification&quot;)
end</code></pre><h3 id="Function-Signature-7"><a class="docs-heading-anchor" href="#Function-Signature-7">Function Signature</a><a class="docs-heading-anchor-permalink" href="#Function-Signature-7" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.is_stationary"><a class="docstring-binding" href="#MacroEconometricModels.is_stationary"><code>MacroEconometricModels.is_stationary</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_stationary(model::VARModel) -&gt; VARStationarityResult</code></pre><p>Check if estimated VAR model is stationary.</p><p>A VAR(p) is stationary if and only if all eigenvalues of the companion matrix have modulus strictly less than 1.</p><p><strong>Returns</strong></p><p><code>VARStationarityResult</code> with:</p><ul><li><code>is_stationary</code>: Boolean indicating stationarity</li><li><code>eigenvalues</code>: Complex eigenvalues of companion matrix</li><li><code>max_modulus</code>: Maximum eigenvalue modulus</li><li><code>companion_matrix</code>: The (np × np) companion form matrix</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">model = estimate_var(Y, 2)
result = is_stationary(model)
if !result.is_stationary
    println(&quot;Warning: VAR is non-stationary, max modulus = &quot;, result.max_modulus)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/unitroot.jl#L1211-L1234">source</a></section><section><div><pre><code class="language-julia hljs">is_stationary(model::DynamicFactorModel) -&gt; Bool</code></pre><p>Check if factor dynamics are stationary (max |eigenvalue| &lt; 1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/dynamicfactor.jl#L441-L445">source</a></section></details></article><h3 id="VARStationarityResult-Return-Values"><a class="docs-heading-anchor" href="#VARStationarityResult-Return-Values">VARStationarityResult Return Values</a><a id="VARStationarityResult-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#VARStationarityResult-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>is_stationary</code></td><td style="text-align: right"><code>Bool</code></td><td style="text-align: right"><code>true</code> if all eigenvalues lie inside unit circle</td></tr><tr><td style="text-align: right"><code>eigenvalues</code></td><td style="text-align: right"><code>Vector{E}</code></td><td style="text-align: right">Eigenvalues of the companion matrix (may be complex)</td></tr><tr><td style="text-align: right"><code>max_modulus</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Maximum eigenvalue modulus (should be <span>$&lt; 1$</span> for stability)</td></tr><tr><td style="text-align: right"><code>companion_matrix</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$np \times np$</span> companion matrix</td></tr></table><hr/><h2 id="Convenience-Functions"><a class="docs-heading-anchor" href="#Convenience-Functions">Convenience Functions</a><a id="Convenience-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Convenience-Functions" title="Permalink"></a></h2><h3 id="Summary-of-Multiple-Tests"><a class="docs-heading-anchor" href="#Summary-of-Multiple-Tests">Summary of Multiple Tests</a><a id="Summary-of-Multiple-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Summary-of-Multiple-Tests" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MacroEconometricModels

y = cumsum(randn(200))

# Run multiple tests and get summary
summary = unit_root_summary(y; tests=[:adf, :kpss, :pp])

# Access individual results
summary.results[:adf]
summary.results[:kpss]

# Overall conclusion
println(summary.conclusion)</code></pre><h3 id="Test-All-Variables"><a class="docs-heading-anchor" href="#Test-All-Variables">Test All Variables</a><a id="Test-All-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Test-All-Variables" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MacroEconometricModels

Y = randn(200, 5)
Y[:, 1] = cumsum(Y[:, 1])  # Make first column non-stationary

# Apply ADF test to all columns
results = test_all_variables(Y; test=:adf)

# Check which variables have unit roots
for (i, r) in enumerate(results)
    status = r.pvalue &gt; 0.05 ? &quot;I(1)&quot; : &quot;I(0)&quot;
    println(&quot;Variable $i: p=$(round(r.pvalue, digits=3)) → $status&quot;)
end</code></pre><h3 id="Function-Signatures"><a class="docs-heading-anchor" href="#Function-Signatures">Function Signatures</a><a id="Function-Signatures-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Signatures" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.unit_root_summary"><a class="docstring-binding" href="#MacroEconometricModels.unit_root_summary"><code>MacroEconometricModels.unit_root_summary</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">unit_root_summary(y; tests=[:adf, :kpss, :pp], kwargs...) -&gt; NamedTuple</code></pre><p>Run multiple unit root tests and return summary with PrettyTables output.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>tests</code>: Vector of test symbols to run (default: [:adf, :kpss, :pp])</li><li><code>kwargs...</code>: Additional arguments passed to individual tests</li></ul><p><strong>Returns</strong></p><p>NamedTuple with test results, conclusion, and summary table.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = cumsum(randn(200))
summary = unit_root_summary(y)
summary.conclusion  # Overall conclusion</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/unitroot.jl#L1246-L1265">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.test_all_variables"><a class="docstring-binding" href="#MacroEconometricModels.test_all_variables"><code>MacroEconometricModels.test_all_variables</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">test_all_variables(Y; test=:adf, kwargs...) -&gt; Vector</code></pre><p>Apply unit root test to each column of Y.</p><p><strong>Arguments</strong></p><ul><li><code>Y</code>: Data matrix (T × n)</li><li><code>test</code>: Test to apply (:adf, :kpss, :pp, :za, :ngperron)</li><li><code>kwargs...</code>: Additional arguments passed to the test</li></ul><p><strong>Returns</strong></p><p>Vector of test results, one per variable.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">Y = randn(200, 3)
Y[:, 1] = cumsum(Y[:, 1])  # Make first column non-stationary
results = test_all_variables(Y; test=:adf)
[r.pvalue for r in results]  # P-values for each variable</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/unitroot.jl#L1309-L1329">source</a></section></details></article><hr/><h2 id="Result-Types"><a class="docs-heading-anchor" href="#Result-Types">Result Types</a><a id="Result-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Result-Types" title="Permalink"></a></h2><p>All unit root test results inherit from <code>AbstractUnitRootTest</code> and implement the StatsAPI interface:</p><pre><code class="language-julia hljs">using StatsAPI

result = adf_test(y)

# StatsAPI interface
nobs(result)    # Number of observations
dof(result)     # Degrees of freedom
pvalue(result)  # P-value</code></pre><h3 id="Type-Hierarchy"><a class="docs-heading-anchor" href="#Type-Hierarchy">Type Hierarchy</a><a id="Type-Hierarchy-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Hierarchy" title="Permalink"></a></h3><p>All unit root test results inherit from <code>AbstractUnitRootTest</code> and implement the StatsAPI interface. See the <a href="../api/#API-Reference">API Reference</a> for detailed type documentation.</p><ul><li><code>ADFResult</code> - Augmented Dickey-Fuller test result</li><li><code>KPSSResult</code> - KPSS stationarity test result</li><li><code>PPResult</code> - Phillips-Perron test result</li><li><code>ZAResult</code> - Zivot-Andrews structural break test result</li><li><code>NgPerronResult</code> - Ng-Perron test result (MZα, MZt, MSB, MPT)</li><li><code>JohansenResult</code> - Johansen cointegration test result</li><li><code>VARStationarityResult</code> - VAR model stationarity check result</li></ul><hr/><h2 id="Practical-Workflow"><a class="docs-heading-anchor" href="#Practical-Workflow">Practical Workflow</a><a id="Practical-Workflow-1"></a><a class="docs-heading-anchor-permalink" href="#Practical-Workflow" title="Permalink"></a></h2><h3 id="Step-by-Step-Unit-Root-Analysis"><a class="docs-heading-anchor" href="#Step-by-Step-Unit-Root-Analysis">Step-by-Step Unit Root Analysis</a><a id="Step-by-Step-Unit-Root-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Step-by-Step-Unit-Root-Analysis" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MacroEconometricModels

# 1. Load/generate data
y = your_time_series

# 2. Visual inspection (plot the series)
# Look for trends, structural breaks, etc.

# 3. Test for unit root with ADF
adf_result = adf_test(y; regression=:constant)

# 4. Confirm with KPSS (opposite null)
kpss_result = kpss_test(y; regression=:constant)

# 5. If structural break suspected, use Zivot-Andrews
za_result = za_test(y; regression=:both)

# 6. For small samples, use Ng-Perron
np_result = ngperron_test(y; regression=:constant)

# 7. Decision matrix
if pvalue(adf_result) &lt; 0.05 &amp;&amp; pvalue(kpss_result) &gt; 0.05
    println(&quot;Series is stationary - proceed with VAR in levels&quot;)
elseif pvalue(adf_result) &gt; 0.05 &amp;&amp; pvalue(kpss_result) &lt; 0.05
    println(&quot;Series has unit root - consider differencing or VECM&quot;)
else
    println(&quot;Inconclusive - examine further or use robust methods&quot;)
end</code></pre><h3 id="Pre-VAR-Analysis"><a class="docs-heading-anchor" href="#Pre-VAR-Analysis">Pre-VAR Analysis</a><a id="Pre-VAR-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Pre-VAR-Analysis" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MacroEconometricModels

# Multi-variable dataset
Y = your_data_matrix

# 1. Test each variable for unit root
results = test_all_variables(Y; test=:adf)
n_nonstationary = sum(r.pvalue &gt; 0.05 for r in results)
println(&quot;Variables with unit roots: $n_nonstationary / $(size(Y, 2))&quot;)

# 2. If all I(1), test for cointegration
if n_nonstationary == size(Y, 2)
    johansen_result = johansen_test(Y, 2)

    if johansen_result.rank &gt; 0
        println(&quot;Cointegration detected! Use VECM with rank=$(johansen_result.rank)&quot;)
    else
        println(&quot;No cointegration - use VAR in first differences&quot;)
    end
end

# 3. If mixed I(0)/I(1), be cautious
# Consider ARDL bounds test or transform I(1) variables</code></pre><hr/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><h3 id="Unit-Root-Tests"><a class="docs-heading-anchor" href="#Unit-Root-Tests">Unit Root Tests</a><a id="Unit-Root-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Unit-Root-Tests" title="Permalink"></a></h3><ul><li>Dickey, David A., and Wayne A. Fuller. 1979. &quot;Distribution of the Estimators for Autoregressive Time Series with a Unit Root.&quot; <em>Journal of the American Statistical Association</em> 74 (366): 427–431. <a href="https://doi.org/10.1080/01621459.1979.10482531">https://doi.org/10.1080/01621459.1979.10482531</a></li><li>Kwiatkowski, Denis, Peter C. B. Phillips, Peter Schmidt, and Yongcheol Shin. 1992. &quot;Testing the Null Hypothesis of Stationarity Against the Alternative of a Unit Root.&quot; <em>Journal of Econometrics</em> 54 (1–3): 159–178. <a href="https://doi.org/10.1016/0304-4076(92)90104-Y">https://doi.org/10.1016/0304-4076(92)90104-Y</a></li><li>MacKinnon, James G. 2010. &quot;Critical Values for Cointegration Tests.&quot; Queen&#39;s Economics Department Working Paper No. 1227.</li><li>Ng, Serena, and Pierre Perron. 2001. &quot;Lag Length Selection and the Construction of Unit Root Tests with Good Size and Power.&quot; <em>Econometrica</em> 69 (6): 1519–1554. <a href="https://doi.org/10.1111/1468-0262.00256">https://doi.org/10.1111/1468-0262.00256</a></li><li>Phillips, Peter C. B., and Pierre Perron. 1988. &quot;Testing for a Unit Root in Time Series Regression.&quot; <em>Biometrika</em> 75 (2): 335–346. <a href="https://doi.org/10.1093/biomet/75.2.335">https://doi.org/10.1093/biomet/75.2.335</a></li><li>Zivot, Eric, and Donald W. K. Andrews. 1992. &quot;Further Evidence on the Great Crash, the Oil-Price Shock, and the Unit-Root Hypothesis.&quot; <em>Journal of Business &amp; Economic Statistics</em> 10 (3): 251–270. <a href="https://doi.org/10.1080/07350015.1992.10509904">https://doi.org/10.1080/07350015.1992.10509904</a></li></ul><h3 id="Cointegration"><a class="docs-heading-anchor" href="#Cointegration">Cointegration</a><a id="Cointegration-1"></a><a class="docs-heading-anchor-permalink" href="#Cointegration" title="Permalink"></a></h3><ul><li>Johansen, Søren. 1991. &quot;Estimation and Hypothesis Testing of Cointegration Vectors in Gaussian Vector Autoregressive Models.&quot; <em>Econometrica</em> 59 (6): 1551–1580. <a href="https://doi.org/10.2307/2938278">https://doi.org/10.2307/2938278</a></li><li>Johansen, Søren. 1995. <em>Likelihood-Based Inference in Cointegrated Vector Autoregressive Models</em>. Oxford: Oxford University Press. ISBN 978-0-19-877450-5.</li><li>Osterwald-Lenum, Michael. 1992. &quot;A Note with Quantiles of the Asymptotic Distribution of the Maximum Likelihood Cointegration Rank Test Statistics.&quot; <em>Oxford Bulletin of Economics and Statistics</em> 54 (3): 461–472. <a href="https://doi.org/10.1111/j.1468-0084.1992.tb00013.x">https://doi.org/10.1111/j.1468-0084.1992.tb00013.x</a></li></ul><h3 id="Textbooks"><a class="docs-heading-anchor" href="#Textbooks">Textbooks</a><a id="Textbooks-1"></a><a class="docs-heading-anchor-permalink" href="#Textbooks" title="Permalink"></a></h3><ul><li>Hamilton, James D. 1994. <em>Time Series Analysis</em>. Princeton, NJ: Princeton University Press. ISBN 978-0-691-04289-3.</li><li>Lütkepohl, Helmut. 2005. <em>New Introduction to Multiple Time Series Analysis</em>. Berlin: Springer. ISBN 978-3-540-40172-8.</li><li>Enders, Walter. 2014. <em>Applied Econometric Time Series</em>. 4th ed. Hoboken, NJ: Wiley. ISBN 978-1-118-80856-6.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../innovation_accounting/">« Innovation Accounting</a><a class="docs-footer-nextpage" href="../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 6 February 2026 03:03">Friday 6 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
