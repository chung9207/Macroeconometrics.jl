<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · MacroEconometricModels.jl</title><meta name="title" content="Functions · MacroEconometricModels.jl"/><meta property="og:title" content="Functions · MacroEconometricModels.jl"/><meta property="twitter:title" content="Functions · MacroEconometricModels.jl"/><meta name="description" content="Documentation for MacroEconometricModels.jl."/><meta property="og:description" content="Documentation for MacroEconometricModels.jl."/><meta property="twitter:description" content="Documentation for MacroEconometricModels.jl."/><meta property="og:url" content="https://chung9207.github.io/MacroEconometricModels.jl/api_functions/"/><meta property="twitter:url" content="https://chung9207.github.io/MacroEconometricModels.jl/api_functions/"/><link rel="canonical" href="https://chung9207.github.io/MacroEconometricModels.jl/api_functions/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MacroEconometricModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Univariate Models</span><ul><li><a class="tocitem" href="../arima/">ARIMA</a></li></ul></li><li><span class="tocitem">Frequentist Models</span><ul><li><a class="tocitem" href="../manual/">VAR</a></li><li><a class="tocitem" href="../lp/">Local Projections</a></li><li><a class="tocitem" href="../factormodels/">Factor Models</a></li></ul></li><li><span class="tocitem">Bayesian Models</span><ul><li><a class="tocitem" href="../bayesian/">Bayesian VAR</a></li></ul></li><li><a class="tocitem" href="../nongaussian/">Non-Gaussian SVAR</a></li><li><a class="tocitem" href="../innovation_accounting/">Innovation Accounting</a></li><li><span class="tocitem">Hypothesis Tests</span><ul><li><a class="tocitem" href="../hypothesis_tests/">Unit Root &amp; Cointegration</a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../api/">Overview</a></li><li><a class="tocitem" href="../api_types/">Types</a></li><li class="is-active"><a class="tocitem" href>Functions</a><ul class="internal"><li><a class="tocitem" href="#ARIMA-Models"><span>ARIMA Models</span></a></li><li><a class="tocitem" href="#VAR-Estimation"><span>VAR Estimation</span></a></li><li><a class="tocitem" href="#Structural-Identification"><span>Structural Identification</span></a></li><li><a class="tocitem" href="#Innovation-Accounting"><span>Innovation Accounting</span></a></li><li><a class="tocitem" href="#Local-Projections"><span>Local Projections</span></a></li><li><a class="tocitem" href="#Factor-Models"><span>Factor Models</span></a></li><li><a class="tocitem" href="#GMM-Estimation"><span>GMM Estimation</span></a></li><li><a class="tocitem" href="#Unit-Root-and-Cointegration-Tests"><span>Unit Root and Cointegration Tests</span></a></li><li><a class="tocitem" href="#Non-Gaussian-SVAR-Identification"><span>Non-Gaussian SVAR Identification</span></a></li><li><a class="tocitem" href="#Utility-Functions"><span>Utility Functions</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/chung9207/MacroEconometricModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/main/docs/src/api_functions.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="api_functions"><a class="docs-heading-anchor" href="#api_functions">API Functions</a><a id="api_functions-1"></a><a class="docs-heading-anchor-permalink" href="#api_functions" title="Permalink"></a></h1><p>This page documents all functions in <strong>MacroEconometricModels.jl</strong>, organized by module.</p><hr/><h2 id="ARIMA-Models"><a class="docs-heading-anchor" href="#ARIMA-Models">ARIMA Models</a><a id="ARIMA-Models-1"></a><a class="docs-heading-anchor-permalink" href="#ARIMA-Models" title="Permalink"></a></h2><h3 id="Estimation"><a class="docs-heading-anchor" href="#Estimation">Estimation</a><a id="Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Estimation" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_ar"><a class="docstring-binding" href="#MacroEconometricModels.estimate_ar"><code>MacroEconometricModels.estimate_ar</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">estimate_ar(y, p; method=:ols, include_intercept=true) -&gt; ARModel</code></pre><p>Estimate AR(p) model: yₜ = c + φ₁yₜ₋₁ + ... + φₚyₜ₋ₚ + εₜ</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>p</code>: AR order (must be ≥ 1)</li><li><code>method</code>: Estimation method (:ols or :mle)</li><li><code>include_intercept</code>: Whether to include constant term</li></ul><p><strong>Returns</strong></p><p><code>ARModel</code> with estimated coefficients and diagnostics.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = randn(200)
model = estimate_ar(y, 2)
println(model.phi)  # AR coefficients</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_estimation.jl#L354-L374">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_ma"><a class="docstring-binding" href="#MacroEconometricModels.estimate_ma"><code>MacroEconometricModels.estimate_ma</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">estimate_ma(y, q; method=:css_mle, include_intercept=true, max_iter=500) -&gt; MAModel</code></pre><p>Estimate MA(q) model: yₜ = c + εₜ + θ₁εₜ₋₁ + ... + θqεₜ₋q</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>q</code>: MA order (must be ≥ 1)</li><li><code>method</code>: Estimation method (:css, :mle, or :css_mle)</li><li><code>include_intercept</code>: Whether to include constant term</li><li><code>max_iter</code>: Maximum optimization iterations</li></ul><p><strong>Returns</strong></p><p><code>MAModel</code> with estimated coefficients and diagnostics.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = randn(200)
model = estimate_ma(y, 1)
println(model.theta)  # MA coefficient</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_estimation.jl#L444-L465">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_arma"><a class="docstring-binding" href="#MacroEconometricModels.estimate_arma"><code>MacroEconometricModels.estimate_arma</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">estimate_arma(y, p, q; method=:css_mle, include_intercept=true, max_iter=500) -&gt; ARMAModel</code></pre><p>Estimate ARMA(p,q) model: yₜ = c + φ₁yₜ₋₁ + ... + φₚyₜ₋ₚ + εₜ + θ₁εₜ₋₁ + ... + θqεₜ₋q</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>p</code>: AR order</li><li><code>q</code>: MA order</li><li><code>method</code>: Estimation method (:css, :mle, or :css_mle)</li><li><code>include_intercept</code>: Whether to include constant term</li><li><code>max_iter</code>: Maximum optimization iterations</li></ul><p><strong>Returns</strong></p><p><code>ARMAModel</code> with estimated coefficients and diagnostics.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = randn(200)
model = estimate_arma(y, 1, 1)
println(&quot;AR: &quot;, model.phi, &quot; MA: &quot;, model.theta)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_estimation.jl#L482-L505">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_arima"><a class="docstring-binding" href="#MacroEconometricModels.estimate_arima"><code>MacroEconometricModels.estimate_arima</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">estimate_arima(y, p, d, q; method=:css_mle, include_intercept=true, max_iter=500) -&gt; ARIMAModel</code></pre><p>Estimate ARIMA(p,d,q) model by differencing d times and fitting ARMA(p,q).</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>p</code>: AR order</li><li><code>d</code>: Integration order (number of differences)</li><li><code>q</code>: MA order</li><li><code>method</code>: Estimation method (:css, :mle, or :css_mle)</li><li><code>include_intercept</code>: Whether to include constant term (on differenced series)</li><li><code>max_iter</code>: Maximum optimization iterations</li></ul><p><strong>Returns</strong></p><p><code>ARIMAModel</code> with estimated coefficients and diagnostics.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = cumsum(randn(200))  # Random walk
model = estimate_arima(y, 1, 1, 0)  # ARIMA(1,1,0)
println(model.phi)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_estimation.jl#L522-L545">source</a></section></details></article><h3 id="Forecasting"><a class="docs-heading-anchor" href="#Forecasting">Forecasting</a><a id="Forecasting-1"></a><a class="docs-heading-anchor-permalink" href="#Forecasting" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels._compute_psi_weights-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._compute_psi_weights-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._compute_psi_weights</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_compute_psi_weights(phi, theta, h) -&gt; Vector{T}</code></pre><p>Compute ψ-weights for the MA(∞) representation of an ARMA process.</p><p>The ARMA(p,q) process can be written as: yₜ = μ + Σⱼ₌₀^∞ ψⱼ εₜ₋ⱼ</p><p>where ψ₀ = 1 and ψⱼ follows the recursion: ψⱼ = φ₁ψⱼ₋₁ + ... + φₚψⱼ₋ₚ + θⱼ</p><p>Returns [ψ₁, ψ₂, ..., ψₕ] (excludes ψ₀ = 1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_forecast.jl#L31-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._confidence_band-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, T}} where T"><a class="docstring-binding" href="#MacroEconometricModels._confidence_band-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, T}} where T"><code>MacroEconometricModels._confidence_band</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_confidence_band(forecasts, se, conf_level)</code></pre><p>Compute symmetric confidence interval bounds from forecasts, standard errors, and a confidence level.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_forecast.jl#L16-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._forecast_arma-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, T, Vector{T}, Vector{T}, T, Int64, T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._forecast_arma-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, T, Vector{T}, Vector{T}, T, Int64, T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._forecast_arma</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_forecast_arma(y, resid, c, phi, theta, sigma2, h, conf_level) -&gt; ARIMAForecast</code></pre><p>Unified point forecast + CI computation for any ARMA(p,q) model. AR models pass <code>theta=T[]</code>, MA models pass <code>phi=T[]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_forecast.jl#L93-L98">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._forecast_variance-Union{Tuple{T}, Tuple{T, Vector{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._forecast_variance-Union{Tuple{T}, Tuple{T, Vector{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._forecast_variance</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_forecast_variance(sigma2, psi, h) -&gt; Vector{T}</code></pre><p>Compute h-step ahead forecast variance.</p><p>Var(eₜ₊ₕ) = σ² (1 + ψ₁² + ψ₂² + ... + ψₕ₋₁²)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_forecast.jl#L69-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._integrate_forecasts-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._integrate_forecasts-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._integrate_forecasts</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_integrate_forecasts(y, fc_diff, d) -&gt; Vector{T}</code></pre><p>Integrate d-differenced forecasts back to original scale.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_forecast.jl#L190-L194">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._integrate_se-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._integrate_se-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._integrate_se</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_integrate_se(se_diff, d) -&gt; Vector{T}</code></pre><p>Approximate standard errors after integration.</p><p>For d-fold integration, the variance grows roughly as h^d. This is a conservative approximation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_forecast.jl#L229-L236">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{ARIMAModel{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{ARIMAModel{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.forecast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">forecast(model::ARIMAModel, h; conf_level=0.95) -&gt; ARIMAForecast</code></pre><p>Compute h-step ahead forecasts with confidence intervals for ARIMA model. Forecasts are computed on the differenced series and then integrated back to the original scale.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_forecast.jl#L168-L174">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{ARMAModel{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{ARMAModel{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.forecast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">forecast(model::ARMAModel, h; conf_level=0.95) -&gt; ARIMAForecast</code></pre><p>Compute h-step ahead forecasts with confidence intervals for ARMA model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_forecast.jl#L158-L162">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{ARModel{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{ARModel{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.forecast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">forecast(model::ARModel, h; conf_level=0.95) -&gt; ARIMAForecast</code></pre><p>Compute h-step ahead forecasts with confidence intervals for AR model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_forecast.jl#L138-L142">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{MAModel{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{MAModel{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.forecast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">forecast(model::MAModel, h; conf_level=0.95) -&gt; ARIMAForecast</code></pre><p>Compute h-step ahead forecasts with confidence intervals for MA model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_forecast.jl#L148-L152">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.predict-Tuple{AbstractARIMAModel, Int64}"><a class="docstring-binding" href="#StatsAPI.predict-Tuple{AbstractARIMAModel, Int64}"><code>StatsAPI.predict</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">predict(model::AbstractARIMAModel, h::Int) -&gt; Vector{T}</code></pre><p>Return h-step ahead point forecasts (without confidence intervals).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_forecast.jl#L257-L261">source</a></section></details></article><h3 id="Order-Selection"><a class="docs-heading-anchor" href="#Order-Selection">Order Selection</a><a id="Order-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#Order-Selection" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.select_arima_order"><a class="docstring-binding" href="#MacroEconometricModels.select_arima_order"><code>MacroEconometricModels.select_arima_order</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">select_arima_order(y, max_p, max_q; criterion=:bic, d=0, method=:css_mle, include_intercept=true)</code></pre><p>Automatically select ARMA/ARIMA order via grid search over information criteria.</p><p>Searches over p ∈ 0:max<em>p and q ∈ 0:max</em>q, fits each model, and selects the order that minimizes the specified information criterion.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>max_p</code>: Maximum AR order to consider</li><li><code>max_q</code>: Maximum MA order to consider</li><li><code>criterion</code>: Selection criterion (:aic or :bic, default :bic)</li><li><code>d</code>: Integration order for ARIMA (default 0 = ARMA)</li><li><code>method</code>: Estimation method (:css, :mle, or :css_mle)</li><li><code>include_intercept</code>: Whether to include constant term</li></ul><p><strong>Returns</strong></p><p><code>ARIMAOrderSelection</code> with best orders, IC matrices, and fitted models.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = randn(200)
result = select_arima_order(y, 3, 3; criterion=:bic)
println(&quot;Best order: p=$(result.best_p_bic), q=$(result.best_q_bic)&quot;)
best_model = result.best_model_bic</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_selection.jl#L11-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.auto_arima"><a class="docstring-binding" href="#MacroEconometricModels.auto_arima"><code>MacroEconometricModels.auto_arima</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">auto_arima(y; max_p=5, max_q=5, max_d=2, criterion=:bic, method=:css_mle)</code></pre><p>Automatically select and fit the best ARIMA model.</p><p>Performs order selection over p, d, and q using the specified criterion. For integration order d, uses unit root test heuristics.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>max_p</code>: Maximum AR order (default 5)</li><li><code>max_q</code>: Maximum MA order (default 5)</li><li><code>max_d</code>: Maximum integration order (default 2)</li><li><code>criterion</code>: Selection criterion (:aic or :bic)</li><li><code>method</code>: Estimation method</li></ul><p><strong>Returns</strong></p><p>Best fitted ARIMAModel or ARMAModel.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = cumsum(randn(200))
model = auto_arima(y)
println(model)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_selection.jl#L108-L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.ic_table"><a class="docstring-binding" href="#MacroEconometricModels.ic_table"><code>MacroEconometricModels.ic_table</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ic_table(result::ARIMAOrderSelection; criterion=:bic)</code></pre><p>Return a formatted table of IC values for printing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_selection.jl#L183-L187">source</a></section></details></article><hr/><h2 id="VAR-Estimation"><a class="docs-heading-anchor" href="#VAR-Estimation">VAR Estimation</a><a id="VAR-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#VAR-Estimation" title="Permalink"></a></h2><h3 id="Frequentist-Estimation"><a class="docs-heading-anchor" href="#Frequentist-Estimation">Frequentist Estimation</a><a id="Frequentist-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Frequentist-Estimation" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels._compute_aic_bic-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels._compute_aic_bic-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T"><code>MacroEconometricModels._compute_aic_bic</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_compute_aic_bic(loglik, k, n)</code></pre><p>Compute AIC and BIC from log-likelihood, number of parameters k, and sample size n.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_estimation.jl#L34-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._count_params-Tuple{Int64, Int64}"><a class="docstring-binding" href="#MacroEconometricModels._count_params-Tuple{Int64, Int64}"><code>MacroEconometricModels._count_params</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_count_params(p, q; include_intercept=true)</code></pre><p>Count total number of parameters: intercept + AR + MA + sigma2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_estimation.jl#L42-L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._css_objective-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._css_objective-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._css_objective</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_css_objective(params, y, p, q; include_intercept=true) -&gt; T</code></pre><p>Conditional Sum of Squares objective function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_estimation.jl#L198-L202">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._difference-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._difference-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._difference</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Apply d-order differencing to a time series.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_estimation.jl#L84">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._estimate_ar_ols-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._estimate_ar_ols-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._estimate_ar_ols</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Estimate AR model via OLS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_estimation.jl#L394">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._estimate_arma_internal-Union{Tuple{T}, Tuple{Vector{T}, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._estimate_arma_internal-Union{Tuple{T}, Tuple{Vector{T}, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._estimate_arma_internal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_estimate_arma_internal(y, p, q; method=:css_mle, include_intercept=true, max_iter=500)</code></pre><p>Unified estimation dispatcher for ARMA(p,q). Routes to CSS, MLE, or CSS→MLE. Returns 9-tuple: (c, phi, theta, sigma2, loglik, residuals, fitted, converged, iterations).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_estimation.jl#L325-L330">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._estimate_css-Union{Tuple{T}, Tuple{Vector{T}, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._estimate_css-Union{Tuple{T}, Tuple{Vector{T}, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._estimate_css</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_estimate_css(y, p, q; ...) -&gt; (c, phi, theta, sigma2, loglik, residuals, fitted, converged, iterations)</code></pre><p>Estimate ARMA parameters via Conditional Sum of Squares. Returns the same 9-tuple as <code>_estimate_mle</code> for pipeline consistency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_estimation.jl#L220-L225">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._estimate_mle-Union{Tuple{T}, Tuple{Vector{T}, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._estimate_mle-Union{Tuple{T}, Tuple{Vector{T}, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._estimate_mle</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_estimate_mle(y, p, q; include_intercept=true, init_params=nothing, max_iter=500, tol=1e-8)</code></pre><p>Estimate ARMA parameters via Maximum Likelihood using Kalman filter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_estimation.jl#L269-L273">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._innovations_algorithm-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._innovations_algorithm-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._innovations_algorithm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_innovations_algorithm(y, q) -&gt; theta</code></pre><p>Estimate MA coefficients via innovations algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_estimation.jl#L149-L153">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._pack_arma_params-Union{Tuple{T}, Tuple{T, Vector{T}, Vector{T}}} where T"><a class="docstring-binding" href="#MacroEconometricModels._pack_arma_params-Union{Tuple{T}, Tuple{T, Vector{T}, Vector{T}}} where T"><code>MacroEconometricModels._pack_arma_params</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_pack_arma_params(c, phi, theta; include_intercept=true, log_sigma2=nothing)</code></pre><p>Pack ARMA parameters into a single vector for optimization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_estimation.jl#L18-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._truncate_to_invertible-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._truncate_to_invertible-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._truncate_to_invertible</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Truncate MA coefficients to ensure invertibility.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_estimation.jl#L191">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._truncate_to_stable-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._truncate_to_stable-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._truncate_to_stable</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Scale coefficients until all companion-matrix eigenvalues lie inside the unit circle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_estimation.jl#L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._truncate_to_stationary-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._truncate_to_stationary-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._truncate_to_stationary</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Truncate AR coefficients to ensure stationarity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_estimation.jl#L145">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._validate_arima_inputs-Union{Tuple{T}, Tuple{Vector{T}, Int64, Int64, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels._validate_arima_inputs-Union{Tuple{T}, Tuple{Vector{T}, Int64, Int64, Int64}} where T"><code>MacroEconometricModels._validate_arima_inputs</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Validate ARIMA inputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_estimation.jl#L69">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._white_noise_fit-Union{Tuple{Vector{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#MacroEconometricModels._white_noise_fit-Union{Tuple{Vector{T}}, Tuple{T}} where T"><code>MacroEconometricModels._white_noise_fit</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_white_noise_fit(y; include_intercept=true)</code></pre><p>Fit a white-noise (p=0, q=0) model. Returns (c, sigma2, loglik, residuals, fitted).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_estimation.jl#L50-L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._yule_walker-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._yule_walker-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._yule_walker</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_yule_walker(y, p) -&gt; phi</code></pre><p>Estimate AR coefficients via Yule-Walker equations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_estimation.jl#L98-L102">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_ar-Union{Tuple{T}, Tuple{AbstractVector{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_ar-Union{Tuple{T}, Tuple{AbstractVector{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_ar</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_ar(y, p; method=:ols, include_intercept=true) -&gt; ARModel</code></pre><p>Estimate AR(p) model: yₜ = c + φ₁yₜ₋₁ + ... + φₚyₜ₋ₚ + εₜ</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>p</code>: AR order (must be ≥ 1)</li><li><code>method</code>: Estimation method (:ols or :mle)</li><li><code>include_intercept</code>: Whether to include constant term</li></ul><p><strong>Returns</strong></p><p><code>ARModel</code> with estimated coefficients and diagnostics.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = randn(200)
model = estimate_ar(y, 2)
println(model.phi)  # AR coefficients</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_estimation.jl#L354-L374">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_arima-Union{Tuple{T}, Tuple{AbstractVector{T}, Int64, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_arima-Union{Tuple{T}, Tuple{AbstractVector{T}, Int64, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_arima</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_arima(y, p, d, q; method=:css_mle, include_intercept=true, max_iter=500) -&gt; ARIMAModel</code></pre><p>Estimate ARIMA(p,d,q) model by differencing d times and fitting ARMA(p,q).</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>p</code>: AR order</li><li><code>d</code>: Integration order (number of differences)</li><li><code>q</code>: MA order</li><li><code>method</code>: Estimation method (:css, :mle, or :css_mle)</li><li><code>include_intercept</code>: Whether to include constant term (on differenced series)</li><li><code>max_iter</code>: Maximum optimization iterations</li></ul><p><strong>Returns</strong></p><p><code>ARIMAModel</code> with estimated coefficients and diagnostics.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = cumsum(randn(200))  # Random walk
model = estimate_arima(y, 1, 1, 0)  # ARIMA(1,1,0)
println(model.phi)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_estimation.jl#L522-L545">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_arma-Union{Tuple{T}, Tuple{AbstractVector{T}, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_arma-Union{Tuple{T}, Tuple{AbstractVector{T}, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_arma</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_arma(y, p, q; method=:css_mle, include_intercept=true, max_iter=500) -&gt; ARMAModel</code></pre><p>Estimate ARMA(p,q) model: yₜ = c + φ₁yₜ₋₁ + ... + φₚyₜ₋ₚ + εₜ + θ₁εₜ₋₁ + ... + θqεₜ₋q</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>p</code>: AR order</li><li><code>q</code>: MA order</li><li><code>method</code>: Estimation method (:css, :mle, or :css_mle)</li><li><code>include_intercept</code>: Whether to include constant term</li><li><code>max_iter</code>: Maximum optimization iterations</li></ul><p><strong>Returns</strong></p><p><code>ARMAModel</code> with estimated coefficients and diagnostics.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = randn(200)
model = estimate_arma(y, 1, 1)
println(&quot;AR: &quot;, model.phi, &quot; MA: &quot;, model.theta)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_estimation.jl#L482-L505">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_ma-Union{Tuple{T}, Tuple{AbstractVector{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_ma-Union{Tuple{T}, Tuple{AbstractVector{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_ma</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_ma(y, q; method=:css_mle, include_intercept=true, max_iter=500) -&gt; MAModel</code></pre><p>Estimate MA(q) model: yₜ = c + εₜ + θ₁εₜ₋₁ + ... + θqεₜ₋q</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>q</code>: MA order (must be ≥ 1)</li><li><code>method</code>: Estimation method (:css, :mle, or :css_mle)</li><li><code>include_intercept</code>: Whether to include constant term</li><li><code>max_iter</code>: Maximum optimization iterations</li></ul><p><strong>Returns</strong></p><p><code>MAModel</code> with estimated coefficients and diagnostics.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = randn(200)
model = estimate_ma(y, 1)
println(model.theta)  # MA coefficient</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/arima_estimation.jl#L444-L465">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_var-Tuple{DataFrames.DataFrame, Int64}"><a class="docstring-binding" href="#MacroEconometricModels.estimate_var-Tuple{DataFrames.DataFrame, Int64}"><code>MacroEconometricModels.estimate_var</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Estimate VAR from DataFrame. Use <code>vars</code> to select columns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/estimation.jl#L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_var-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_var-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_var</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_var(Y::AbstractMatrix{T}, p::Int; check_stability::Bool=true) -&gt; VARModel{T}</code></pre><p>Estimate VAR(p) via OLS: Yₜ = c + A₁Yₜ₋₁ + ... + AₚYₜ₋ₚ + uₜ.</p><p><strong>Arguments</strong></p><ul><li><code>Y</code>: Data matrix (T × n)</li><li><code>p</code>: Number of lags</li><li><code>check_stability</code>: If true (default), warns if estimated VAR is non-stationary</li></ul><p><strong>Returns</strong></p><p><code>VARModel</code> with estimated coefficients, residuals, covariance matrix, and information criteria.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/estimation.jl#L11-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.select_lag_order-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.select_lag_order-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.select_lag_order</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Select optimal lag order via information criterion (:aic, :bic, :hqic).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/estimation.jl#L142">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.confint-Union{Tuple{VARModel{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#StatsAPI.confint-Union{Tuple{VARModel{T}}, Tuple{T}} where T"><code>StatsAPI.confint</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Confidence intervals at given level (default 95%).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/estimation.jl#L131">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.loglikelihood-Union{Tuple{VARModel{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#StatsAPI.loglikelihood-Union{Tuple{VARModel{T}}, Tuple{T}} where T"><code>StatsAPI.loglikelihood</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Gaussian log-likelihood.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/estimation.jl#L123">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.predict-Tuple{VARModel}"><a class="docstring-binding" href="#StatsAPI.predict-Tuple{VARModel}"><code>StatsAPI.predict</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>In-sample fitted values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/estimation.jl#L93">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.predict-Union{Tuple{T}, Tuple{VARModel{T}, Int64}} where T"><a class="docstring-binding" href="#StatsAPI.predict-Union{Tuple{T}, Tuple{VARModel{T}, Int64}} where T"><code>StatsAPI.predict</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Out-of-sample forecasts for <code>steps</code> periods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/estimation.jl#L96">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.r2-Union{Tuple{VARModel{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#StatsAPI.r2-Union{Tuple{VARModel{T}}, Tuple{T}} where T"><code>StatsAPI.r2</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>R² for each equation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/estimation.jl#L117">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.vcov-Union{Tuple{VARModel{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#StatsAPI.vcov-Union{Tuple{VARModel{T}}, Tuple{T}} where T"><code>StatsAPI.vcov</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Covariance of vectorized coefficients: Σ ⊗ (X&#39;X)⁻¹.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/estimation.jl#L87">source</a></section></details></article><h3 id="Bayesian-Estimation"><a class="docs-heading-anchor" href="#Bayesian-Estimation">Bayesian Estimation</a><a id="Bayesian-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Bayesian-Estimation" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_bvar-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_bvar-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_bvar</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_bvar(Y, p; n_samples=1000, n_adapts=500, prior=:normal, hyper=nothing,
              sampler=:nuts, sampler_args=(;)) -&gt; Chains</code></pre><p>Estimate Bayesian VAR via Turing.jl MCMC.</p><p>Samplers: :nuts (default), :hmc, :hmcda, :is, :smc, :pg. Prior: :normal (default) or :minnesota with optional <code>hyper::MinnesotaHyperparameters</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/bayesian.jl#L70-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.extract_chain_parameters-Tuple{MCMCChains.Chains}"><a class="docstring-binding" href="#MacroEconometricModels.extract_chain_parameters-Tuple{MCMCChains.Chains}"><code>MacroEconometricModels.extract_chain_parameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extract_chain_parameters(chain::Chains) -&gt; (b_vecs, sigmas)</code></pre><p>Extract coefficient vectors and covariance matrices from MCMC chain. Handles both diagonal (gradient samplers) and InverseWishart (particle samplers) parameterizations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/bayesian.jl#L112-L117">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.get_sampler-Tuple{Symbol, Int64, NamedTuple}"><a class="docstring-binding" href="#MacroEconometricModels.get_sampler-Tuple{Symbol, Int64, NamedTuple}"><code>MacroEconometricModels.get_sampler</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Create Turing sampler from symbol. Supports: :nuts, :hmc, :hmcda, :is, :smc, :pg.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/bayesian.jl#L53">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.parameters_to_model-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Int64, Int64}, Tuple{AbstractVector{T}, AbstractVector{T}, Int64, Int64, AbstractMatrix{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.parameters_to_model-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Int64, Int64}, Tuple{AbstractVector{T}, AbstractVector{T}, Int64, Int64, AbstractMatrix{T}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.parameters_to_model</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Convert chain parameters to VARModel. Provide <code>data</code> for residual computation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/bayesian.jl#L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.posterior_mean_model-Tuple{MCMCChains.Chains, Int64, Int64}"><a class="docstring-binding" href="#MacroEconometricModels.posterior_mean_model-Tuple{MCMCChains.Chains, Int64, Int64}"><code>MacroEconometricModels.posterior_mean_model</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>VARModel with posterior mean parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/bayesian.jl#L174">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.posterior_median_model-Tuple{MCMCChains.Chains, Int64, Int64}"><a class="docstring-binding" href="#MacroEconometricModels.posterior_median_model-Tuple{MCMCChains.Chains, Int64, Int64}"><code>MacroEconometricModels.posterior_median_model</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>VARModel with posterior median parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/bayesian.jl#L180">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.var_bayes_sequential-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.var_bayes_sequential-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.var_bayes_sequential</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Sequential BVAR model with full covariance for particle-based samplers (SMC, PG). Uses InverseWishart for compatibility with particle samplers (no AD required).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/bayesian.jl#L32-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.var_bayes_vectorized-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.var_bayes_vectorized-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.var_bayes_vectorized</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Vectorized BVAR model for gradient-based samplers (NUTS, HMC, HMCDA). Uses diagonal covariance for numerical stability with ForwardDiff AD.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/bayesian.jl#L11-L13">source</a></section></details></article><h3 id="Prior-Specification"><a class="docs-heading-anchor" href="#Prior-Specification">Prior Specification</a><a id="Prior-Specification-1"></a><a class="docs-heading-anchor-permalink" href="#Prior-Specification" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.gen_dummy_obs-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, MinnesotaHyperparameters}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.gen_dummy_obs-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, MinnesotaHyperparameters}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.gen_dummy_obs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gen_dummy_obs(Y, p, hyper) -&gt; (Y_dummy, X_dummy)</code></pre><p>Generate Minnesota prior dummy observations. Hyperparameters: tau (tightness), decay, lambda (sum-of-coef), mu (co-persistence), omega.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/priors.jl#L11-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.log_marginal_likelihood-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, MinnesotaHyperparameters}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.log_marginal_likelihood-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, MinnesotaHyperparameters}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.log_marginal_likelihood</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">log_marginal_likelihood(Y, p, hyper) -&gt; T</code></pre><p>Closed-form log marginal likelihood for BVAR with Minnesota prior.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/priors.jl#L95-L99">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.optimize_hyperparameters-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.optimize_hyperparameters-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.optimize_hyperparameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Optimize tau via grid search on marginal likelihood.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/priors.jl#L134">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.optimize_hyperparameters_full-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.optimize_hyperparameters_full-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.optimize_hyperparameters_full</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Full grid search over tau, lambda, mu.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/priors.jl#L150">source</a></section></details></article><hr/><h2 id="Structural-Identification"><a class="docs-heading-anchor" href="#Structural-Identification">Structural Identification</a><a id="Structural-Identification-1"></a><a class="docs-heading-anchor-permalink" href="#Structural-Identification" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MacroEconometricModels._build_zero_constraint_matrix-Union{Tuple{T}, Tuple{SVARRestrictions, Int64, Array{Matrix{T}, 1}, LinearAlgebra.LowerTriangular{T, Matrix{T}}}} where T"><a class="docstring-binding" href="#MacroEconometricModels._build_zero_constraint_matrix-Union{Tuple{T}, Tuple{SVARRestrictions, Int64, Array{Matrix{T}, 1}, LinearAlgebra.LowerTriangular{T, Matrix{T}}}} where T"><code>MacroEconometricModels._build_zero_constraint_matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Build constraint matrix for zero restrictions on shock j.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/identification.jl#L248">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._check_sign_restrictions-Union{Tuple{T}, Tuple{Array{T, 3}, SVARRestrictions}} where T"><a class="docstring-binding" href="#MacroEconometricModels._check_sign_restrictions-Union{Tuple{T}, Tuple{Array{T, 3}, SVARRestrictions}} where T"><code>MacroEconometricModels._check_sign_restrictions</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Check if all sign restrictions are satisfied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/identification.jl#L241">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._check_zero_restrictions-Union{Tuple{T}, Tuple{Array{T, 3}, SVARRestrictions}} where T"><a class="docstring-binding" href="#MacroEconometricModels._check_zero_restrictions-Union{Tuple{T}, Tuple{Array{T, 3}, SVARRestrictions}} where T"><code>MacroEconometricModels._check_zero_restrictions</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Check if all zero restrictions are satisfied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/identification.jl#L237">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._compute_importance_weight-Union{Tuple{T}, Tuple{Matrix{T}, SVARRestrictions, Array{Matrix{T}, 1}, LinearAlgebra.LowerTriangular{T, Matrix{T}}}} where T"><a class="docstring-binding" href="#MacroEconometricModels._compute_importance_weight-Union{Tuple{T}, Tuple{Matrix{T}, SVARRestrictions, Array{Matrix{T}, 1}, LinearAlgebra.LowerTriangular{T, Matrix{T}}}} where T"><code>MacroEconometricModels._compute_importance_weight</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute importance weight for Q (corrects non-uniform prior from zero restrictions).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/identification.jl#L287">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._compute_irf_for_Q-Union{Tuple{T}, Tuple{VARModel{T}, Matrix{T}, Array{Matrix{T}, 1}, LinearAlgebra.LowerTriangular{T, Matrix{T}}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._compute_irf_for_Q-Union{Tuple{T}, Tuple{VARModel{T}, Matrix{T}, Array{Matrix{T}, 1}, LinearAlgebra.LowerTriangular{T, Matrix{T}}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._compute_irf_for_Q</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute structural IRF for rotation Q.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/identification.jl#L223">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._compute_ma_coefficients-Union{Tuple{T}, Tuple{VARModel{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._compute_ma_coefficients-Union{Tuple{T}, Tuple{VARModel{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._compute_ma_coefficients</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute MA coefficients Φ<em>0, ..., Φ</em>horizon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/identification.jl#L199">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._draw_Q_with_zero_restrictions-Union{Tuple{T}, Tuple{SVARRestrictions, Array{Matrix{T}, 1}, LinearAlgebra.LowerTriangular{T, Matrix{T}}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._draw_Q_with_zero_restrictions-Union{Tuple{T}, Tuple{SVARRestrictions, Array{Matrix{T}, 1}, LinearAlgebra.LowerTriangular{T, Matrix{T}}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._draw_Q_with_zero_restrictions</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Draw orthogonal Q satisfying zero restrictions (Algorithm 2, Arias et al. 2018).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/identification.jl#L271">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._draw_null_space_vector-Union{Tuple{T}, Tuple{Array{Vector{T}, 1}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._draw_null_space_vector-Union{Tuple{T}, Tuple{Array{Vector{T}, 1}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._draw_null_space_vector</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Draw unit vector from null space of constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/identification.jl#L253">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._draw_uniform_orthogonal-Union{Tuple{Int64}, Tuple{T}, Tuple{Int64, Type{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._draw_uniform_orthogonal-Union{Tuple{Int64}, Tuple{T}, Tuple{Int64, Type{T}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._draw_uniform_orthogonal</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Draw uniformly from O(n) via QR decomposition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/identification.jl#L211">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._weighted_quantile-Union{Tuple{S}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{S}, Real}} where {T, S}"><a class="docstring-binding" href="#MacroEconometricModels._weighted_quantile-Union{Tuple{S}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{S}, Real}} where {T, S}"><code>MacroEconometricModels._weighted_quantile</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Weighted quantile via linear interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/identification.jl#L407">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.compute_Q-Union{Tuple{T}, Tuple{VARModel{T}, Symbol, Int64, Any, Any}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.compute_Q-Union{Tuple{T}, Tuple{VARModel{T}, Symbol, Int64, Any, Any}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.compute_Q</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_Q(model, method, horizon, check_func, narrative_check; max_draws=100)</code></pre><p>Compute identification matrix Q. Methods: :cholesky, :sign, :narrative, :long_run.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/identification.jl#L122-L126">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.compute_irf-Union{Tuple{T}, Tuple{VARModel{T}, AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.compute_irf-Union{Tuple{T}, Tuple{VARModel{T}, AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.compute_irf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_irf(model, Q, horizon) -&gt; Array{T,3}</code></pre><p>Compute IRFs for rotation matrix Q. Returns (horizon × n × n) array. IRF[h, i, j] = response of variable i to shock j at horizon h-1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/identification.jl#L30-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.compute_structural_shocks-Union{Tuple{T}, Tuple{VARModel{T}, AbstractMatrix{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.compute_structural_shocks-Union{Tuple{T}, Tuple{VARModel{T}, AbstractMatrix{T}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.compute_structural_shocks</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute structural shocks: εₜ = Q&#39;L⁻¹uₜ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/identification.jl#L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.generate_Q-Union{Tuple{Int64}, Tuple{T}, Tuple{Int64, Type{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.generate_Q-Union{Tuple{Int64}, Tuple{T}, Tuple{Int64, Type{T}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.generate_Q</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Generate random orthogonal matrix via QR decomposition (Haar measure).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/identification.jl#L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_arias-Union{Tuple{T}, Tuple{VARModel{T}, SVARRestrictions, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.identify_arias-Union{Tuple{T}, Tuple{VARModel{T}, SVARRestrictions, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.identify_arias</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">identify_arias(model, restrictions, horizon; n_draws=1000, n_rotations=1000) -&gt; AriasSVARResult</code></pre><p>Identify SVAR using Arias et al. (2018) with zero and sign restrictions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/identification.jl#L311-L315">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_arias_bayesian-Tuple{Any, Int64, Int64, SVARRestrictions, Int64}"><a class="docstring-binding" href="#MacroEconometricModels.identify_arias_bayesian-Tuple{Any, Int64, Int64, SVARRestrictions, Int64}"><code>MacroEconometricModels.identify_arias_bayesian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">identify_arias_bayesian(chain, p, n, restrictions, horizon; data=nothing, n_rotations=100, quantiles=[0.16,0.5,0.84])</code></pre><p>Apply Arias identification to each posterior draw. Returns IRF quantiles, mean, acceptance rates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/identification.jl#L358-L362">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_cholesky-Union{Tuple{VARModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.identify_cholesky-Union{Tuple{VARModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.identify_cholesky</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Identify via Cholesky decomposition (recursive ordering). Returns L where Σ = LL&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/identification.jl#L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_long_run-Union{Tuple{VARModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.identify_long_run-Union{Tuple{VARModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.identify_long_run</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Identify via long-run restrictions: long-run cumulative impact matrix is lower triangular.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/identification.jl#L107">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_narrative-Union{Tuple{T}, Tuple{VARModel{T}, Int64, Function, Function}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.identify_narrative-Union{Tuple{T}, Tuple{VARModel{T}, Int64, Function, Function}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.identify_narrative</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">identify_narrative(model, horizon, sign_check, narrative_check; max_draws=1000)</code></pre><p>Combine sign and narrative restrictions. Returns (Q, irf, shocks).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/identification.jl#L84-L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_sign-Union{Tuple{T}, Tuple{VARModel{T}, Int64, Function}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.identify_sign-Union{Tuple{T}, Tuple{VARModel{T}, Int64, Function}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.identify_sign</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">identify_sign(model, horizon, check_func; max_draws=1000) -&gt; (Q, irf)</code></pre><p>Find Q satisfying sign restrictions via random draws.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/identification.jl#L64-L68">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.irf_mean-Union{Tuple{AriasSVARResult{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#MacroEconometricModels.irf_mean-Union{Tuple{AriasSVARResult{T}}, Tuple{T}} where T"><code>MacroEconometricModels.irf_mean</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute weighted mean IRF from AriasSVARResult.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/identification.jl#L441">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.irf_percentiles-Union{Tuple{AriasSVARResult{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#MacroEconometricModels.irf_percentiles-Union{Tuple{AriasSVARResult{T}}, Tuple{T}} where T"><code>MacroEconometricModels.irf_percentiles</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute weighted IRF percentiles from AriasSVARResult.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/identification.jl#L429">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.sign_restriction-Tuple{Int64, Int64, Symbol}"><a class="docstring-binding" href="#MacroEconometricModels.sign_restriction-Tuple{Int64, Int64, Symbol}"><code>MacroEconometricModels.sign_restriction</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Create sign restriction: variable response has given sign (:positive/:negative) at horizon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/identification.jl#L425">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.zero_restriction-Tuple{Int64, Int64}"><a class="docstring-binding" href="#MacroEconometricModels.zero_restriction-Tuple{Int64, Int64}"><code>MacroEconometricModels.zero_restriction</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Create zero restriction: variable doesn&#39;t respond to shock at horizon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/identification.jl#L422">source</a></section></details></article><hr/><h2 id="Innovation-Accounting"><a class="docs-heading-anchor" href="#Innovation-Accounting">Innovation Accounting</a><a id="Innovation-Accounting-1"></a><a class="docs-heading-anchor-permalink" href="#Innovation-Accounting" title="Permalink"></a></h2><h3 id="Impulse-Response-Functions"><a class="docs-heading-anchor" href="#Impulse-Response-Functions">Impulse Response Functions</a><a id="Impulse-Response-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Impulse-Response-Functions" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels._simulate_irfs-Union{Tuple{T}, Tuple{VARModel{T}, Symbol, Int64, Any, Any, Symbol, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._simulate_irfs-Union{Tuple{T}, Tuple{VARModel{T}, Symbol, Int64, Any, Any, Symbol, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._simulate_irfs</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Simulate IRFs for confidence intervals (bootstrap or asymptotic).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/irf.jl#L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._simulate_var-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._simulate_var-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._simulate_var</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Simulate VAR data from initial conditions and innovations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/irf.jl#L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.cumulative_irf-Union{Tuple{LPImpulseResponse{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.cumulative_irf-Union{Tuple{LPImpulseResponse{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.cumulative_irf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cumulative_irf(irf::LPImpulseResponse{T}) -&gt; LPImpulseResponse{T}</code></pre><p>Compute cumulative impulse response: Σₛ₌₀ʰ β_s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/irf.jl#L169-L173">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.irf-Tuple{MCMCChains.Chains, Int64, Int64, Int64}"><a class="docstring-binding" href="#MacroEconometricModels.irf-Tuple{MCMCChains.Chains, Int64, Int64, Int64}"><code>MacroEconometricModels.irf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">irf(chain, p, n, horizon; method=:cholesky, quantiles=[0.16, 0.5, 0.84], ...)</code></pre><p>Compute Bayesian IRFs from MCMC chain with posterior quantiles.</p><p>Uses <code>process_posterior_samples</code> and <code>compute_posterior_quantiles</code> from bayesian_utils.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/irf.jl#L99-L105">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.irf-Union{Tuple{T}, Tuple{VARModel{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.irf-Union{Tuple{T}, Tuple{VARModel{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.irf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">irf(model, horizon; method=:cholesky, ci_type=:none, reps=200, conf_level=0.95, ...)</code></pre><p>Compute IRFs with optional confidence intervals.</p><p>Methods: :cholesky, :sign, :narrative, :long_run. CI types: :none, :bootstrap, :theoretical.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/irf.jl#L11-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.lp_irf-Tuple{AbstractMatrix, Int64, Int64}"><a class="docstring-binding" href="#MacroEconometricModels.lp_irf-Tuple{AbstractMatrix, Int64, Int64}"><code>MacroEconometricModels.lp_irf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lp_irf(Y::AbstractMatrix, shock_var::Int, horizon::Int; kwargs...) -&gt; LPImpulseResponse</code></pre><p>Convenience function: estimate LP and extract IRF in one call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/irf.jl#L155-L159">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.lp_irf-Union{Tuple{LPModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.lp_irf-Union{Tuple{LPModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.lp_irf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lp_irf(model::LPModel{T}; conf_level::Real=0.95) -&gt; LPImpulseResponse{T}</code></pre><p>Extract impulse response function with confidence intervals from LP model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/irf.jl#L137-L141">source</a></section></details></article><h3 id="Forecast-Error-Variance-Decomposition"><a class="docs-heading-anchor" href="#Forecast-Error-Variance-Decomposition">Forecast Error Variance Decomposition</a><a id="Forecast-Error-Variance-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Forecast-Error-Variance-Decomposition" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels._compute_fevd-Union{Tuple{T}, Tuple{Array{T, 3}, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._compute_fevd-Union{Tuple{T}, Tuple{Array{T, 3}, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._compute_fevd</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute FEVD from IRF array: decomposition[i,j,h] = cumulative MSE contribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/fevd.jl#L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.fevd-Tuple{MCMCChains.Chains, Int64, Int64, Int64}"><a class="docstring-binding" href="#MacroEconometricModels.fevd-Tuple{MCMCChains.Chains, Int64, Int64, Int64}"><code>MacroEconometricModels.fevd</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fevd(chain, p, n, horizon; quantiles=[0.16, 0.5, 0.84], ...) -&gt; BayesianFEVD</code></pre><p>Compute Bayesian FEVD from MCMC chain with posterior quantiles.</p><p>Uses <code>process_posterior_samples</code> and <code>compute_posterior_quantiles</code> from bayesian_utils.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/fevd.jl#L48-L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.fevd-Union{Tuple{T}, Tuple{VARModel{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.fevd-Union{Tuple{T}, Tuple{VARModel{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.fevd</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fevd(model, horizon; method=:cholesky, ...) -&gt; FEVD</code></pre><p>Compute FEVD showing proportion of h-step forecast error variance attributable to each shock.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/fevd.jl#L11-L15">source</a></section></details></article><h3 id="Historical-Decomposition"><a class="docs-heading-anchor" href="#Historical-Decomposition">Historical Decomposition</a><a id="Historical-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Historical-Decomposition" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels._compute_hd_contributions-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Array{Matrix{T}, 1}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._compute_hd_contributions-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Array{Matrix{T}, 1}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._compute_hd_contributions</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute historical decomposition contributions from structural shocks and MA coefficients. HD[t, i, j] = Σ<em>{s=0}^{t-1} Θ</em>s[i, j] * ε_j(t-s)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/hd.jl#L102-L105">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._compute_initial_conditions-Union{Tuple{T}, Tuple{Matrix{T}, Array{T, 3}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._compute_initial_conditions-Union{Tuple{T}, Tuple{Matrix{T}, Array{T, 3}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._compute_initial_conditions</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute initial conditions as residual: actual - total shock contributions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/hd.jl#L129-L131">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._compute_structural_ma_coefficients-Union{Tuple{T}, Tuple{VARModel{T}, AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._compute_structural_ma_coefficients-Union{Tuple{T}, Tuple{VARModel{T}, AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._compute_structural_ma_coefficients</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute structural MA coefficients Θ<em>s = Φ</em>s * P for s = 0, ..., horizon-1. Returns Vector{Matrix{T}} of length horizon.</p><p>Uses <code>_compute_ma_coefficients</code> from identification.jl to avoid code duplication.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/hd.jl#L84-L89">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.contribution-Union{Tuple{T}, Tuple{BayesianHistoricalDecomposition{T}, Int64, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.contribution-Union{Tuple{T}, Tuple{BayesianHistoricalDecomposition{T}, Int64, Int64}} where T"><code>MacroEconometricModels.contribution</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">contribution(hd::BayesianHistoricalDecomposition, var, shock; stat=:mean) -&gt; Vector</code></pre><p>Get contribution time series for specific variable and shock (Bayesian).</p><p><strong>Arguments</strong></p><ul><li><code>hd</code>: Bayesian historical decomposition result</li><li><code>var</code>: Variable index (Int) or name (String)</li><li><code>shock</code>: Shock index (Int) or name (String)</li><li><code>stat</code>: <code>:mean</code> or quantile index (Int)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/hd.jl#L452-L462">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.contribution-Union{Tuple{T}, Tuple{HistoricalDecomposition{T}, Int64, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.contribution-Union{Tuple{T}, Tuple{HistoricalDecomposition{T}, Int64, Int64}} where T"><code>MacroEconometricModels.contribution</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">contribution(hd::HistoricalDecomposition, var, shock) -&gt; Vector</code></pre><p>Get contribution time series for specific variable and shock.</p><p><strong>Arguments</strong></p><ul><li><code>hd</code>: Historical decomposition result</li><li><code>var</code>: Variable index (Int) or name (String)</li><li><code>shock</code>: Shock index (Int) or name (String)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">contrib_y1_s1 = contribution(hd, 1, 1)  # Contribution of shock 1 to variable 1
contrib_y1_s1 = contribution(hd, &quot;Var 1&quot;, &quot;Shock 1&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/hd.jl#L422-L437">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.historical_decomposition-Tuple{MCMCChains.Chains, Int64, Int64, Int64}"><a class="docstring-binding" href="#MacroEconometricModels.historical_decomposition-Tuple{MCMCChains.Chains, Int64, Int64, Int64}"><code>MacroEconometricModels.historical_decomposition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">historical_decomposition(chain::Chains, p, n, horizon; data, ...) -&gt; BayesianHistoricalDecomposition</code></pre><p>Compute Bayesian historical decomposition from MCMC chain with posterior quantiles.</p><p><strong>Arguments</strong></p><ul><li><code>chain::Chains</code>: MCMC chain from <code>estimate_bvar</code></li><li><code>p::Int</code>: Number of lags</li><li><code>n::Int</code>: Number of variables</li><li><code>horizon::Int</code>: Maximum horizon for MA coefficients</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>data::AbstractMatrix</code>: Original data matrix (required)</li><li><code>method::Symbol=:cholesky</code>: Identification method</li><li><code>quantiles::Vector{&lt;:Real}=[0.16, 0.5, 0.84]</code>: Posterior quantile levels</li><li><code>check_func=nothing</code>: Sign restriction check function</li><li><code>narrative_check=nothing</code>: Narrative restriction check function</li></ul><p><strong>Returns</strong></p><p><code>BayesianHistoricalDecomposition</code> with posterior quantiles and means.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">chain = estimate_bvar(Y, 2; n_samples=500)
hd = historical_decomposition(chain, 2, 3, 198; data=Y)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/hd.jl#L221-L247">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.historical_decomposition-Union{Tuple{T}, Tuple{VARModel{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.historical_decomposition-Union{Tuple{T}, Tuple{VARModel{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.historical_decomposition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">historical_decomposition(model::VARModel, horizon; method=:cholesky, ...) -&gt; HistoricalDecomposition</code></pre><p>Compute historical decomposition for a VAR model.</p><p>Decomposes observed data into contributions from each structural shock plus initial conditions.</p><p><strong>Arguments</strong></p><ul><li><code>model::VARModel</code>: Estimated VAR model</li><li><code>horizon::Int</code>: Maximum horizon for MA coefficient computation (typically T_eff)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>method::Symbol=:cholesky</code>: Identification method (:cholesky, :sign, :narrative, :long_run)</li><li><code>check_func=nothing</code>: Sign restriction check function (for method=:sign or :narrative)</li><li><code>narrative_check=nothing</code>: Narrative restriction check function (for method=:narrative)</li><li><code>max_draws::Int=1000</code>: Maximum draws for sign/narrative identification</li></ul><p><strong>Returns</strong></p><p><code>HistoricalDecomposition</code> containing:</p><ul><li><code>contributions</code>: Shock contributions (T<em>eff × n</em>vars × n_shocks)</li><li><code>initial_conditions</code>: Initial condition effects (T<em>eff × n</em>vars)</li><li><code>actual</code>: Actual data values</li><li><code>shocks</code>: Structural shocks</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">model = estimate_var(Y, 2)
hd = historical_decomposition(model, size(Y, 1) - 2)
verify_decomposition(hd)  # Check decomposition identity</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/hd.jl#L151-L181">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.historical_decomposition-Union{Tuple{T}, Tuple{VARModel{T}, SVARRestrictions, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.historical_decomposition-Union{Tuple{T}, Tuple{VARModel{T}, SVARRestrictions, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.historical_decomposition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">historical_decomposition(model::VARModel, restrictions::SVARRestrictions, horizon; ...) -&gt; BayesianHistoricalDecomposition</code></pre><p>Compute historical decomposition using Arias et al. (2018) identification with importance weights.</p><p><strong>Arguments</strong></p><ul><li><code>model::VARModel</code>: Estimated VAR model</li><li><code>restrictions::SVARRestrictions</code>: Zero and sign restrictions</li><li><code>horizon::Int</code>: Maximum horizon for MA coefficients</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>n_draws::Int=1000</code>: Number of accepted draws</li><li><code>n_rotations::Int=1000</code>: Maximum rotation attempts per draw</li><li><code>quantiles::Vector{&lt;:Real}=[0.16, 0.5, 0.84]</code>: Quantile levels for weighted quantiles</li></ul><p><strong>Returns</strong></p><p><code>BayesianHistoricalDecomposition</code> with weighted posterior quantiles and means.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">r = SVARRestrictions(3; signs=[sign_restriction(1, 1, :positive)])
hd = historical_decomposition(model, r, 198; n_draws=500)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/hd.jl#L321-L344">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.total_shock_contribution-Union{Tuple{T}, Tuple{HistoricalDecomposition{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.total_shock_contribution-Union{Tuple{T}, Tuple{HistoricalDecomposition{T}, Int64}} where T"><code>MacroEconometricModels.total_shock_contribution</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">total_shock_contribution(hd::AbstractHistoricalDecomposition, var) -&gt; Vector</code></pre><p>Get total contribution from all shocks to a variable over time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/hd.jl#L486-L490">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.verify_decomposition-Union{Tuple{BayesianHistoricalDecomposition{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#MacroEconometricModels.verify_decomposition-Union{Tuple{BayesianHistoricalDecomposition{T}}, Tuple{T}} where T"><code>MacroEconometricModels.verify_decomposition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">verify_decomposition(hd::BayesianHistoricalDecomposition; tol=1e-6) -&gt; Bool</code></pre><p>Verify that mean contributions + mean initial_conditions ≈ actual (approximately, due to averaging).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/hd.jl#L535-L539">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.verify_decomposition-Union{Tuple{HistoricalDecomposition{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#MacroEconometricModels.verify_decomposition-Union{Tuple{HistoricalDecomposition{T}}, Tuple{T}} where T"><code>MacroEconometricModels.verify_decomposition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">verify_decomposition(hd::HistoricalDecomposition; tol=1e-10) -&gt; Bool</code></pre><p>Verify that contributions + initial_conditions ≈ actual.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">hd = historical_decomposition(model, horizon)
@assert verify_decomposition(hd) &quot;Decomposition identity failed&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/hd.jl#L513-L523">source</a></section></details></article><h3 id="Summary-Tables"><a class="docs-heading-anchor" href="#Summary-Tables">Summary Tables</a><a id="Summary-Tables-1"></a><a class="docs-heading-anchor-permalink" href="#Summary-Tables" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels._select_horizons-Tuple{Int64}"><a class="docstring-binding" href="#MacroEconometricModels._select_horizons-Tuple{Int64}"><code>MacroEconometricModels._select_horizons</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Select representative horizons for display.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/summary.jl#L98">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.has_uncertainty-Tuple{AbstractAnalysisResult}"><a class="docstring-binding" href="#MacroEconometricModels.has_uncertainty-Tuple{AbstractAnalysisResult}"><code>MacroEconometricModels.has_uncertainty</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_uncertainty(result::AbstractAnalysisResult) -&gt; Bool</code></pre><p>Check if the result includes uncertainty quantification (confidence intervals or posterior quantiles).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/summary.jl#L30-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.point_estimate-Tuple{AbstractAnalysisResult}"><a class="docstring-binding" href="#MacroEconometricModels.point_estimate-Tuple{AbstractAnalysisResult}"><code>MacroEconometricModels.point_estimate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">point_estimate(result::AbstractAnalysisResult)</code></pre><p>Get the point estimate from an analysis result.</p><p>Returns the main values/estimates (IRF values, FEVD proportions, HD contributions).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/summary.jl#L21-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.print_table-Union{Tuple{T}, Tuple{IO, FEVD{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.print_table-Union{Tuple{T}, Tuple{IO, FEVD{T}, Int64}} where T"><code>MacroEconometricModels.print_table</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">print_table([io], f::FEVD, var; horizons=nothing)</code></pre><p>Print formatted FEVD table.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/summary.jl#L432-L436">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.print_table-Union{Tuple{T}, Tuple{IO, HistoricalDecomposition{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.print_table-Union{Tuple{T}, Tuple{IO, HistoricalDecomposition{T}, Int64}} where T"><code>MacroEconometricModels.print_table</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">print_table([io], hd::HistoricalDecomposition, var; periods=nothing)</code></pre><p>Print formatted HD table.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/summary.jl#L494-L498">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.print_table-Union{Tuple{T}, Tuple{IO, ImpulseResponse{T}, Int64, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.print_table-Union{Tuple{T}, Tuple{IO, ImpulseResponse{T}, Int64, Int64}} where T"><code>MacroEconometricModels.print_table</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">print_table([io], irf::ImpulseResponse, var, shock; horizons=nothing)</code></pre><p>Print formatted IRF table.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/summary.jl#L381-L385">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.summary-Union{Tuple{FEVD{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#MacroEconometricModels.summary-Union{Tuple{FEVD{T}}, Tuple{T}} where T"><code>MacroEconometricModels.summary</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">summary(f::FEVD)
summary(f::BayesianFEVD)</code></pre><p>Print FEVD summary with decomposition at selected horizons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/summary.jl#L182-L187">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.summary-Union{Tuple{HistoricalDecomposition{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#MacroEconometricModels.summary-Union{Tuple{HistoricalDecomposition{T}}, Tuple{T}} where T"><code>MacroEconometricModels.summary</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">summary(hd::HistoricalDecomposition)
summary(hd::BayesianHistoricalDecomposition)</code></pre><p>Print HD summary with contribution statistics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/summary.jl#L196-L201">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.summary-Union{Tuple{ImpulseResponse{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#MacroEconometricModels.summary-Union{Tuple{ImpulseResponse{T}}, Tuple{T}} where T"><code>MacroEconometricModels.summary</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">summary(irf::ImpulseResponse)
summary(irf::BayesianImpulseResponse)</code></pre><p>Print IRF summary with values at selected horizons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/summary.jl#L168-L173">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.summary-Union{Tuple{VARModel{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#MacroEconometricModels.summary-Union{Tuple{VARModel{T}}, Tuple{T}} where T"><code>MacroEconometricModels.summary</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">summary(model::VARModel)</code></pre><p>Print comprehensive VAR model summary including specification, information criteria, residual covariance, and stationarity check.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/summary.jl#L110-L115">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.table-Union{Tuple{T}, Tuple{BayesianFEVD{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.table-Union{Tuple{T}, Tuple{BayesianFEVD{T}, Int64}} where T"><code>MacroEconometricModels.table</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">table(f::BayesianFEVD, var; horizons=nothing, stat=:mean) -&gt; Matrix</code></pre><p>Extract Bayesian FEVD values. stat can be :mean or quantile index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/summary.jl#L304-L308">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.table-Union{Tuple{T}, Tuple{BayesianHistoricalDecomposition{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.table-Union{Tuple{T}, Tuple{BayesianHistoricalDecomposition{T}, Int64}} where T"><code>MacroEconometricModels.table</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">table(hd::BayesianHistoricalDecomposition, var; periods=nothing, stat=:mean) -&gt; Matrix</code></pre><p>Extract Bayesian HD contributions. stat can be :mean or quantile index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/summary.jl#L352-L356">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.table-Union{Tuple{T}, Tuple{BayesianImpulseResponse{T}, Int64, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.table-Union{Tuple{T}, Tuple{BayesianImpulseResponse{T}, Int64, Int64}} where T"><code>MacroEconometricModels.table</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">table(irf::BayesianImpulseResponse, var, shock; horizons=nothing) -&gt; Matrix</code></pre><p>Extract Bayesian IRF values. Returns [Horizon, Mean, Q1, Q2, ...].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/summary.jl#L250-L254">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.table-Union{Tuple{T}, Tuple{FEVD{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.table-Union{Tuple{T}, Tuple{FEVD{T}, Int64}} where T"><code>MacroEconometricModels.table</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">table(f::FEVD, var; horizons=nothing) -&gt; Matrix</code></pre><p>Extract FEVD proportions for a variable. Returns [Horizon, Shock1, Shock2, ...].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/summary.jl#L282-L286">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.table-Union{Tuple{T}, Tuple{HistoricalDecomposition{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.table-Union{Tuple{T}, Tuple{HistoricalDecomposition{T}, Int64}} where T"><code>MacroEconometricModels.table</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">table(hd::HistoricalDecomposition, var; periods=nothing) -&gt; Matrix</code></pre><p>Extract HD contributions for a variable. Returns [Period, Actual, Shock1, ..., ShockN, Initial].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/summary.jl#L327-L332">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.table-Union{Tuple{T}, Tuple{ImpulseResponse{T}, Int64, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.table-Union{Tuple{T}, Tuple{ImpulseResponse{T}, Int64, Int64}} where T"><code>MacroEconometricModels.table</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">table(irf::ImpulseResponse, var, shock; horizons=nothing) -&gt; Matrix</code></pre><p>Extract IRF values for a variable-shock pair. Returns matrix with columns: [Horizon, IRF] or [Horizon, IRF, CI<em>lo, CI</em>hi].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/summary.jl#L214-L219">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.uncertainty_bounds-Tuple{AbstractAnalysisResult}"><a class="docstring-binding" href="#MacroEconometricModels.uncertainty_bounds-Tuple{AbstractAnalysisResult}"><code>MacroEconometricModels.uncertainty_bounds</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">uncertainty_bounds(result::AbstractAnalysisResult) -&gt; Union{Nothing, Tuple}</code></pre><p>Get uncertainty bounds (lower, upper) if available, otherwise nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/summary.jl#L37-L41">source</a></section></details></article><hr/><h2 id="Local-Projections"><a class="docs-heading-anchor" href="#Local-Projections">Local Projections</a><a id="Local-Projections-1"></a><a class="docs-heading-anchor-permalink" href="#Local-Projections" title="Permalink"></a></h2><h3 id="Core-LP-Estimation-and-Covariance"><a class="docs-heading-anchor" href="#Core-LP-Estimation-and-Covariance">Core LP Estimation and Covariance</a><a id="Core-LP-Estimation-and-Covariance-1"></a><a class="docs-heading-anchor-permalink" href="#Core-LP-Estimation-and-Covariance" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.build_control_columns!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, Vararg{Int64, 4}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.build_control_columns!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, Vararg{Int64, 4}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.build_control_columns!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">build_control_columns!(X_h::AbstractMatrix{T}, Y::AbstractMatrix{T},
                       t_start::Int, t_end::Int, lags::Int, start_col::Int) where T</code></pre><p>Fill control (lagged Y) columns into regressor matrix X_h. Returns the next available column index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_core.jl#L72-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.build_response_matrix-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64, Int64, Vector{Int64}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.build_response_matrix-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64, Int64, Vector{Int64}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.build_response_matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">build_response_matrix(Y::AbstractMatrix{T}, h::Int, t_start::Int, t_end::Int,
                      response_vars::Vector{Int}) where T</code></pre><p>Build response matrix Y_h at horizon h.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_core.jl#L53-L58">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.compare_var_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.compare_var_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.compare_var_lp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compare_var_lp(Y::AbstractMatrix{T}, horizon::Int; lags::Int=4) where T</code></pre><p>Compare VAR-based and LP-based impulse responses.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_core.jl#L296-L300">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.compute_block_robust_vcov-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractCovarianceEstimator}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.compute_block_robust_vcov-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractCovarianceEstimator}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.compute_block_robust_vcov</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_block_robust_vcov(X::AbstractMatrix{T}, U::AbstractMatrix{T},
                          cov_estimator::AbstractCovarianceEstimator) where T</code></pre><p>Compute block-diagonal robust covariance for multi-equation system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_core.jl#L95-L100">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.compute_horizon_bounds-Tuple{Int64, Int64, Int64}"><a class="docstring-binding" href="#MacroEconometricModels.compute_horizon_bounds-Tuple{Int64, Int64, Int64}"><code>MacroEconometricModels.compute_horizon_bounds</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_horizon_bounds(T_obs::Int, h::Int, lags::Int) -&gt; (t_start, t_end)</code></pre><p>Compute valid observation bounds for horizon h.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_core.jl#L39-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.construct_lp_matrices-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.construct_lp_matrices-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.construct_lp_matrices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">construct_lp_matrices(Y::AbstractMatrix{T}, shock_var::Int, h::Int, lags::Int;
                      response_vars::Vector{Int}=collect(1:size(Y,2))) where T</code></pre><p>Construct regressor and response matrices for LP regression at horizon h.</p><p>Returns: (Y<em>h, X</em>h, valid_idx)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_core.jl#L156-L163">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.create_cov_estimator-Union{Tuple{T}, Tuple{Symbol, Type{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.create_cov_estimator-Union{Tuple{T}, Tuple{Symbol, Type{T}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.create_cov_estimator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_cov_estimator(cov_type::Symbol, ::Type{T}; bandwidth::Int=0) where T</code></pre><p>Create covariance estimator from symbol specification. Eliminates repeated if/else patterns across LP variants.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_core.jl#L21-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_lp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_lp(Y::AbstractMatrix{T}, shock_var::Int, horizon::Int;
            lags::Int=4, response_vars::Vector{Int}=collect(1:size(Y,2)),
            cov_type::Symbol=:newey_west, bandwidth::Int=0,
            conf_level::Real=0.95) -&gt; LPModel{T}</code></pre><p>Estimate Local Projection impulse response functions (Jordà 2005).</p><p>The LP regression for horizon h:     y<em>{t+h} = α</em>h + β<em>h * shock</em>t + Γ<em>h * controls</em>t + ε_{t+h}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_core.jl#L191-L201">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_lp_cholesky-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_lp_cholesky-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_lp_cholesky</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_lp_cholesky(Y::AbstractMatrix{T}, horizon::Int;
                     lags::Int=4, cov_type::Symbol=:newey_west, kwargs...) -&gt; Vector{LPModel{T}}</code></pre><p>Estimate LP with Cholesky-orthogonalized shocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_core.jl#L263-L268">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_lp_multi-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Vector{Int64}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_lp_multi-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Vector{Int64}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_lp_multi</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_lp_multi(Y::AbstractMatrix{T}, shock_vars::Vector{Int}, horizon::Int;
                  kwargs...) -&gt; Vector{LPModel{T}}</code></pre><p>Estimate LP for multiple shock variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_core.jl#L248-L253">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.extract_shock_irf-Union{Tuple{T}, Tuple{Array{Matrix{T}, 1}, Array{Matrix{T}, 1}, Vector{Int64}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.extract_shock_irf-Union{Tuple{T}, Tuple{Array{Matrix{T}, 1}, Array{Matrix{T}, 1}, Vector{Int64}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.extract_shock_irf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extract_shock_irf(B::Vector{Matrix{T}}, vcov::Vector{Matrix{T}},
                  response_vars::Vector{Int}, shock_coef_idx::Int;
                  conf_level::Real=0.95) where T</code></pre><p>Generic IRF extraction from coefficient and covariance vectors. Works for LPModel, LPIVModel, PropensityLPModel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_core.jl#L114-L121">source</a></section></details></article><h3 id="LP-Extensions-(IV,-Smooth,-State-Dependent,-Propensity)"><a class="docs-heading-anchor" href="#LP-Extensions-(IV,-Smooth,-State-Dependent,-Propensity)">LP Extensions (IV, Smooth, State-Dependent, Propensity)</a><a id="LP-Extensions-(IV,-Smooth,-State-Dependent,-Propensity)-1"></a><a class="docs-heading-anchor-permalink" href="#LP-Extensions-(IV,-Smooth,-State-Dependent,-Propensity)" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.bspline_basis-Tuple{AbstractVector{Int64}, Int64, Int64}"><a class="docstring-binding" href="#MacroEconometricModels.bspline_basis-Tuple{AbstractVector{Int64}, Int64, Int64}"><code>MacroEconometricModels.bspline_basis</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bspline_basis(horizons::AbstractVector{Int}, degree::Int, n_interior_knots::Int;
              T::Type{&lt;:AbstractFloat}=Float64) -&gt; BSplineBasis{T}</code></pre><p>Construct B-spline basis matrix for given horizons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_extensions.jl#L238-L243">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.bspline_basis_value-Union{Tuple{T}, Tuple{T, Int64, Int64, Vector{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.bspline_basis_value-Union{Tuple{T}, Tuple{T, Int64, Int64, Vector{T}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.bspline_basis_value</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bspline_basis_value(x::T, i::Int, degree::Int, knots::Vector{T}) where T</code></pre><p>Evaluate B-spline basis function using Cox-de Boor recursion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_extensions.jl#L214-L218">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.compare_smooth_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.compare_smooth_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.compare_smooth_lp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compare_smooth_lp(Y::AbstractMatrix{T}, shock_var::Int, horizon::Int;
                  lambda::T=T(1.0), kwargs...) -&gt; NamedTuple</code></pre><p>Compare standard LP and smooth LP.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_extensions.jl#L418-L423">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.cross_validate_lambda-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.cross_validate_lambda-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.cross_validate_lambda</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cross_validate_lambda(Y::AbstractMatrix{T}, shock_var::Int, horizon::Int;
                      lambda_grid::Vector{T}=T.(10.0 .^ (-4:0.5:2)),
                      k_folds::Int=5, kwargs...) -&gt; T</code></pre><p>Select optimal λ via k-fold cross-validation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_extensions.jl#L355-L361">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.doubly_robust_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{Bool}, AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.doubly_robust_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{Bool}, AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.doubly_robust_lp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">doubly_robust_lp(Y::AbstractMatrix{T}, treatment::AbstractVector{Bool},
                 covariates::AbstractMatrix{T}, horizon::Int; ...) -&gt; PropensityLPModel{T}</code></pre><p>Doubly robust LP estimator combining IPW and regression adjustment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_extensions.jl#L901-L906">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_lp_iv-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_lp_iv-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_lp_iv</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_lp_iv(Y::AbstractMatrix{T}, shock_var::Int, instruments::AbstractMatrix{T},
               horizon::Int; lags::Int=4, response_vars::Vector{Int}=collect(1:size(Y,2)),
               cov_type::Symbol=:newey_west, bandwidth::Int=0) -&gt; LPIVModel{T}</code></pre><p>Estimate LP with Instrumental Variables (Stock &amp; Watson 2018) using 2SLS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_extensions.jl#L76-L82">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_propensity_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{Bool}, AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_propensity_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{Bool}, AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_propensity_lp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_propensity_lp(Y::AbstractMatrix{T}, treatment::AbstractVector{Bool},
                       covariates::AbstractMatrix{T}, horizon::Int; ...) -&gt; PropensityLPModel{T}</code></pre><p>Estimate LP with Inverse Propensity Weighting (Angrist et al. 2018).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_extensions.jl#L807-L812">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_propensity_score-Union{Tuple{T}, Tuple{AbstractVector{Bool}, AbstractMatrix{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_propensity_score-Union{Tuple{T}, Tuple{AbstractVector{Bool}, AbstractMatrix{T}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_propensity_score</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_propensity_score(treatment::AbstractVector{Bool}, X::AbstractMatrix{T};
                          method::Symbol=:logit) -&gt; Vector{T}</code></pre><p>Estimate propensity scores P(D=1|X) via logit or probit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_extensions.jl#L740-L745">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_smooth_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_smooth_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_smooth_lp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_smooth_lp(Y::AbstractMatrix{T}, shock_var::Int, horizon::Int;
                   degree::Int=3, n_knots::Int=4, lambda::T=T(0.0),
                   lags::Int=4, response_vars::Vector{Int}=collect(1:size(Y,2)),
                   cov_type::Symbol=:newey_west, bandwidth::Int=0) -&gt; SmoothLPModel{T}</code></pre><p>Estimate Smooth LP with B-spline parameterization (Barnichon &amp; Brownlees 2019).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_extensions.jl#L288-L295">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_state_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, AbstractVector{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_state_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, AbstractVector{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_state_lp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_state_lp(Y::AbstractMatrix{T}, shock_var::Int, state_var::AbstractVector{T},
                  horizon::Int; gamma::Union{T,Symbol}=:estimate, ...) -&gt; StateLPModel{T}</code></pre><p>Estimate state-dependent LP (Auerbach &amp; Gorodnichenko 2013).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_extensions.jl#L528-L533">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_transition_params-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_transition_params-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_transition_params</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_transition_params(state_var::AbstractVector{T}, Y::AbstractMatrix{T},
                           shock_var::Int; method::Symbol=:nlls, ...) -&gt; NamedTuple</code></pre><p>Estimate smooth transition parameters (γ, c).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_extensions.jl#L462-L467">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.exponential_transition-Union{Tuple{T}, Tuple{AbstractVector{T}, T, T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.exponential_transition-Union{Tuple{T}, Tuple{AbstractVector{T}, T, T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.exponential_transition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">exponential_transition(z::AbstractVector{T}, gamma::T, c::T) -&gt; Vector{T}</code></pre><p>Exponential (symmetric) transition: F(z) = 1 - exp(-γ(z - c)²)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_extensions.jl#L447-L451">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.first_stage_regression-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}, AbstractMatrix{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.first_stage_regression-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}, AbstractMatrix{T}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.first_stage_regression</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">first_stage_regression(endog::AbstractVector{T}, instruments::AbstractMatrix{T},
                       controls::AbstractMatrix{T}) -&gt; NamedTuple</code></pre><p>First-stage regression for 2SLS with F-statistic for instrument relevance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_extensions.jl#L19-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.indicator_transition-Union{Tuple{T}, Tuple{AbstractVector{T}, T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.indicator_transition-Union{Tuple{T}, Tuple{AbstractVector{T}, T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.indicator_transition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">indicator_transition(z::AbstractVector{T}, c::T) -&gt; Vector{T}</code></pre><p>Sharp indicator transition: F(z) = 1 if z ≥ c, else 0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_extensions.jl#L455-L459">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.inverse_propensity_weights-Union{Tuple{T}, Tuple{AbstractVector{Bool}, AbstractVector{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.inverse_propensity_weights-Union{Tuple{T}, Tuple{AbstractVector{Bool}, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.inverse_propensity_weights</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inverse_propensity_weights(treatment::AbstractVector{Bool}, propensity::AbstractVector{T};
                           trimming::Tuple{T,T}=(T(0.01), T(0.99)), normalize::Bool=true) -&gt; Vector{T}</code></pre><p>Compute IPW weights with optional trimming.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_extensions.jl#L784-L789">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.logistic_transition-Union{Tuple{T}, Tuple{AbstractVector{T}, T, T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.logistic_transition-Union{Tuple{T}, Tuple{AbstractVector{T}, T, T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.logistic_transition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">logistic_transition(z::AbstractVector{T}, gamma::T, c::T) -&gt; Vector{T}</code></pre><p>Logistic transition function: F(z) = exp(-γ(z - c)) / (1 + exp(-γ(z - c)))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_extensions.jl#L436-L440">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.lp_iv_irf-Union{Tuple{LPIVModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.lp_iv_irf-Union{Tuple{LPIVModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.lp_iv_irf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lp_iv_irf(model::LPIVModel{T}; conf_level::Real=0.95) -&gt; LPImpulseResponse{T}</code></pre><p>Extract IRF from LP-IV model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_extensions.jl#L163-L167">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.propensity_diagnostics-Union{Tuple{PropensityLPModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.propensity_diagnostics-Union{Tuple{PropensityLPModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.propensity_diagnostics</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">propensity_diagnostics(model::PropensityLPModel{T}) -&gt; NamedTuple</code></pre><p>Propensity score diagnostics (overlap, balance).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_extensions.jl#L1020-L1024">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.propensity_irf-Union{Tuple{PropensityLPModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.propensity_irf-Union{Tuple{PropensityLPModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.propensity_irf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">propensity_irf(model::PropensityLPModel{T}; conf_level::Real=0.95) -&gt; LPImpulseResponse{T}</code></pre><p>Extract treatment effect (ATE) IRF from PropensityLPModel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_extensions.jl#L1003-L1007">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.roughness_penalty_matrix-Union{Tuple{BSplineBasis{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.roughness_penalty_matrix-Union{Tuple{BSplineBasis{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.roughness_penalty_matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">roughness_penalty_matrix(basis::BSplineBasis{T}) -&gt; Matrix{T}</code></pre><p>Compute roughness penalty matrix R for B-splines (second derivative penalty).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_extensions.jl#L265-L269">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.sargan_test-Union{Tuple{T}, Tuple{LPIVModel{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.sargan_test-Union{Tuple{T}, Tuple{LPIVModel{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.sargan_test</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sargan_test(model::LPIVModel{T}, h::Int) -&gt; NamedTuple</code></pre><p>Sargan-Hansen J-test for overidentification at horizon h.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_extensions.jl#L181-L185">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.smooth_lp_irf-Union{Tuple{SmoothLPModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.smooth_lp_irf-Union{Tuple{SmoothLPModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.smooth_lp_irf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">smooth_lp_irf(model::SmoothLPModel{T}; conf_level::Real=0.95) -&gt; LPImpulseResponse{T}</code></pre><p>Extract smoothed IRF from SmoothLPModel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_extensions.jl#L401-L405">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.state_irf-Union{Tuple{StateLPModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.state_irf-Union{Tuple{StateLPModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.state_irf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">state_irf(model::StateLPModel{T}; regime::Symbol=:both, conf_level::Real=0.95) -&gt; NamedTuple</code></pre><p>Extract state-dependent IRFs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_extensions.jl#L645-L649">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.test_regime_difference-Union{Tuple{StateLPModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.test_regime_difference-Union{Tuple{StateLPModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.test_regime_difference</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">test_regime_difference(model::StateLPModel{T}; h::Union{Int,Nothing}=nothing) -&gt; NamedTuple</code></pre><p>Test whether IRFs differ across regimes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_extensions.jl#L693-L697">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.tsls_regression-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, AbstractVector{T}, AbstractMatrix{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.tsls_regression-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, AbstractVector{T}, AbstractMatrix{T}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.tsls_regression</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tsls_regression(Y::AbstractMatrix{T}, endog::AbstractVector{T},
                endog_fitted::AbstractVector{T}, controls::AbstractMatrix{T};
                cov_estimator::AbstractCovarianceEstimator=NeweyWestEstimator()) -&gt; NamedTuple</code></pre><p>Second-stage regression using fitted values from first stage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_extensions.jl#L49-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.weak_instrument_test-Union{Tuple{LPIVModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.weak_instrument_test-Union{Tuple{LPIVModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.weak_instrument_test</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">weak_instrument_test(model::LPIVModel{T}; threshold::T=T(10.0)) -&gt; NamedTuple</code></pre><p>Test for weak instruments using Stock-Yogo rule of thumb (F &gt; 10).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/lp_extensions.jl#L147-L151">source</a></section></details></article><hr/><h2 id="Factor-Models"><a class="docs-heading-anchor" href="#Factor-Models">Factor Models</a><a id="Factor-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Factor-Models" title="Permalink"></a></h2><h3 id="Static-Factor-Model"><a class="docs-heading-anchor" href="#Static-Factor-Model">Static Factor Model</a><a id="Static-Factor-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Static-Factor-Model" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_factors-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_factors-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_factors</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_factors(X, r; standardize=true) -&gt; FactorModel</code></pre><p>Estimate static factor model X<em>t = Λ F</em>t + e_t via Principal Component Analysis.</p><p><strong>Arguments</strong></p><ul><li><code>X</code>: Data matrix (T × N), observations × variables</li><li><code>r</code>: Number of factors to extract</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>standardize::Bool=true</code>: Standardize data before estimation</li></ul><p><strong>Returns</strong></p><p><code>FactorModel</code> containing factors, loadings, eigenvalues, and explained variance.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">X = randn(200, 50)  # 200 observations, 50 variables
fm = estimate_factors(X, 3)  # Extract 3 factors
r2(fm)  # R² for each variable</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/staticfactor.jl#L17-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{FactorModel{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{FactorModel{T}, Int64}} where T"><code>MacroEconometricModels.forecast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">forecast(model::FactorModel, h; p=1, ci_method=:none, conf_level=0.95, n_boot=1000)</code></pre><p>Forecast factors and observables h steps ahead from a static factor model.</p><p>Internally fits a VAR(p) on the extracted factors, then uses the VAR dynamics to produce multi-step forecasts and (optionally) confidence intervals.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: Estimated static factor model</li><li><code>h</code>: Forecast horizon</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>p::Int=1</code>: VAR lag order for factor dynamics</li><li><code>ci_method::Symbol=:none</code>: CI method — <code>:none</code>, <code>:theoretical</code>, or <code>:bootstrap</code></li><li><code>conf_level::Real=0.95</code>: Confidence level for intervals</li><li><code>n_boot::Int=1000</code>: Number of bootstrap replications (if <code>ci_method=:bootstrap</code>)</li></ul><p><strong>Returns</strong></p><p><code>FactorForecast</code> with factor and observable forecasts (and CIs if requested).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/staticfactor.jl#L160-L180">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.ic_criteria-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.ic_criteria-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.ic_criteria</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ic_criteria(X, max_factors; standardize=true)</code></pre><p>Compute Bai-Ng (2002) information criteria IC1, IC2, IC3 for selecting the number of factors.</p><p><strong>Arguments</strong></p><ul><li><code>X</code>: Data matrix (T × N)</li><li><code>max_factors</code>: Maximum number of factors to consider</li></ul><p><strong>Returns</strong></p><p>Named tuple with IC values and optimal factor counts:</p><ul><li><code>IC1</code>, <code>IC2</code>, <code>IC3</code>: Information criteria vectors</li><li><code>r_IC1</code>, <code>r_IC2</code>, <code>r_IC3</code>: Optimal factor counts</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">result = ic_criteria(X, 10)
println(&quot;Optimal factors: IC1=&quot;, result.r_IC1, &quot;, IC2=&quot;, result.r_IC2, &quot;, IC3=&quot;, result.r_IC3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/staticfactor.jl#L97-L116">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.scree_plot_data-Tuple{FactorModel}"><a class="docstring-binding" href="#MacroEconometricModels.scree_plot_data-Tuple{FactorModel}"><code>MacroEconometricModels.scree_plot_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">scree_plot_data(m::FactorModel)</code></pre><p>Return data for scree plot: factor indices, explained variance, cumulative variance.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">data = scree_plot_data(fm)
# Plot: data.factors vs data.explained_variance</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/staticfactor.jl#L142-L152">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.dof-Tuple{FactorModel}"><a class="docstring-binding" href="#StatsAPI.dof-Tuple{FactorModel}"><code>StatsAPI.dof</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Degrees of freedom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/staticfactor.jl#L90">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.nobs-Tuple{FactorModel}"><a class="docstring-binding" href="#StatsAPI.nobs-Tuple{FactorModel}"><code>StatsAPI.nobs</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Number of observations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/staticfactor.jl#L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.predict-Tuple{FactorModel}"><a class="docstring-binding" href="#StatsAPI.predict-Tuple{FactorModel}"><code>StatsAPI.predict</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Predicted values: F * Λ&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/staticfactor.jl#L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.r2-Union{Tuple{FactorModel{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#StatsAPI.r2-Union{Tuple{FactorModel{T}}, Tuple{T}} where T"><code>StatsAPI.r2</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>R² for each variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/staticfactor.jl#L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.residuals-Union{Tuple{FactorModel{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#StatsAPI.residuals-Union{Tuple{FactorModel{T}}, Tuple{T}} where T"><code>StatsAPI.residuals</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Residuals: X - predicted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/staticfactor.jl#L73">source</a></section></details></article><h3 id="Dynamic-Factor-Model"><a class="docs-heading-anchor" href="#Dynamic-Factor-Model">Dynamic Factor Model</a><a id="Dynamic-Factor-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Dynamic-Factor-Model" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels._compute_dfm_loglikelihood-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, Bool}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._compute_dfm_loglikelihood-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, Bool}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._compute_dfm_loglikelihood</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute Gaussian log-likelihood given factors and parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/dynamicfactor.jl#L211">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._em_mstep-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractArray{T, 3}, AbstractArray{T, 3}, Int64, Int64, Bool}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._em_mstep-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractArray{T, 3}, AbstractArray{T, 3}, Int64, Int64, Bool}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._em_mstep</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>M-step: update loadings, VAR coefficients, and covariances.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/dynamicfactor.jl#L155">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._estimate_dfm_em-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._estimate_dfm_em-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._estimate_dfm_em</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>EM algorithm for maximum likelihood estimation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/dynamicfactor.jl#L100">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._estimate_dfm_twostep-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._estimate_dfm_twostep-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._estimate_dfm_twostep</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Two-step estimation: PCA for factors, then VAR on extracted factors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/dynamicfactor.jl#L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.companion_matrix_factors-Union{Tuple{DynamicFactorModel{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#MacroEconometricModels.companion_matrix_factors-Union{Tuple{DynamicFactorModel{T}}, Tuple{T}} where T"><code>MacroEconometricModels.companion_matrix_factors</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">companion_matrix_factors(model::DynamicFactorModel)</code></pre><p>Construct companion matrix for factor VAR dynamics.</p><p>The companion form converts VAR(p) to VAR(1): [F<em>t; F</em>{t-1}; ...] = C [F<em>{t-1}; F</em>{t-2}; ...] + [η_t; 0; ...]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/dynamicfactor.jl#L423-L430">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_dynamic_factors-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_dynamic_factors-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_dynamic_factors</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_dynamic_factors(X, r, p; method=:twostep, standardize=true, max_iter=100, tol=1e-6)</code></pre><p>Estimate dynamic factor model with VAR(p) factor dynamics.</p><p><strong>Arguments</strong></p><ul><li><code>X</code>: Data matrix (T × N)</li><li><code>r</code>: Number of factors</li><li><code>p</code>: Number of lags in factor VAR</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>method::Symbol=:twostep</code>: Estimation method (:twostep or :em)</li><li><code>standardize::Bool=true</code>: Standardize data</li><li><code>max_iter::Int=100</code>: Maximum EM iterations (if method=:em)</li><li><code>tol::Float64=1e-6</code>: Convergence tolerance (if method=:em)</li><li><code>diagonal_idio::Bool=true</code>: Assume diagonal idiosyncratic covariance</li></ul><p><strong>Returns</strong></p><p><code>DynamicFactorModel</code> with factors, loadings, VAR coefficients, and diagnostics.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">dfm = estimate_dynamic_factors(X, 3, 2)  # 3 factors, VAR(2)
forecast(dfm, 12)  # 12-step ahead forecast</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/dynamicfactor.jl#L24-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{DynamicFactorModel{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{DynamicFactorModel{T}, Int64}} where T"><code>MacroEconometricModels.forecast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">forecast(model::DynamicFactorModel, h; ci_method=:none, conf_level=0.95, n_boot=1000, ci=false, ci_level=0.95)</code></pre><p>Forecast factors and observables h steps ahead.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: Estimated dynamic factor model</li><li><code>h</code>: Forecast horizon</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ci_method::Symbol=:none</code>: CI method — <code>:none</code>, <code>:theoretical</code>, <code>:bootstrap</code>, or <code>:simulation</code></li><li><code>conf_level::Real=0.95</code>: Confidence level for intervals</li><li><code>n_boot::Int=1000</code>: Bootstrap replications (for <code>:bootstrap</code> and <code>:simulation</code>)</li><li><code>ci::Bool=false</code>: Legacy keyword — <code>ci=true</code> maps to <code>ci_method=:simulation</code></li><li><code>ci_level::Real=0.95</code>: Legacy keyword — maps to <code>conf_level</code></li></ul><p><strong>Returns</strong></p><p><code>FactorForecast</code> with factor and observable forecasts (and CIs if requested).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">fc = forecast(dfm, 12; ci_method=:theoretical)
fc.observables       # h×N matrix of forecasts
fc.observables_lower # h×N lower CI bounds</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/dynamicfactor.jl#L259-L284">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.ic_criteria_dynamic-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.ic_criteria_dynamic-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.ic_criteria_dynamic</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ic_criteria_dynamic(X, max_r, max_p; standardize=true, method=:twostep)</code></pre><p>Select (r, p) via AIC/BIC grid search over factor and lag combinations.</p><p><strong>Returns</strong></p><p>Named tuple with AIC/BIC matrices and optimal (r, p) combinations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/dynamicfactor.jl#L391-L398">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.is_stationary-Tuple{DynamicFactorModel}"><a class="docstring-binding" href="#MacroEconometricModels.is_stationary-Tuple{DynamicFactorModel}"><code>MacroEconometricModels.is_stationary</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_stationary(model::DynamicFactorModel) -&gt; Bool</code></pre><p>Check if factor dynamics are stationary (max |eigenvalue| &lt; 1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/dynamicfactor.jl#L441-L445">source</a></section></details></article><h3 id="Generalized-Dynamic-Factor-Model"><a class="docs-heading-anchor" href="#Generalized-Dynamic-Factor-Model">Generalized Dynamic Factor Model</a><a id="Generalized-Dynamic-Factor-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Generalized-Dynamic-Factor-Model" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels._compute_common_spectral_density-Union{Tuple{T}, Tuple{Array{Complex{T}, 3}, AbstractMatrix}} where T"><a class="docstring-binding" href="#MacroEconometricModels._compute_common_spectral_density-Union{Tuple{T}, Tuple{Array{Complex{T}, 3}, AbstractMatrix}} where T"><code>MacroEconometricModels._compute_common_spectral_density</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute spectral density of common component from loadings and eigenvalues.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/generalizedfactor.jl#L155">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._compute_kernel_weights-Tuple{Int64, Symbol}"><a class="docstring-binding" href="#MacroEconometricModels._compute_kernel_weights-Tuple{Int64, Symbol}"><code>MacroEconometricModels._compute_kernel_weights</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute kernel weights for spectral smoothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/generalizedfactor.jl#L120">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._compute_variance_explained-Union{Tuple{T}, Tuple{Matrix{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels._compute_variance_explained-Union{Tuple{T}, Tuple{Matrix{T}, Int64}} where T"><code>MacroEconometricModels._compute_variance_explained</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute variance explained by first q factors (averaged across frequencies).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/generalizedfactor.jl#L203">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._estimate_spectral_density-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Symbol}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._estimate_spectral_density-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Symbol}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._estimate_spectral_density</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Estimate spectral density matrix with kernel smoothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/generalizedfactor.jl#L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._extract_time_domain_factors-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Array{Complex{T}, 3}, Vector{T}}} where T"><a class="docstring-binding" href="#MacroEconometricModels._extract_time_domain_factors-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Array{Complex{T}, 3}, Vector{T}}} where T"><code>MacroEconometricModels._extract_time_domain_factors</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Extract time-domain factors via frequency-domain projection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/generalizedfactor.jl#L182">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._forecast_factors_ar-Union{Tuple{T}, Tuple{Matrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._forecast_factors_ar-Union{Tuple{T}, Tuple{Matrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._forecast_factors_ar</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>AR(1) forecast for each factor series.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/generalizedfactor.jl#L411">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._reconstruct_time_domain-Union{Tuple{T}, Tuple{Array{Complex{T}, 3}, AbstractMatrix{T}}} where T"><a class="docstring-binding" href="#MacroEconometricModels._reconstruct_time_domain-Union{Tuple{T}, Tuple{Array{Complex{T}, 3}, AbstractMatrix{T}}} where T"><code>MacroEconometricModels._reconstruct_time_domain</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Reconstruct common component in time domain via inverse FFT.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/generalizedfactor.jl#L166">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._select_bandwidth-Tuple{Int64}"><a class="docstring-binding" href="#MacroEconometricModels._select_bandwidth-Tuple{Int64}"><code>MacroEconometricModels._select_bandwidth</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Automatic bandwidth selection: T^(1/3).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/generalizedfactor.jl#L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._spectral_eigendecomposition-Union{Tuple{Array{Complex{T}, 3}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._spectral_eigendecomposition-Union{Tuple{Array{Complex{T}, 3}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._spectral_eigendecomposition</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Eigendecomposition of spectral density at each frequency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/generalizedfactor.jl#L137">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.common_variance_share-Union{Tuple{GeneralizedDynamicFactorModel{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#MacroEconometricModels.common_variance_share-Union{Tuple{GeneralizedDynamicFactorModel{T}}, Tuple{T}} where T"><code>MacroEconometricModels.common_variance_share</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">common_variance_share(model::GeneralizedDynamicFactorModel) -&gt; Vector</code></pre><p>Fraction of each variable&#39;s variance explained by the common component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/generalizedfactor.jl#L433-L437">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_gdfm-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_gdfm-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_gdfm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_gdfm(X, q; standardize=true, bandwidth=0, kernel=:bartlett, r=0) -&gt; GeneralizedDynamicFactorModel</code></pre><p>Estimate Generalized Dynamic Factor Model using spectral methods.</p><p><strong>Arguments</strong></p><ul><li><code>X</code>: Data matrix (T × N)</li><li><code>q</code>: Number of dynamic factors</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>standardize::Bool=true</code>: Standardize data</li><li><code>bandwidth::Int=0</code>: Kernel bandwidth (0 = automatic selection)</li><li><code>kernel::Symbol=:bartlett</code>: Kernel for spectral smoothing (:bartlett, :parzen, :tukey)</li><li><code>r::Int=0</code>: Number of static factors (0 = same as q)</li></ul><p><strong>Returns</strong></p><p><code>GeneralizedDynamicFactorModel</code> with common/idiosyncratic components and spectral loadings.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">gdfm = estimate_gdfm(X, 3)
common_variance_share(gdfm)  # Fraction of variance explained by common component</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/generalizedfactor.jl#L23-L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{GeneralizedDynamicFactorModel{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{GeneralizedDynamicFactorModel{T}, Int64}} where T"><code>MacroEconometricModels.forecast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">forecast(model::GeneralizedDynamicFactorModel, h; method=:ar, ci_method=:none, conf_level=0.95, n_boot=1000)</code></pre><p>Forecast h steps ahead using AR extrapolation of factors.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: Estimated GDFM</li><li><code>h</code>: Forecast horizon</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>method::Symbol=:ar</code>: Forecasting method (currently only <code>:ar</code> supported)</li><li><code>ci_method::Symbol=:none</code>: CI method — <code>:none</code>, <code>:theoretical</code>, or <code>:bootstrap</code></li><li><code>conf_level::Real=0.95</code>: Confidence level for intervals</li><li><code>n_boot::Int=1000</code>: Bootstrap replications (for <code>:bootstrap</code>)</li></ul><p><strong>Returns</strong></p><p><code>FactorForecast</code> with factor and observable forecasts (and CIs if requested).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/generalizedfactor.jl#L275-L292">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.ic_criteria_gdfm-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.ic_criteria_gdfm-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.ic_criteria_gdfm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ic_criteria_gdfm(X, max_q; standardize=true, bandwidth=0, kernel=:bartlett)</code></pre><p>Information criteria for selecting number of dynamic factors.</p><p>Uses eigenvalue ratio test and cumulative variance threshold.</p><p><strong>Returns</strong></p><p>Named tuple with:</p><ul><li><code>eigenvalue_ratios</code>: Ratios of consecutive eigenvalues</li><li><code>cumulative_variance</code>: Cumulative variance explained</li><li><code>q_ratio</code>: Optimal q from eigenvalue ratio</li><li><code>q_variance</code>: Optimal q from 90% variance threshold</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/generalizedfactor.jl#L235-L248">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.spectral_eigenvalue_plot_data-Tuple{GeneralizedDynamicFactorModel}"><a class="docstring-binding" href="#MacroEconometricModels.spectral_eigenvalue_plot_data-Tuple{GeneralizedDynamicFactorModel}"><code>MacroEconometricModels.spectral_eigenvalue_plot_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">spectral_eigenvalue_plot_data(model::GeneralizedDynamicFactorModel)</code></pre><p>Return data for plotting eigenvalues across frequencies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/generalizedfactor.jl#L443-L447">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.dof-Tuple{GeneralizedDynamicFactorModel}"><a class="docstring-binding" href="#StatsAPI.dof-Tuple{GeneralizedDynamicFactorModel}"><code>StatsAPI.dof</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Degrees of freedom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/generalizedfactor.jl#L222">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.nobs-Tuple{GeneralizedDynamicFactorModel}"><a class="docstring-binding" href="#StatsAPI.nobs-Tuple{GeneralizedDynamicFactorModel}"><code>StatsAPI.nobs</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Number of observations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/generalizedfactor.jl#L219">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.predict-Tuple{GeneralizedDynamicFactorModel}"><a class="docstring-binding" href="#StatsAPI.predict-Tuple{GeneralizedDynamicFactorModel}"><code>StatsAPI.predict</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Predicted values (common component).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/generalizedfactor.jl#L213">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.r2-Union{Tuple{GeneralizedDynamicFactorModel{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#StatsAPI.r2-Union{Tuple{GeneralizedDynamicFactorModel{T}}, Tuple{T}} where T"><code>StatsAPI.r2</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>R² for each variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/generalizedfactor.jl#L225">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.residuals-Tuple{GeneralizedDynamicFactorModel}"><a class="docstring-binding" href="#StatsAPI.residuals-Tuple{GeneralizedDynamicFactorModel}"><code>StatsAPI.residuals</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Residuals (idiosyncratic component).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/generalizedfactor.jl#L216">source</a></section></details></article><hr/><h2 id="GMM-Estimation"><a class="docs-heading-anchor" href="#GMM-Estimation">GMM Estimation</a><a id="GMM-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#GMM-Estimation" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_gmm-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, Any}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_gmm-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, Any}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_gmm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_gmm(moment_fn::Function, theta0::AbstractVector{T}, data;
             weighting::Symbol=:two_step, max_iter::Int=100,
             tol::T=T(1e-8), hac::Bool=true, bandwidth::Int=0) -&gt; GMMModel{T}</code></pre><p>Estimate parameters via Generalized Method of Moments.</p><p>Minimizes: Q(θ) = g(θ)&#39;W g(θ) where g(θ) = (1/n) Σᵢ gᵢ(θ)</p><p>Arguments:</p><ul><li>moment_fn: Function (theta, data) -&gt; Matrix of moment conditions (n × q)</li><li>theta0: Initial parameter guess</li><li>data: Data passed to moment function</li><li>weighting: Weighting method (:identity, :optimal, :two_step, :iterated)</li><li>max_iter: Maximum iterations for optimization and/or iterated GMM</li><li>tol: Convergence tolerance</li><li>hac: Use HAC correction for optimal weighting</li><li>bandwidth: HAC bandwidth (0 = automatic)</li></ul><p>Returns:</p><ul><li>GMMModel with estimates, covariance, and J-test results</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/gmm.jl#L336-L357">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_lp_gmm-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_lp_gmm-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_lp_gmm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_lp_gmm(Y::AbstractMatrix{T}, shock_var::Int, horizon::Int;
                lags::Int=4, weighting::Symbol=:two_step) -&gt; Vector{GMMModel{T}}</code></pre><p>Estimate Local Projection via GMM.</p><p>Returns a GMMModel for each horizon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/gmm.jl#L581-L588">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.gmm_objective-Union{Tuple{T}, Tuple{AbstractVector{T}, Function, Any, AbstractMatrix{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.gmm_objective-Union{Tuple{T}, Tuple{AbstractVector{T}, Function, Any, AbstractMatrix{T}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.gmm_objective</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gmm_objective(theta::AbstractVector{T}, moment_fn::Function, data,
              W::AbstractMatrix{T}) -&gt; T</code></pre><p>Compute GMM objective: Q(θ) = g(θ)&#39;W g(θ)</p><p>where g(θ) = (1/n) Σᵢ gᵢ(θ,data)</p><p>Arguments:</p><ul><li>theta: Parameter vector</li><li>moment_fn: Function (theta, data) -&gt; Matrix of moment conditions (n × q)</li><li>data: Data passed to moment function</li><li>W: Weighting matrix (q × q)</li></ul><p>Returns:</p><ul><li>GMM objective value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/gmm.jl#L160-L176">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.gmm_summary-Union{Tuple{GMMModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.gmm_summary-Union{Tuple{GMMModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.gmm_summary</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gmm_summary(model::GMMModel{T}) -&gt; NamedTuple</code></pre><p>Summary statistics for GMM estimation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/gmm.jl#L505-L509">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identity_weighting-Union{Tuple{Int64}, Tuple{T}, Tuple{Int64, Type{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.identity_weighting-Union{Tuple{Int64}, Tuple{T}, Tuple{Int64, Type{T}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.identity_weighting</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">identity_weighting(n_moments::Int, ::Type{T}=Float64) -&gt; Matrix{T}</code></pre><p>Identity weighting matrix (one-step GMM).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/gmm.jl#L188-L192">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.j_test-Union{Tuple{GMMModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.j_test-Union{Tuple{GMMModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.j_test</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">j_test(model::GMMModel{T}) -&gt; NamedTuple</code></pre><p>Hansen&#39;s J-test for overidentifying restrictions.</p><p>H0: All moment conditions are valid (E[g(θ₀)] = 0) H1: Some moment conditions are violated</p><p>Returns:</p><ul><li>J_stat: Test statistic</li><li>p_value: p-value from chi-squared distribution</li><li>df: Degrees of freedom (n<em>moments - n</em>params)</li><li>reject_05: Whether to reject at 5% level</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/gmm.jl#L479-L492">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.lp_gmm_moments-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64, Any, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.lp_gmm_moments-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64, Any, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.lp_gmm_moments</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lp_gmm_moments(Y::AbstractMatrix{T}, shock_var::Int, h::Int, theta,
               lags::Int) -&gt; Matrix{T}</code></pre><p>Construct moment conditions for LP estimated via GMM.</p><p>Moments: E[Z<em>t * ε</em>{t+h}] = 0 where ε<em>{t+h} = y</em>{t+h} - θ&#39; * X_t and Z includes all exogenous variables.</p><p>This is useful when you need to impose cross-equation restrictions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/gmm.jl#L527-L537">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.minimize_gmm-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, Any, AbstractMatrix{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.minimize_gmm-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, Any, AbstractMatrix{T}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.minimize_gmm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">minimize_gmm(moment_fn::Function, theta0::AbstractVector{T}, data,
             W::AbstractMatrix{T}; max_iter::Int=100, tol::T=T(1e-8)) -&gt; NamedTuple</code></pre><p>Minimize GMM objective using gradient descent with BFGS-like updates.</p><p>Returns:</p><ul><li>theta: Minimizer</li><li>objective: Final objective value</li><li>converged: Convergence flag</li><li>iterations: Number of iterations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/gmm.jl#L249-L260">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.numerical_gradient-Union{Tuple{T}, Tuple{Function, AbstractVector{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.numerical_gradient-Union{Tuple{T}, Tuple{Function, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.numerical_gradient</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">numerical_gradient(f::Function, x::AbstractVector{T}; eps::T=T(1e-7)) -&gt; Matrix{T}</code></pre><p>Compute numerical gradient (Jacobian) of function f at point x using central differences.</p><p>Arguments:</p><ul><li>f: Function that takes vector x and returns vector (moment conditions)</li><li>x: Point at which to evaluate gradient</li><li>eps: Step size for finite differences</li></ul><p>Returns:</p><ul><li>Jacobian matrix (n<em>moments × n</em>params)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/gmm.jl#L124-L136">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.optimal_weighting_matrix-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, Any}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.optimal_weighting_matrix-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, Any}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.optimal_weighting_matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">optimal_weighting_matrix(moment_fn::Function, theta::AbstractVector{T}, data;
                         hac::Bool=true, bandwidth::Int=0) -&gt; Matrix{T}</code></pre><p>Compute optimal GMM weighting matrix: W = inv(Var(g)).</p><p>For i.i.d. data: W = inv((1/n) Σᵢ gᵢ gᵢ&#39;) For time series: Uses HAC estimation with Newey-West kernel.</p><p>Arguments:</p><ul><li>moment_fn: Moment function</li><li>theta: Current parameter estimate</li><li>data: Data</li><li>hac: Use HAC correction for serial correlation</li><li>bandwidth: HAC bandwidth (0 = automatic)</li></ul><p>Returns:</p><ul><li>Optimal weighting matrix (q × q)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/gmm.jl#L197-L215">source</a></section></details></article><hr/><h2 id="Unit-Root-and-Cointegration-Tests"><a class="docs-heading-anchor" href="#Unit-Root-and-Cointegration-Tests">Unit Root and Cointegration Tests</a><a id="Unit-Root-and-Cointegration-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Unit-Root-and-Cointegration-Tests" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MacroEconometricModels._build_adf_matrix-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Int64, Symbol}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._build_adf_matrix-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Int64, Symbol}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._build_adf_matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Build ADF regression matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/unitroot.jl#L450">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._long_run_variance-Union{Tuple{T}, Tuple{AbstractVector{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._long_run_variance-Union{Tuple{T}, Tuple{AbstractVector{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._long_run_variance</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute long-run variance using Bartlett kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/unitroot.jl#L493">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._ngperron_pvalue-Union{Tuple{T}, Tuple{T, Symbol, Symbol}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._ngperron_pvalue-Union{Tuple{T}, Tuple{T, Symbol, Symbol}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._ngperron_pvalue</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Approximate p-value for Ng-Perron tests.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/unitroot.jl#L372">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._nw_bandwidth-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._nw_bandwidth-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._nw_bandwidth</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute Newey-West bandwidth using Andrews (1991) AR(1) rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/unitroot.jl#L482">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.adf_critical_values"><a class="docstring-binding" href="#MacroEconometricModels.adf_critical_values"><code>MacroEconometricModels.adf_critical_values</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Compute ADF critical values using MacKinnon response surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/unitroot.jl#L312">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.adf_pvalue-Union{Tuple{T}, Tuple{T, Symbol, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.adf_pvalue-Union{Tuple{T}, Tuple{T, Symbol, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.adf_pvalue</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Approximate p-value for ADF test using MacKinnon (1994) interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/unitroot.jl#L321">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.adf_select_lags-Union{Tuple{T}, Tuple{AbstractVector{T}, Int64, Symbol, Symbol}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.adf_select_lags-Union{Tuple{T}, Tuple{AbstractVector{T}, Int64, Symbol, Symbol}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.adf_select_lags</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute optimal lag length for ADF test using information criterion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/unitroot.jl#L402">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.adf_test-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.adf_test-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.adf_test</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">adf_test(y; lags=:aic, max_lags=nothing, regression=:constant) -&gt; ADFResult</code></pre><p>Augmented Dickey-Fuller test for unit root.</p><p>Tests H₀: y has a unit root (non-stationary) against H₁: y is stationary.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>lags</code>: Number of augmenting lags, or :aic/:bic/:hqic for automatic selection</li><li><code>max_lags</code>: Maximum lags for automatic selection (default: floor(12*(T/100)^0.25))</li><li><code>regression</code>: Deterministic terms - :none, :constant (default), or :trend</li></ul><p><strong>Returns</strong></p><p><code>ADFResult</code> containing test statistic, p-value, critical values, etc.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = cumsum(randn(200))  # Random walk (has unit root)
result = adf_test(y)
result.pvalue &gt; 0.05  # Should fail to reject H₀</code></pre><p><strong>References</strong></p><ul><li>Dickey, D. A., &amp; Fuller, W. A. (1979). Distribution of the estimators for autoregressive time series with a unit root. JASA, 74(366), 427-431.</li><li>MacKinnon, J. G. (2010). Critical values for cointegration tests. Queen&#39;s Economics Department Working Paper No. 1227.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/unitroot.jl#L512-L540">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.is_stationary-Union{Tuple{VARModel{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#MacroEconometricModels.is_stationary-Union{Tuple{VARModel{T}}, Tuple{T}} where T"><code>MacroEconometricModels.is_stationary</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_stationary(model::VARModel) -&gt; VARStationarityResult</code></pre><p>Check if estimated VAR model is stationary.</p><p>A VAR(p) is stationary if and only if all eigenvalues of the companion matrix have modulus strictly less than 1.</p><p><strong>Returns</strong></p><p><code>VARStationarityResult</code> with:</p><ul><li><code>is_stationary</code>: Boolean indicating stationarity</li><li><code>eigenvalues</code>: Complex eigenvalues of companion matrix</li><li><code>max_modulus</code>: Maximum eigenvalue modulus</li><li><code>companion_matrix</code>: The (np × np) companion form matrix</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">model = estimate_var(Y, 2)
result = is_stationary(model)
if !result.is_stationary
    println(&quot;Warning: VAR is non-stationary, max modulus = &quot;, result.max_modulus)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/unitroot.jl#L1211-L1234">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.johansen_test-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.johansen_test-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.johansen_test</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">johansen_test(Y, p; deterministic=:constant) -&gt; JohansenResult</code></pre><p>Johansen cointegration test for VAR system.</p><p>Tests for the number of cointegrating relationships among variables using trace and maximum eigenvalue tests.</p><p><strong>Arguments</strong></p><ul><li><code>Y</code>: Data matrix (T × n)</li><li><code>p</code>: Number of lags in the VECM representation</li><li><code>deterministic</code>: Specification for deterministic terms<ul><li>:none - No deterministic terms</li><li>:constant - Constant in cointegrating relation (default)</li><li>:trend - Linear trend in levels</li></ul></li></ul><p><strong>Returns</strong></p><p><code>JohansenResult</code> containing trace and max-eigenvalue statistics, cointegrating vectors, adjustment coefficients, and estimated rank.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Generate cointegrated system
n, T = 3, 200
Y = randn(T, n)
Y[:, 2] = Y[:, 1] + 0.1 * randn(T)  # Y2 cointegrated with Y1

result = johansen_test(Y, 2)
result.rank  # Should detect 1 or 2 cointegrating relations</code></pre><p><strong>References</strong></p><ul><li>Johansen, S. (1991). Estimation and hypothesis testing of cointegration vectors in Gaussian vector autoregressive models. Econometrica, 59(6), 1551-1580.</li><li>Osterwald-Lenum, M. (1992). A note with quantiles of the asymptotic distribution of the ML cointegration rank test statistics. Oxford BEJM.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/unitroot.jl#L1018-L1054">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.kpss_pvalue-Union{Tuple{T}, Tuple{T, Symbol}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.kpss_pvalue-Union{Tuple{T}, Tuple{T, Symbol}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.kpss_pvalue</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Approximate p-value for KPSS test.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/unitroot.jl#L342">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.kpss_test-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.kpss_test-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.kpss_test</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">kpss_test(y; regression=:constant, bandwidth=:auto) -&gt; KPSSResult</code></pre><p>Kwiatkowski-Phillips-Schmidt-Shin test for stationarity.</p><p>Tests H₀: y is stationary against H₁: y has a unit root.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>regression</code>: :constant (level stationarity) or :trend (trend stationarity)</li><li><code>bandwidth</code>: Bartlett kernel bandwidth, or :auto for Newey-West selection</li></ul><p><strong>Returns</strong></p><p><code>KPSSResult</code> containing test statistic, p-value, critical values, etc.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = randn(200)  # Stationary series
result = kpss_test(y)
result.pvalue &gt; 0.05  # Should fail to reject H₀ (stationarity)</code></pre><p><strong>References</strong></p><ul><li>Kwiatkowski, D., Phillips, P. C., Schmidt, P., &amp; Shin, Y. (1992). Testing the null hypothesis of stationarity against the alternative of a unit root. Journal of Econometrics, 54(1-3), 159-178.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/unitroot.jl#L604-L630">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.ngperron_test-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.ngperron_test-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.ngperron_test</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ngperron_test(y; regression=:constant) -&gt; NgPerronResult</code></pre><p>Ng-Perron unit root tests with GLS detrending (MZα, MZt, MSB, MPT).</p><p>Tests H₀: y has a unit root against H₁: y is stationary. These tests have better size properties than ADF/PP in small samples.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>regression</code>: :constant (default) or :trend</li></ul><p><strong>Returns</strong></p><p><code>NgPerronResult</code> containing MZα, MZt, MSB, MPT statistics and critical values.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = cumsum(randn(100))
result = ngperron_test(y)
# Check if MZt rejects at 5%
result.MZt &lt; result.critical_values[:MZt][5]</code></pre><p><strong>References</strong></p><ul><li>Ng, S., &amp; Perron, P. (2001). Lag length selection and the construction of unit root tests with good size and power. Econometrica, 69(6), 1519-1554.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/unitroot.jl#L905-L931">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.pp_test-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.pp_test-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.pp_test</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pp_test(y; regression=:constant, bandwidth=:auto) -&gt; PPResult</code></pre><p>Phillips-Perron test for unit root with non-parametric correction.</p><p>Tests H₀: y has a unit root against H₁: y is stationary.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>regression</code>: :none, :constant (default), or :trend</li><li><code>bandwidth</code>: Newey-West bandwidth, or :auto for automatic selection</li></ul><p><strong>Returns</strong></p><p><code>PPResult</code> containing test statistic (Zt), p-value, critical values, etc.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = cumsum(randn(200))  # Random walk
result = pp_test(y)
result.pvalue &gt; 0.05  # Should fail to reject H₀</code></pre><p><strong>References</strong></p><ul><li>Phillips, P. C., &amp; Perron, P. (1988). Testing for a unit root in time series regression. Biometrika, 75(2), 335-346.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/unitroot.jl#L676-L701">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.test_all_variables-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.test_all_variables-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.test_all_variables</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">test_all_variables(Y; test=:adf, kwargs...) -&gt; Vector</code></pre><p>Apply unit root test to each column of Y.</p><p><strong>Arguments</strong></p><ul><li><code>Y</code>: Data matrix (T × n)</li><li><code>test</code>: Test to apply (:adf, :kpss, :pp, :za, :ngperron)</li><li><code>kwargs...</code>: Additional arguments passed to the test</li></ul><p><strong>Returns</strong></p><p>Vector of test results, one per variable.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">Y = randn(200, 3)
Y[:, 1] = cumsum(Y[:, 1])  # Make first column non-stationary
results = test_all_variables(Y; test=:adf)
[r.pvalue for r in results]  # P-values for each variable</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/unitroot.jl#L1309-L1329">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.unit_root_summary-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.unit_root_summary-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.unit_root_summary</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">unit_root_summary(y; tests=[:adf, :kpss, :pp], kwargs...) -&gt; NamedTuple</code></pre><p>Run multiple unit root tests and return summary with PrettyTables output.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>tests</code>: Vector of test symbols to run (default: [:adf, :kpss, :pp])</li><li><code>kwargs...</code>: Additional arguments passed to individual tests</li></ul><p><strong>Returns</strong></p><p>NamedTuple with test results, conclusion, and summary table.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = cumsum(randn(200))
summary = unit_root_summary(y)
summary.conclusion  # Overall conclusion</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/unitroot.jl#L1246-L1265">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.za_pvalue-Union{Tuple{T}, Tuple{T, Symbol}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.za_pvalue-Union{Tuple{T}, Tuple{T, Symbol}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.za_pvalue</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Approximate p-value for Zivot-Andrews test.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/unitroot.jl#L357">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.za_test-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.za_test-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.za_test</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">za_test(y; regression=:both, trim=0.15, lags=:aic, max_lags=nothing) -&gt; ZAResult</code></pre><p>Zivot-Andrews test for unit root with endogenous structural break.</p><p>Tests H₀: y has a unit root without break against H₁: y is stationary with break.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>regression</code>: Type of break - :constant (intercept), :trend (slope), or :both</li><li><code>trim</code>: Trimming fraction for break search (default 0.15)</li><li><code>lags</code>: Number of augmenting lags, or :aic/:bic for automatic selection</li><li><code>max_lags</code>: Maximum lags for selection</li></ul><p><strong>Returns</strong></p><p><code>ZAResult</code> containing minimum t-statistic, break point, p-value, etc.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Series with structural break
y = vcat(randn(100), randn(100) .+ 2)
result = za_test(y; regression=:constant)</code></pre><p><strong>References</strong></p><ul><li>Zivot, E., &amp; Andrews, D. W. K. (1992). Further evidence on the great crash, the oil-price shock, and the unit-root hypothesis. JBES, 10(3), 251-270.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/unitroot.jl#L769-L796">source</a></section></details></article><hr/><h2 id="Non-Gaussian-SVAR-Identification"><a class="docs-heading-anchor" href="#Non-Gaussian-SVAR-Identification">Non-Gaussian SVAR Identification</a><a id="Non-Gaussian-SVAR-Identification-1"></a><a class="docs-heading-anchor-permalink" href="#Non-Gaussian-SVAR-Identification" title="Permalink"></a></h2><h3 id="Normality-Tests"><a class="docs-heading-anchor" href="#Normality-Tests">Normality Tests</a><a id="Normality-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Normality-Tests" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.jarque_bera_test"><a class="docstring-binding" href="#MacroEconometricModels.jarque_bera_test"><code>MacroEconometricModels.jarque_bera_test</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">jarque_bera_test(model::VARModel; method=:multivariate) -&gt; NormalityTestResult
jarque_bera_test(U::AbstractMatrix; method=:multivariate)  -&gt; NormalityTestResult</code></pre><p>Multivariate Jarque-Bera test for normality of VAR residuals.</p><p>Methods:</p><ul><li><code>:multivariate</code> — joint test based on multivariate skewness and kurtosis (Lütkepohl 2005)</li><li><code>:component</code> — component-wise univariate JB tests on standardized residuals</li></ul><p><strong>Reference</strong>: Jarque &amp; Bera (1980), Lütkepohl (2005, §4.5)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/normality_tests.jl#L152-L163">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.mardia_test"><a class="docstring-binding" href="#MacroEconometricModels.mardia_test"><code>MacroEconometricModels.mardia_test</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">mardia_test(model::VARModel; type=:both) -&gt; NormalityTestResult
mardia_test(U::AbstractMatrix; type=:both) -&gt; NormalityTestResult</code></pre><p>Mardia&#39;s tests for multivariate normality based on multivariate skewness and kurtosis.</p><p>Types:</p><ul><li><code>:skewness</code> — tests multivariate skewness b₁,ₖ</li><li><code>:kurtosis</code> — tests multivariate kurtosis b₂,ₖ</li><li><code>:both</code> — combined test (sum of both statistics)</li></ul><p>Under H₀: T·b₁,ₖ/6 ~ χ²(k(k+1)(k+2)/6), (b₂,ₖ - k(k+2)) / √(8k(k+2)/T) ~ N(0,1).</p><p><strong>Reference</strong>: Mardia (1970)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/normality_tests.jl#L209-L223">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.doornik_hansen_test"><a class="docstring-binding" href="#MacroEconometricModels.doornik_hansen_test"><code>MacroEconometricModels.doornik_hansen_test</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">doornik_hansen_test(model::VARModel) -&gt; NormalityTestResult
doornik_hansen_test(U::AbstractMatrix)  -&gt; NormalityTestResult</code></pre><p>Doornik-Hansen omnibus test for multivariate normality.</p><p>Applies the Bowman-Shenton transformation to each component&#39;s skewness and kurtosis, then sums z₁² + z₂² across components. Under H₀: DH ~ χ²(2k).</p><p><strong>Reference</strong>: Doornik &amp; Hansen (2008)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/normality_tests.jl#L264-L274">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.henze_zirkler_test"><a class="docstring-binding" href="#MacroEconometricModels.henze_zirkler_test"><code>MacroEconometricModels.henze_zirkler_test</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">henze_zirkler_test(model::VARModel) -&gt; NormalityTestResult
henze_zirkler_test(U::AbstractMatrix)  -&gt; NormalityTestResult</code></pre><p>Henze-Zirkler test for multivariate normality based on the empirical characteristic function.</p><p>The test statistic is:</p><p class="math-container">\[T_{\beta} = \frac{1}{n} \sum_{i,j} e^{-\beta^2 D_{ij}/2} - 2(1+\beta^2)^{-k/2} \sum_i e^{-\beta^2 d_i^2/(2(1+\beta^2))} + n(1+2\beta^2)^{-k/2}\]</p><p>where <span>$D_{ij} = (z_i - z_j)&#39;(z_i - z_j)$</span> and <span>$d_i = z_i&#39; z_i$</span>.</p><p><strong>Reference</strong>: Henze &amp; Zirkler (1990)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/normality_tests.jl#L310-L323">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.normality_test_suite"><a class="docstring-binding" href="#MacroEconometricModels.normality_test_suite"><code>MacroEconometricModels.normality_test_suite</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">normality_test_suite(model::VARModel) -&gt; NormalityTestSuite
normality_test_suite(U::AbstractMatrix)  -&gt; NormalityTestSuite</code></pre><p>Run all available multivariate normality tests and return a <code>NormalityTestSuite</code>.</p><p>Tests included:</p><ol><li>Multivariate Jarque-Bera</li><li>Component-wise Jarque-Bera</li><li>Mardia skewness</li><li>Mardia kurtosis</li><li>Mardia combined</li><li>Doornik-Hansen</li><li>Henze-Zirkler</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/normality_tests.jl#L386-L400">source</a></section></details></article><h3 id="ICA-based-Identification"><a class="docs-heading-anchor" href="#ICA-based-Identification">ICA-based Identification</a><a id="ICA-based-Identification-1"></a><a class="docs-heading-anchor-permalink" href="#ICA-based-Identification" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_fastica"><a class="docstring-binding" href="#MacroEconometricModels.identify_fastica"><code>MacroEconometricModels.identify_fastica</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">identify_fastica(model::VARModel; contrast=:logcosh, approach=:deflation,
                 max_iter=200, tol=1e-6) -&gt; ICASVARResult</code></pre><p>Identify SVAR via FastICA (Hyvärinen 1999).</p><p>Recovers independent non-Gaussian structural shocks by maximizing non-Gaussianity of the recovered sources.</p><p>Arguments:</p><ul><li><code>contrast</code> — non-Gaussianity measure: <code>:logcosh</code> (default, robust), <code>:exp</code>, <code>:kurtosis</code></li><li><code>approach</code> — <code>:deflation</code> (one-by-one) or <code>:symmetric</code> (simultaneous)</li><li><code>max_iter</code> — maximum iterations per component</li><li><code>tol</code> — convergence tolerance</li></ul><p><strong>Reference</strong>: Hyvärinen (1999)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/nongaussian_ica.jl#L277-L293">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_jade"><a class="docstring-binding" href="#MacroEconometricModels.identify_jade"><code>MacroEconometricModels.identify_jade</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">identify_jade(model::VARModel; max_iter=100, tol=1e-6) -&gt; ICASVARResult</code></pre><p>Identify SVAR via JADE (Joint Approximate Diagonalization of Eigenmatrices).</p><p>Uses fourth-order cumulant matrices and joint diagonalization via Jacobi rotations.</p><p><strong>Reference</strong>: Cardoso &amp; Souloumiac (1993)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/nongaussian_ica.jl#L405-L413">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_sobi"><a class="docstring-binding" href="#MacroEconometricModels.identify_sobi"><code>MacroEconometricModels.identify_sobi</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">identify_sobi(model::VARModel; lags=1:12, max_iter=100, tol=1e-6) -&gt; ICASVARResult</code></pre><p>Identify SVAR via SOBI (Second-Order Blind Identification).</p><p>Uses autocovariance matrices at multiple lags and joint diagonalization. Exploits temporal structure rather than higher-order statistics.</p><p><strong>Reference</strong>: Belouchrani et al. (1997)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/nongaussian_ica.jl#L454-L463">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_dcov"><a class="docstring-binding" href="#MacroEconometricModels.identify_dcov"><code>MacroEconometricModels.identify_dcov</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">identify_dcov(model::VARModel; max_iter=200, tol=1e-6) -&gt; ICASVARResult</code></pre><p>Identify SVAR by minimizing pairwise distance covariance between recovered shocks.</p><p>Distance covariance (Székely et al. 2007) is zero iff the variables are independent, making it a natural criterion for ICA.</p><p><strong>Reference</strong>: Matteson &amp; Tsay (2017)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/nongaussian_ica.jl#L529-L538">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_hsic"><a class="docstring-binding" href="#MacroEconometricModels.identify_hsic"><code>MacroEconometricModels.identify_hsic</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">identify_hsic(model::VARModel; kernel=:gaussian, sigma=1.0,
              max_iter=200, tol=1e-6) -&gt; ICASVARResult</code></pre><p>Identify SVAR by minimizing pairwise HSIC between recovered shocks.</p><p>HSIC with a characteristic kernel (Gaussian) is zero iff variables are independent.</p><p><strong>Reference</strong>: Gretton et al. (2005)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/nongaussian_ica.jl#L594-L603">source</a></section></details></article><h3 id="Non-Gaussian-ML-Identification"><a class="docs-heading-anchor" href="#Non-Gaussian-ML-Identification">Non-Gaussian ML Identification</a><a id="Non-Gaussian-ML-Identification-1"></a><a class="docs-heading-anchor-permalink" href="#Non-Gaussian-ML-Identification" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_student_t"><a class="docstring-binding" href="#MacroEconometricModels.identify_student_t"><code>MacroEconometricModels.identify_student_t</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">identify_student_t(model::VARModel; max_iter=500, tol=1e-6) -&gt; NonGaussianMLResult</code></pre><p>Identify SVAR assuming Student-t distributed structural shocks.</p><p>Each shock εⱼ ~ t(νⱼ) (standardized to unit variance). Identification is achieved when at most one νⱼ = ∞ (Gaussian).</p><p><strong>Reference</strong>: Lanne, Meitz &amp; Saikkonen (2017)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/nongaussian_ml.jl#L361-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_mixture_normal"><a class="docstring-binding" href="#MacroEconometricModels.identify_mixture_normal"><code>MacroEconometricModels.identify_mixture_normal</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">identify_mixture_normal(model::VARModel; n_components=2, max_iter=500, tol=1e-6) -&gt; NonGaussianMLResult</code></pre><p>Identify SVAR assuming mixture-of-normals distributed structural shocks.</p><p>Each shock εⱼ ~ p<em>j N(0,σ₁ⱼ²) + (1-p</em>j) N(0,σ₂ⱼ²) with unit variance constraint.</p><p><strong>Reference</strong>: Lanne &amp; Lütkepohl (2010)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/nongaussian_ml.jl#L376-L384">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_pml"><a class="docstring-binding" href="#MacroEconometricModels.identify_pml"><code>MacroEconometricModels.identify_pml</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">identify_pml(model::VARModel; max_iter=500, tol=1e-6) -&gt; NonGaussianMLResult</code></pre><p>Identify SVAR via Pseudo Maximum Likelihood using Pearson Type IV distributions.</p><p>Allows both skewness and excess kurtosis in the structural shocks.</p><p><strong>Reference</strong>: Herwartz (2018)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/nongaussian_ml.jl#L390-L398">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_skew_normal"><a class="docstring-binding" href="#MacroEconometricModels.identify_skew_normal"><code>MacroEconometricModels.identify_skew_normal</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">identify_skew_normal(model::VARModel; max_iter=500, tol=1e-6) -&gt; NonGaussianMLResult</code></pre><p>Identify SVAR assuming skew-normal distributed structural shocks.</p><p>Each shock εⱼ has pdf f(x) = 2 φ(x) Φ(αⱼ x), where αⱼ controls skewness.</p><p><strong>Reference</strong>: Azzalini (1985)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/nongaussian_ml.jl#L404-L412">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_nongaussian_ml"><a class="docstring-binding" href="#MacroEconometricModels.identify_nongaussian_ml"><code>MacroEconometricModels.identify_nongaussian_ml</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">identify_nongaussian_ml(model::VARModel; distribution=:student_t,
                        max_iter=500, tol=1e-6) -&gt; NonGaussianMLResult</code></pre><p>Unified non-Gaussian ML SVAR identification dispatcher.</p><p>Supported distributions:</p><ul><li><code>:student_t</code> — independent Student-t shocks (Lanne, Meitz &amp; Saikkonen 2017)</li><li><code>:mixture_normal</code> — mixture of two normals (Lanne &amp; Lütkepohl 2010)</li><li><code>:pml</code> — Pearson Type IV / Pseudo-ML (Herwartz 2018)</li><li><code>:skew_normal</code> — skew-normal (Azzalini 1985)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/nongaussian_ml.jl#L418-L429">source</a></section></details></article><h3 id="Heteroskedasticity-Identification"><a class="docs-heading-anchor" href="#Heteroskedasticity-Identification">Heteroskedasticity Identification</a><a id="Heteroskedasticity-Identification-1"></a><a class="docs-heading-anchor-permalink" href="#Heteroskedasticity-Identification" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_markov_switching"><a class="docstring-binding" href="#MacroEconometricModels.identify_markov_switching"><code>MacroEconometricModels.identify_markov_switching</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">identify_markov_switching(model::VARModel; n_regimes=2, max_iter=500, tol=1e-6) -&gt; MarkovSwitchingSVARResult</code></pre><p>Identify SVAR via Markov-switching heteroskedasticity (Lanne &amp; Lütkepohl 2008).</p><p>Estimates regime-specific covariance matrices Σ₁, Σ₂, ..., Σ_K via EM algorithm, then identifies B₀ from the eigendecomposition of Σ₁⁻¹ Σ₂.</p><p>Identification requires that the relative variance ratios (eigenvalues) are distinct.</p><p><strong>Reference</strong>: Lanne &amp; Lütkepohl (2008), Rigobon (2003)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/heteroskedastic_id.jl#L339-L350">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_garch"><a class="docstring-binding" href="#MacroEconometricModels.identify_garch"><code>MacroEconometricModels.identify_garch</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">identify_garch(model::VARModel; max_iter=500, tol=1e-6) -&gt; GARCHSVARResult</code></pre><p>Identify SVAR via GARCH-based heteroskedasticity (Normandin &amp; Phaneuf 2004).</p><p>Iterative procedure:</p><ol><li>Start with Cholesky B₀</li><li>Compute structural shocks ε<em>t = B₀⁻¹ u</em>t</li><li>Fit GARCH(1,1) to each ε_j,t</li><li>Use conditional covariances to re-estimate B₀</li><li>Repeat until convergence</li></ol><p><strong>Reference</strong>: Normandin &amp; Phaneuf (2004)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/heteroskedastic_id.jl#L475-L488">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_smooth_transition"><a class="docstring-binding" href="#MacroEconometricModels.identify_smooth_transition"><code>MacroEconometricModels.identify_smooth_transition</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">identify_smooth_transition(model::VARModel, transition_var::AbstractVector;
                           max_iter=500, tol=1e-6) -&gt; SmoothTransitionSVARResult</code></pre><p>Identify SVAR via smooth-transition heteroskedasticity (Lütkepohl &amp; Netšunajev 2017).</p><p>The covariance matrix varies smoothly between two regimes:</p><p class="math-container">\[\Sigma_t = B_0 [I + G(s_t)(\Lambda - I)] B_0&#39;\]</p><p>where G(s<em>t) = 1/(1 + exp(-γ(s</em>t - c))) is the logistic transition function.</p><p>Arguments:</p><ul><li><code>transition_var</code> — the transition variable s_t (e.g., a lagged endogenous variable)</li></ul><p><strong>Reference</strong>: Lütkepohl &amp; Netšunajev (2017)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/heteroskedastic_id.jl#L572-L588">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_external_volatility"><a class="docstring-binding" href="#MacroEconometricModels.identify_external_volatility"><code>MacroEconometricModels.identify_external_volatility</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">identify_external_volatility(model::VARModel, regime_indicator::AbstractVector{Int};
                             regimes=2) -&gt; ExternalVolatilitySVARResult</code></pre><p>Identify SVAR via externally specified volatility regimes (Rigobon 2003).</p><p>Uses a known regime indicator (e.g., NBER recessions, financial crises) to split the sample and estimate regime-specific covariance matrices.</p><p>Arguments:</p><ul><li><code>regime_indicator</code> — integer vector of regime labels (1, 2, ..., K)</li><li><code>regimes</code> — number of distinct regimes (default: 2)</li></ul><p><strong>Reference</strong>: Rigobon (2003)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/heteroskedastic_id.jl#L654-L668">source</a></section></details></article><h3 id="Identifiability-Tests"><a class="docs-heading-anchor" href="#Identifiability-Tests">Identifiability Tests</a><a id="Identifiability-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Identifiability-Tests" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.test_identification_strength"><a class="docstring-binding" href="#MacroEconometricModels.test_identification_strength"><code>MacroEconometricModels.test_identification_strength</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">test_identification_strength(model::VARModel; method=:fastica,
                             n_bootstrap=999) -&gt; IdentifiabilityTestResult</code></pre><p>Test the strength of non-Gaussian identification via bootstrap.</p><p>Resamples residuals with replacement, re-estimates B₀, and computes the Procrustes distance between bootstrap and original B₀. Small distances indicate strong identification.</p><p>Returns: test statistic = median Procrustes distance, p-value from distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/nongaussian_tests.jl#L158-L168">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.test_shock_gaussianity"><a class="docstring-binding" href="#MacroEconometricModels.test_shock_gaussianity"><code>MacroEconometricModels.test_shock_gaussianity</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">test_shock_gaussianity(result::ICASVARResult) -&gt; IdentifiabilityTestResult
test_shock_gaussianity(result::NonGaussianMLResult) -&gt; IdentifiabilityTestResult</code></pre><p>Test whether recovered structural shocks are non-Gaussian using univariate JB tests.</p><p>Non-Gaussian identification requires at most one shock to be Gaussian. This test checks each shock individually and reports the joint result.</p><p>At most one Gaussian shock → identification holds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/nongaussian_tests.jl#L238-L248">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.test_gaussian_vs_nongaussian"><a class="docstring-binding" href="#MacroEconometricModels.test_gaussian_vs_nongaussian"><code>MacroEconometricModels.test_gaussian_vs_nongaussian</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">test_gaussian_vs_nongaussian(model::VARModel; distribution=:student_t) -&gt; IdentifiabilityTestResult</code></pre><p>Likelihood ratio test: H₀ Gaussian vs H₁ non-Gaussian structural shocks.</p><p>Under H₀, the LR statistic LR = 2(ℓ₁ - ℓ₀) ~ χ²(n<em>extra</em>params).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/nongaussian_tests.jl#L292-L298">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.test_shock_independence"><a class="docstring-binding" href="#MacroEconometricModels.test_shock_independence"><code>MacroEconometricModels.test_shock_independence</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">test_shock_independence(result::ICASVARResult; max_lag=10) -&gt; IdentifiabilityTestResult
test_shock_independence(result::NonGaussianMLResult; max_lag=10) -&gt; IdentifiabilityTestResult</code></pre><p>Test independence of recovered structural shocks.</p><p>Uses both cross-correlation (portmanteau) and distance covariance tests. Independence is a necessary condition for valid identification.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/nongaussian_tests.jl#L322-L330">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.test_overidentification"><a class="docstring-binding" href="#MacroEconometricModels.test_overidentification"><code>MacroEconometricModels.test_overidentification</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">test_overidentification(model::VARModel, result::AbstractNonGaussianSVAR;
                        restrictions=nothing, n_bootstrap=499) -&gt; IdentifiabilityTestResult</code></pre><p>Test overidentifying restrictions for non-Gaussian SVAR.</p><p>When additional restrictions beyond non-Gaussianity are imposed (e.g., zero restrictions on B₀), this test checks whether those restrictions are consistent with the data.</p><p>Uses a bootstrap approach: compares the restricted log-likelihood to bootstrap distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/nongaussian_tests.jl#L373-L383">source</a></section></details></article><hr/><h2 id="Utility-Functions"><a class="docs-heading-anchor" href="#Utility-Functions">Utility Functions</a><a id="Utility-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MacroEconometricModels._default_names-Tuple{Int64, String}"><a class="docstring-binding" href="#MacroEconometricModels._default_names-Tuple{Int64, String}"><code>MacroEconometricModels._default_names</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Generate default names: [&quot;prefix 1&quot;, &quot;prefix 2&quot;, ...]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/utils.jl#L174">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.companion_matrix-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.companion_matrix-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.companion_matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Construct companion matrix F for VAR(p) → VAR(1) representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/utils.jl#L139">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.compute_posterior_quantiles!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, AbstractArray{T}, AbstractVector}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.compute_posterior_quantiles!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, AbstractArray{T}, AbstractVector}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.compute_posterior_quantiles!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_posterior_quantiles!(quantile_out::AbstractArray{T}, mean_out::AbstractArray{T},
                              samples::AbstractArray{T}, q_vec::AbstractVector{T}) where {T}</code></pre><p>Compute quantiles and means from posterior samples (in-place).</p><p>Operates over the first dimension (samples) and computes quantiles/means for all other dimensions.</p><p><strong>Arguments</strong></p><ul><li><code>quantile_out</code>: Output array for quantiles, size = (other<em>dims..., n</em>quantiles)</li><li><code>mean_out</code>: Output array for means, size = (other_dims...)</li><li><code>samples</code>: Input samples array, size = (n<em>samples, other</em>dims...)</li><li><code>q_vec</code>: Vector of quantile levels (e.g., [0.16, 0.5, 0.84])</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">samples = randn(1000, 20, 3, 3)  # 1000 samples of 20×3×3 IRF
q_out = zeros(20, 3, 3, 3)      # 3 quantiles
m_out = zeros(20, 3, 3)
compute_posterior_quantiles!(q_out, m_out, samples, [0.16, 0.5, 0.84])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/bayesian_utils.jl#L87-L108">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.compute_posterior_quantiles-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractVector}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.compute_posterior_quantiles-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractVector}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.compute_posterior_quantiles</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_posterior_quantiles(samples::AbstractArray{T}, q_vec::AbstractVector;
                             threaded::Bool=false) where {T}</code></pre><p>Compute quantiles and means from posterior samples (allocating version).</p><p><strong>Arguments</strong></p><ul><li><code>samples</code>: Input samples array, size = (n<em>samples, other</em>dims...)</li><li><code>q_vec</code>: Vector of quantile levels</li><li><code>threaded</code>: Use threaded version for large arrays</li></ul><p><strong>Returns</strong></p><ul><li><code>quantiles</code>: Array of shape (other<em>dims..., n</em>quantiles)</li><li><code>means</code>: Array of shape (other_dims...)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/bayesian_utils.jl#L161-L175">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.compute_posterior_quantiles_threaded!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, AbstractArray{T}, AbstractVector}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.compute_posterior_quantiles_threaded!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, AbstractArray{T}, AbstractVector}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.compute_posterior_quantiles_threaded!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_posterior_quantiles_threaded!(quantile_out::AbstractArray{T}, mean_out::AbstractArray{T},
                                       samples::AbstractArray{T}, q_vec::AbstractVector{T}) where {T}</code></pre><p>Threaded version of quantile computation for large arrays.</p><p>Uses <code>Threads.@threads</code> to parallelize over the index space. Recommended when <code>prod(size(samples)[2:end]) &gt; 1000</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/bayesian_utils.jl#L128-L136">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.compute_weighted_quantiles!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, AbstractArray{T}, AbstractVector{T}, AbstractVector}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.compute_weighted_quantiles!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, AbstractArray{T}, AbstractVector{T}, AbstractVector}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.compute_weighted_quantiles!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_weighted_quantiles!(quantile_out::AbstractArray{T}, mean_out::AbstractArray{T},
                             samples::AbstractArray{T}, weights::AbstractVector{T},
                             q_vec::AbstractVector) where {T}</code></pre><p>Compute weighted quantiles and weighted means from posterior samples (in-place).</p><p>Used for importance-weighted posterior inference (e.g., Arias et al. 2018 SVAR).</p><p><strong>Arguments</strong></p><ul><li><code>quantile_out</code>: Output array for quantiles</li><li><code>mean_out</code>: Output array for weighted means</li><li><code>samples</code>: Input samples array, size = (n<em>samples, other</em>dims...)</li><li><code>weights</code>: Importance weights, normalized to sum to 1</li><li><code>q_vec</code>: Vector of quantile levels</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/bayesian_utils.jl#L198-L213">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.compute_weighted_quantiles_threaded!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, AbstractArray{T}, AbstractVector{T}, AbstractVector}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.compute_weighted_quantiles_threaded!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, AbstractArray{T}, AbstractVector{T}, AbstractVector}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.compute_weighted_quantiles_threaded!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_weighted_quantiles_threaded!(quantile_out::AbstractArray{T}, mean_out::AbstractArray{T},
                                      samples::AbstractArray{T}, weights::AbstractVector{T},
                                      q_vec::AbstractVector) where {T}</code></pre><p>Threaded version of weighted quantile computation for large arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/bayesian_utils.jl#L235-L241">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.construct_var_matrices-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.construct_var_matrices-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.construct_var_matrices</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Construct VAR design matrices: Y<em>eff = X * B + U. Returns (Y</em>eff, X) where X = [1, Y<em>{t-1}, ..., Y</em>{t-p}].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/utils.jl#L112-L115">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.extract_ar_coefficients-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.extract_ar_coefficients-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T"><code>MacroEconometricModels.extract_ar_coefficients</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Extract AR coefficient matrices [A₁, ..., Aₚ] from stacked B matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/utils.jl#L134">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.logdet_safe-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.logdet_safe-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.logdet_safe</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Log determinant with eigenvalue fallback for numerical issues.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/utils.jl#L97">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.process_posterior_samples-Tuple{MCMCChains.Chains, Int64, Int64, Function}"><a class="docstring-binding" href="#MacroEconometricModels.process_posterior_samples-Tuple{MCMCChains.Chains, Int64, Int64, Function}"><code>MacroEconometricModels.process_posterior_samples</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">process_posterior_samples(chain::Chains, p::Int, n::Int, compute_func::Function;
                          data::AbstractMatrix=Matrix{Float64}(undef, 0, 0),
                          method::Symbol=:cholesky, horizon::Int=20,
                          check_func=nothing, narrative_check=nothing,
                          max_draws::Int=100) -&gt; (Vector{Any}, Int)</code></pre><p>Generic framework for processing posterior samples from MCMC chain.</p><p><strong>Process</strong></p><ol><li>Extract chain parameters using <code>extract_chain_parameters</code></li><li>Loop over samples, reconstructing VARModel for each</li><li>Compute identification matrix Q using specified method</li><li>Apply <code>compute_func(model, Q, horizon)</code> to get result for each sample</li></ol><p><strong>Arguments</strong></p><ul><li><code>chain::Chains</code>: MCMC chain from <code>estimate_bvar</code></li><li><code>p::Int</code>: Number of VAR lags</li><li><code>n::Int</code>: Number of variables</li><li><code>compute_func::Function</code>: Function taking (model, Q, horizon) -&gt; result</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>data::AbstractMatrix</code>: Original data (required for narrative method and residual computation)</li><li><code>method::Symbol</code>: Identification method (:cholesky, :sign, :narrative, :long_run)</li><li><code>horizon::Int</code>: IRF/computation horizon</li><li><code>check_func</code>: Sign restriction check function (for method=:sign or :narrative)</li><li><code>narrative_check</code>: Narrative restriction check function (for method=:narrative)</li><li><code>max_draws::Int</code>: Maximum draws for sign/narrative identification</li></ul><p><strong>Returns</strong></p><ul><li><code>results::Vector{Any}</code>: Vector of results from <code>compute_func</code> for each sample</li><li><code>n_samples::Int</code>: Number of samples processed</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Compute IRF for each posterior sample
results, n_samples = process_posterior_samples(chain, p, n,
    (m, Q, h) -&gt; compute_irf(m, Q, h);
    horizon=20, method=:cholesky
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/bayesian_utils.jl#L19-L60">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.robust_inv-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.robust_inv-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.robust_inv</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute inverse with fallback to pseudo-inverse for singular matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/utils.jl#L68">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.safe_cholesky-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.safe_cholesky-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.safe_cholesky</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Cholesky decomposition with automatic jitter for numerical stability.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/utils.jl#L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.stack_posterior_results-Union{Tuple{T}, Tuple{Vector, Tuple}, Tuple{Vector, Tuple, Type{T}}} where T"><a class="docstring-binding" href="#MacroEconometricModels.stack_posterior_results-Union{Tuple{T}, Tuple{Vector, Tuple}, Tuple{Vector, Tuple, Type{T}}} where T"><code>MacroEconometricModels.stack_posterior_results</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">stack_posterior_results(results::Vector, result_size::Tuple, ::Type{T}=Float64) where {T}</code></pre><p>Stack vector of results into single array for quantile computation.</p><p><strong>Arguments</strong></p><ul><li><code>results</code>: Vector of arrays from posterior samples</li><li><code>result_size</code>: Expected size of each result array</li><li><code>T</code>: Element type</li></ul><p><strong>Returns</strong></p><p>Array of size (n<em>samples, result</em>size...)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/bayesian_utils.jl#L271-L283">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.univariate_ar_variance-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.univariate_ar_variance-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.univariate_ar_variance</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>AR(1) residual standard deviation for Minnesota prior scaling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/utils.jl#L160">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.validate_dynamic_factor_inputs-NTuple{4, Int64}"><a class="docstring-binding" href="#MacroEconometricModels.validate_dynamic_factor_inputs-NTuple{4, Int64}"><code>MacroEconometricModels.validate_dynamic_factor_inputs</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Validate dynamic factor model inputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/utils.jl#L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.validate_factor_inputs-Tuple{Int64, Int64, Int64}"><a class="docstring-binding" href="#MacroEconometricModels.validate_factor_inputs-Tuple{Int64, Int64, Int64}"><code>MacroEconometricModels.validate_factor_inputs</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Validate factor model inputs: 1 ≤ r ≤ min(T, N).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/utils.jl#L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.validate_in_range-Tuple{Real, String, Real, Real}"><a class="docstring-binding" href="#MacroEconometricModels.validate_in_range-Tuple{Real, String, Real, Real}"><code>MacroEconometricModels.validate_in_range</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Validate lo ≤ value ≤ hi.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/utils.jl#L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.validate_option-Tuple{Symbol, String, Tuple}"><a class="docstring-binding" href="#MacroEconometricModels.validate_option-Tuple{Symbol, String, Tuple}"><code>MacroEconometricModels.validate_option</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Validate symbol is in valid_options.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/utils.jl#L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.validate_positive-Tuple{Real, String}"><a class="docstring-binding" href="#MacroEconometricModels.validate_positive-Tuple{Real, String}"><code>MacroEconometricModels.validate_positive</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Validate value &gt; 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/utils.jl#L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.validate_var_inputs-Tuple{Int64, Int64, Int64}"><a class="docstring-binding" href="#MacroEconometricModels.validate_var_inputs-Tuple{Int64, Int64, Int64}"><code>MacroEconometricModels.validate_var_inputs</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Validate VAR inputs: p ≥ 1, T &gt; p + min<em>obs</em>factor, n ≥ 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/000f24495c2ed3cafbe935f3dcffc359db9e7f12/src/utils.jl#L11">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api_types/">« Types</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 6 February 2026 03:03">Friday 6 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
