<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Local Projections · MacroEconometricModels.jl</title><meta name="title" content="Local Projections · MacroEconometricModels.jl"/><meta property="og:title" content="Local Projections · MacroEconometricModels.jl"/><meta property="twitter:title" content="Local Projections · MacroEconometricModels.jl"/><meta name="description" content="Documentation for MacroEconometricModels.jl."/><meta property="og:description" content="Documentation for MacroEconometricModels.jl."/><meta property="twitter:description" content="Documentation for MacroEconometricModels.jl."/><meta property="og:url" content="https://chung9207.github.io/MacroEconometricModels.jl/lp/"/><meta property="twitter:url" content="https://chung9207.github.io/MacroEconometricModels.jl/lp/"/><link rel="canonical" href="https://chung9207.github.io/MacroEconometricModels.jl/lp/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MacroEconometricModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Univariate Models</span><ul><li><a class="tocitem" href="../arima/">ARIMA</a></li></ul></li><li><span class="tocitem">Frequentist Models</span><ul><li><a class="tocitem" href="../manual/">VAR</a></li><li class="is-active"><a class="tocitem" href>Local Projections</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Quick-Start"><span>Quick Start</span></a></li><li><a class="tocitem" href="#Standard-Local-Projections"><span>Standard Local Projections</span></a></li><li><a class="tocitem" href="#Local-Projections-with-Instrumental-Variables-(LP-IV)"><span>Local Projections with Instrumental Variables (LP-IV)</span></a></li><li><a class="tocitem" href="#Smooth-Local-Projections"><span>Smooth Local Projections</span></a></li><li><a class="tocitem" href="#State-Dependent-Local-Projections"><span>State-Dependent Local Projections</span></a></li><li><a class="tocitem" href="#Propensity-Score-Local-Projections"><span>Propensity Score Local Projections</span></a></li><li><a class="tocitem" href="#Comparing-LP-and-VAR"><span>Comparing LP and VAR</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../factormodels/">Factor Models</a></li></ul></li><li><span class="tocitem">Bayesian Models</span><ul><li><a class="tocitem" href="../bayesian/">Bayesian VAR</a></li></ul></li><li><a class="tocitem" href="../nongaussian/">Non-Gaussian SVAR</a></li><li><a class="tocitem" href="../innovation_accounting/">Innovation Accounting</a></li><li><span class="tocitem">Hypothesis Tests</span><ul><li><a class="tocitem" href="../hypothesis_tests/">Unit Root &amp; Cointegration</a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../api/">Overview</a></li><li><a class="tocitem" href="../api_types/">Types</a></li><li><a class="tocitem" href="../api_functions/">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Frequentist Models</a></li><li class="is-active"><a href>Local Projections</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Local Projections</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/chung9207/MacroEconometricModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/main/docs/src/lp.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Local-Projections"><a class="docs-heading-anchor" href="#Local-Projections">Local Projections</a><a id="Local-Projections-1"></a><a class="docs-heading-anchor-permalink" href="#Local-Projections" title="Permalink"></a></h1><p>This chapter provides a comprehensive treatment of Local Projection (LP) methods for estimating impulse response functions, an alternative to the VAR-based approach that offers greater robustness and flexibility.</p><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>Local Projections, introduced by Jordà (2005), estimate impulse responses by running a series of predictive regressions at each forecast horizon. Unlike VARs, which derive IRFs from a single estimated dynamic system, LPs directly estimate the response at each horizon without imposing the dynamic restrictions inherent in VAR specifications.</p><h3 id="Key-Advantages-of-Local-Projections"><a class="docs-heading-anchor" href="#Key-Advantages-of-Local-Projections">Key Advantages of Local Projections</a><a id="Key-Advantages-of-Local-Projections-1"></a><a class="docs-heading-anchor-permalink" href="#Key-Advantages-of-Local-Projections" title="Permalink"></a></h3><ol><li><strong>Robustness to Misspecification</strong>: LPs do not impose the lag structure of VARs, making them robust to dynamic misspecification</li><li><strong>Flexibility</strong>: Easy to incorporate nonlinearities, state-dependence, and instrumental variables</li><li><strong>Transparency</strong>: Each horizon&#39;s estimate is independent, making the source of identification transparent</li><li><strong>Inference</strong>: Standard regression-based inference applies (with HAC corrections)</li></ol><p><strong>Reference</strong>: Jordà (2005), Plagborg-Møller &amp; Wolf (2021)</p><h2 id="Quick-Start"><a class="docs-heading-anchor" href="#Quick-Start">Quick Start</a><a id="Quick-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Start" title="Permalink"></a></h2><pre><code class="language-julia hljs">lp = estimate_lp(Y, 1, 20; lags=4, cov_type=:newey_west)               # Standard LP
lpiv = estimate_lp_iv(Y, 3, Z, 20; lags=4)                             # LP-IV
slp = estimate_smooth_lp(Y, 1, 20; lambda=1.0, n_knots=4)              # Smooth LP
sdlp = estimate_state_lp(Y, 1, state, 20; gamma=1.5)                   # State-dependent LP
plp = estimate_propensity_lp(Y, treatment, covariates, 20)              # Propensity LP
irf_result = lp_irf(lp; conf_level=0.95)                               # Extract IRF</code></pre><hr/><h2 id="Standard-Local-Projections"><a class="docs-heading-anchor" href="#Standard-Local-Projections">Standard Local Projections</a><a id="Standard-Local-Projections-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-Local-Projections" title="Permalink"></a></h2><h3 id="The-LP-Regression"><a class="docs-heading-anchor" href="#The-LP-Regression">The LP Regression</a><a id="The-LP-Regression-1"></a><a class="docs-heading-anchor-permalink" href="#The-LP-Regression" title="Permalink"></a></h3><p>For each horizon <span>$h = 0, 1, \ldots, H$</span>, we estimate:</p><p class="math-container">\[y_{i,t+h} = \alpha_{i,h} + \beta_{i,h} x_t + \gamma_{i,h}&#39; w_t + \varepsilon_{i,t+h}\]</p><p>where:</p><ul><li><span>$y_{i,t+h}$</span> is the response variable <span>$i$</span> at time <span>$t+h$</span></li><li><span>$x_t$</span> is the shock/treatment variable at time <span>$t$</span></li><li><span>$w_t$</span> is a vector of controls (typically lagged <span>$y$</span> and <span>$x$</span>)</li><li><span>$\beta_{i,h}$</span> is the impulse response of variable <span>$i$</span> to shock <span>$x$</span> at horizon <span>$h$</span></li></ul><h3 id="Control-Variables"><a class="docs-heading-anchor" href="#Control-Variables">Control Variables</a><a id="Control-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Control-Variables" title="Permalink"></a></h3><p>Standard controls include lags of all endogenous variables:</p><p class="math-container">\[w_t = (y_{t-1}&#39;, y_{t-2}&#39;, \ldots, y_{t-p}&#39;, x_{t-1}, \ldots, x_{t-p})&#39;\]</p><p>The number of lags <span>$p$</span> is typically selected using information criteria or set to match the VAR lag order.</p><h3 id="Estimation"><a class="docs-heading-anchor" href="#Estimation">Estimation</a><a id="Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Estimation" title="Permalink"></a></h3><p>At each horizon <span>$h$</span>, OLS yields:</p><p class="math-container">\[\hat{\beta}_h = (X&#39;X)^{-1} X&#39;Y_h\]</p><p>where <span>$Y_h$</span> is the matrix of responses at horizon <span>$h$</span> and <span>$X$</span> contains the shock variable and controls.</p><h3 id="HAC-Standard-Errors"><a class="docs-heading-anchor" href="#HAC-Standard-Errors">HAC Standard Errors</a><a id="HAC-Standard-Errors-1"></a><a class="docs-heading-anchor-permalink" href="#HAC-Standard-Errors" title="Permalink"></a></h3><p>Since <span>$\varepsilon_{t+h}$</span> is serially correlated (at least MA(h-1) under the null), we use Newey-West standard errors:</p><p class="math-container">\[\hat{V}_{NW} = (X&#39;X)^{-1} \hat{S} (X&#39;X)^{-1}\]</p><p>with bandwidth typically set to <span>$h + 1$</span> or determined automatically.</p><p><strong>Reference</strong>: Jordà (2005), Newey &amp; West (1987)</p><h3 id="Julia-Implementation"><a class="docs-heading-anchor" href="#Julia-Implementation">Julia Implementation</a><a id="Julia-Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-Implementation" title="Permalink"></a></h3><div class="admonition is-info" id="Technical-Note-5889900b91efbaf7"><header class="admonition-header">Technical Note<a class="admonition-anchor" href="#Technical-Note-5889900b91efbaf7" title="Permalink"></a></header><div class="admonition-body"><p>LP residuals <span>$\varepsilon_{t+h}$</span> are serially correlated at least MA(<span>$h-1$</span>) under the null of correct specification, even when the true DGP has i.i.d. errors. This is because overlapping forecast horizons create mechanical dependence. HAC standard errors (Newey-West) are therefore essential for all horizons <span>$h &gt; 0$</span>. The default bandwidth is set to <span>$h + 1$</span> following standard practice.</p></div></div><pre><code class="language-julia hljs">using MacroEconometricModels

# Data: Y is T×n matrix of variables
# shock_var is the index of the shock variable
# Estimate LP-IRF up to horizon H

lp_model = estimate_lp(Y, shock_var, H;
    lags = 4,                  # Control lags
    cov_type = :newey_west,    # HAC standard errors
    bandwidth = 0              # 0 = automatic bandwidth
)

# Extract IRF with confidence intervals
irf_result = lp_irf(lp_model; conf_level = 0.95)</code></pre><h3 id="LPModel-Return-Values"><a class="docs-heading-anchor" href="#LPModel-Return-Values">LPModel Return Values</a><a id="LPModel-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#LPModel-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>Y</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">Original data matrix</td></tr><tr><td style="text-align: right"><code>shock_var</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Index of the shock variable</td></tr><tr><td style="text-align: right"><code>response_vars</code></td><td style="text-align: right"><code>Vector{Int}</code></td><td style="text-align: right">Indices of response variables</td></tr><tr><td style="text-align: right"><code>horizon</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Maximum horizon <span>$H$</span></td></tr><tr><td style="text-align: right"><code>lags</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of control lags</td></tr><tr><td style="text-align: right"><code>B</code></td><td style="text-align: right"><code>Vector{Matrix{T}}</code></td><td style="text-align: right">Coefficient matrices (one per horizon)</td></tr><tr><td style="text-align: right"><code>residuals</code></td><td style="text-align: right"><code>Vector{Matrix{T}}</code></td><td style="text-align: right">Residuals at each horizon</td></tr><tr><td style="text-align: right"><code>vcov</code></td><td style="text-align: right"><code>Vector{Matrix{T}}</code></td><td style="text-align: right">Variance-covariance matrices (HAC)</td></tr><tr><td style="text-align: right"><code>T_eff</code></td><td style="text-align: right"><code>Vector{Int}</code></td><td style="text-align: right">Effective sample size at each horizon</td></tr><tr><td style="text-align: right"><code>cov_estimator</code></td><td style="text-align: right"><code>AbstractCovarianceEstimator</code></td><td style="text-align: right">Covariance estimator used</td></tr></table><h3 id="LPImpulseResponse-Return-Values"><a class="docs-heading-anchor" href="#LPImpulseResponse-Return-Values">LPImpulseResponse Return Values</a><a id="LPImpulseResponse-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#LPImpulseResponse-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>values</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$(H+1) \times n_{resp}$</span> IRF point estimates</td></tr><tr><td style="text-align: right"><code>ci_lower</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">Lower confidence bounds</td></tr><tr><td style="text-align: right"><code>ci_upper</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">Upper confidence bounds</td></tr><tr><td style="text-align: right"><code>se</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">Standard errors at each horizon</td></tr><tr><td style="text-align: right"><code>horizon</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Maximum horizon</td></tr><tr><td style="text-align: right"><code>response_vars</code></td><td style="text-align: right"><code>Vector{String}</code></td><td style="text-align: right">Response variable names</td></tr><tr><td style="text-align: right"><code>shock_var</code></td><td style="text-align: right"><code>String</code></td><td style="text-align: right">Shock variable name</td></tr><tr><td style="text-align: right"><code>cov_type</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Covariance estimator type</td></tr><tr><td style="text-align: right"><code>conf_level</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Confidence level (e.g., 0.95)</td></tr></table><hr/><h2 id="Local-Projections-with-Instrumental-Variables-(LP-IV)"><a class="docs-heading-anchor" href="#Local-Projections-with-Instrumental-Variables-(LP-IV)">Local Projections with Instrumental Variables (LP-IV)</a><a id="Local-Projections-with-Instrumental-Variables-(LP-IV)-1"></a><a class="docs-heading-anchor-permalink" href="#Local-Projections-with-Instrumental-Variables-(LP-IV)" title="Permalink"></a></h2><h3 id="Motivation"><a class="docs-heading-anchor" href="#Motivation">Motivation</a><a id="Motivation-1"></a><a class="docs-heading-anchor-permalink" href="#Motivation" title="Permalink"></a></h3><p>When the shock variable <span>$x_t$</span> is endogenous or measured with error, we need external instruments for identification. Stock &amp; Watson (2018) develop the LP-IV methodology for using external instruments in a local projection framework.</p><h3 id="The-LP-IV-Model"><a class="docs-heading-anchor" href="#The-LP-IV-Model">The LP-IV Model</a><a id="The-LP-IV-Model-1"></a><a class="docs-heading-anchor-permalink" href="#The-LP-IV-Model" title="Permalink"></a></h3><p>We use two-stage least squares (2SLS) at each horizon:</p><p><strong>First Stage</strong>: Regress the endogenous shock on instruments and controls:</p><p class="math-container">\[x_t = \pi_0 + \pi_1&#39; z_t + \pi_2&#39; w_t + v_t\]</p><p><strong>Second Stage</strong>: Use fitted values in the LP regression:</p><p class="math-container">\[y_{i,t+h} = \alpha_{i,h} + \beta_{i,h} \hat{x}_t + \gamma_{i,h}&#39; w_t + \varepsilon_{i,t+h}\]</p><p>where <span>$z_t$</span> is the vector of external instruments.</p><h3 id="Identification-Assumptions"><a class="docs-heading-anchor" href="#Identification-Assumptions">Identification Assumptions</a><a id="Identification-Assumptions-1"></a><a class="docs-heading-anchor-permalink" href="#Identification-Assumptions" title="Permalink"></a></h3><ol><li><strong>Relevance</strong>: <span>$E[z_t x_t] \neq 0$</span> (instruments predict the shock)</li><li><strong>Exogeneity</strong>: <span>$E[z_t \varepsilon_{t+h}] = 0$</span> (instruments are uncorrelated with structural errors)</li></ol><h3 id="First-Stage-F-Statistic"><a class="docs-heading-anchor" href="#First-Stage-F-Statistic">First-Stage F-Statistic</a><a id="First-Stage-F-Statistic-1"></a><a class="docs-heading-anchor-permalink" href="#First-Stage-F-Statistic" title="Permalink"></a></h3><p>The first-stage F-statistic tests instrument relevance:</p><p class="math-container">\[F = \frac{(\hat{\pi}_1&#39; \hat{V}_{\pi}^{-1} \hat{\pi}_1)}{q}\]</p><p>where <span>$q$</span> is the number of instruments. A rule of thumb is <span>$F &gt; 10$</span> for strong instruments (Stock &amp; Yogo, 2005).</p><h3 id="Weak-Instrument-Robust-Inference"><a class="docs-heading-anchor" href="#Weak-Instrument-Robust-Inference">Weak Instrument Robust Inference</a><a id="Weak-Instrument-Robust-Inference-1"></a><a class="docs-heading-anchor-permalink" href="#Weak-Instrument-Robust-Inference" title="Permalink"></a></h3><p>When instruments are weak, standard 2SLS inference is unreliable. Options include:</p><ul><li>Anderson-Rubin confidence sets</li><li>Conditional likelihood ratio tests</li><li>Weak-instrument robust standard errors</li></ul><p><strong>Reference</strong>: Stock &amp; Watson (2018), Stock &amp; Yogo (2005)</p><h3 id="Julia-Implementation-2"><a class="docs-heading-anchor" href="#Julia-Implementation-2">Julia Implementation</a><a class="docs-heading-anchor-permalink" href="#Julia-Implementation-2" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MacroEconometricModels

# Y: T×n data matrix
# shock_var: index of endogenous shock variable
# Z: T×q matrix of external instruments

lpiv_model = estimate_lp_iv(Y, shock_var, Z, H;
    lags = 4,
    cov_type = :newey_west
)

# Check first-stage strength
weak_test = weak_instrument_test(lpiv_model; threshold = 10.0)
println(&quot;Minimum F-statistic: &quot;, weak_test.min_F)
println(&quot;All horizons pass: &quot;, weak_test.passes_threshold)

# Extract IRF
irf_iv = lp_iv_irf(lpiv_model)</code></pre><h3 id="LPIVModel-Return-Values"><a class="docs-heading-anchor" href="#LPIVModel-Return-Values">LPIVModel Return Values</a><a id="LPIVModel-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#LPIVModel-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>Y</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">Original data matrix</td></tr><tr><td style="text-align: right"><code>shock_var</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Index of the endogenous shock variable</td></tr><tr><td style="text-align: right"><code>response_vars</code></td><td style="text-align: right"><code>Vector{Int}</code></td><td style="text-align: right">Response variable indices</td></tr><tr><td style="text-align: right"><code>instruments</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">External instrument matrix</td></tr><tr><td style="text-align: right"><code>horizon</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Maximum horizon</td></tr><tr><td style="text-align: right"><code>lags</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of control lags</td></tr><tr><td style="text-align: right"><code>B</code></td><td style="text-align: right"><code>Vector{Matrix{T}}</code></td><td style="text-align: right">Second-stage coefficient matrices</td></tr><tr><td style="text-align: right"><code>residuals</code></td><td style="text-align: right"><code>Vector{Matrix{T}}</code></td><td style="text-align: right">Residuals at each horizon</td></tr><tr><td style="text-align: right"><code>vcov</code></td><td style="text-align: right"><code>Vector{Matrix{T}}</code></td><td style="text-align: right">Variance-covariance matrices</td></tr><tr><td style="text-align: right"><code>first_stage_F</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">First-stage F-statistics by horizon</td></tr><tr><td style="text-align: right"><code>first_stage_coef</code></td><td style="text-align: right"><code>Vector{Vector{T}}</code></td><td style="text-align: right">First-stage instrument coefficients</td></tr><tr><td style="text-align: right"><code>T_eff</code></td><td style="text-align: right"><code>Vector{Int}</code></td><td style="text-align: right">Effective sample sizes</td></tr><tr><td style="text-align: right"><code>cov_estimator</code></td><td style="text-align: right"><code>AbstractCovarianceEstimator</code></td><td style="text-align: right">Covariance estimator used</td></tr></table><hr/><h2 id="Smooth-Local-Projections"><a class="docs-heading-anchor" href="#Smooth-Local-Projections">Smooth Local Projections</a><a id="Smooth-Local-Projections-1"></a><a class="docs-heading-anchor-permalink" href="#Smooth-Local-Projections" title="Permalink"></a></h2><h3 id="Motivation-2"><a class="docs-heading-anchor" href="#Motivation-2">Motivation</a><a class="docs-heading-anchor-permalink" href="#Motivation-2" title="Permalink"></a></h3><p>Standard LPs can produce noisy, erratic impulse responses because each horizon is estimated independently. Barnichon &amp; Brownlees (2019) propose <strong>Smooth Local Projections</strong> that parameterize the IRF as a smooth function of the horizon using B-spline basis functions.</p><h3 id="B-Spline-Representation"><a class="docs-heading-anchor" href="#B-Spline-Representation">B-Spline Representation</a><a id="B-Spline-Representation-1"></a><a class="docs-heading-anchor-permalink" href="#B-Spline-Representation" title="Permalink"></a></h3><p>The impulse response is modeled as:</p><p class="math-container">\[\beta(h) = \sum_{j=1}^{J} \theta_j B_j(h)\]</p><p>where <span>$B_j(h)$</span> are B-spline basis functions and <span>$\theta_j$</span> are spline coefficients.</p><h3 id="Cubic-B-Splines"><a class="docs-heading-anchor" href="#Cubic-B-Splines">Cubic B-Splines</a><a id="Cubic-B-Splines-1"></a><a class="docs-heading-anchor-permalink" href="#Cubic-B-Splines" title="Permalink"></a></h3><p>For degree <span>$d = 3$</span> (cubic splines), the basis functions are computed recursively using the Cox-de Boor formula:</p><p class="math-container">\[B_{i,0}(x) = \begin{cases} 1 &amp; \text{if } t_i \leq x &lt; t_{i+1} \\ 0 &amp; \text{otherwise} \end{cases}\]</p><p class="math-container">\[B_{i,d}(x) = \frac{x - t_i}{t_{i+d} - t_i} B_{i,d-1}(x) + \frac{t_{i+d+1} - x}{t_{i+d+1} - t_{i+1}} B_{i+1,d-1}(x)\]</p><h3 id="Smoothness-Penalty"><a class="docs-heading-anchor" href="#Smoothness-Penalty">Smoothness Penalty</a><a id="Smoothness-Penalty-1"></a><a class="docs-heading-anchor-permalink" href="#Smoothness-Penalty" title="Permalink"></a></h3><p>To enforce smoothness, we add a roughness penalty on the second derivative:</p><p class="math-container">\[\min_{\theta} \sum_{h=0}^{H} \left( \hat{\beta}_h - B(h)&#39;\theta \right)^2 + \lambda \int \left( \beta&#39;&#39;(h) \right)^2 dh\]</p><p>The penalty is computed as <span>$\theta&#39; R \theta$</span> where:</p><p class="math-container">\[R_{ij} = \int B&#39;&#39;_i(x) B&#39;&#39;_j(x) dx\]</p><h3 id="Two-Step-Estimation"><a class="docs-heading-anchor" href="#Two-Step-Estimation">Two-Step Estimation</a><a id="Two-Step-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Two-Step-Estimation" title="Permalink"></a></h3><ol><li>Estimate standard LP to get <span>$\hat{\beta}_h$</span> and <span>$\text{Var}(\hat{\beta}_h)$</span></li><li>Fit weighted penalized spline:</li></ol><p class="math-container">\[\hat{\theta} = \left( B&#39;WB + \lambda R \right)^{-1} B&#39;W \hat{\beta}\]</p><p>where <span>$W = \text{diag}(1/\text{Var}(\hat{\beta}_h))$</span></p><h3 id="Cross-Validation-for-λ-Selection"><a class="docs-heading-anchor" href="#Cross-Validation-for-λ-Selection">Cross-Validation for λ Selection</a><a id="Cross-Validation-for-λ-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#Cross-Validation-for-λ-Selection" title="Permalink"></a></h3><p>The smoothing parameter <span>$\lambda$</span> can be selected by k-fold cross-validation to minimize out-of-sample prediction error.</p><p><strong>Reference</strong>: Barnichon &amp; Brownlees (2019)</p><h3 id="Julia-Implementation-3"><a class="docs-heading-anchor" href="#Julia-Implementation-3">Julia Implementation</a><a class="docs-heading-anchor-permalink" href="#Julia-Implementation-3" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MacroEconometricModels

# Smooth LP with cubic splines
smooth_model = estimate_smooth_lp(Y, shock_var, H;
    degree = 3,           # Cubic splines
    n_knots = 4,          # Interior knots
    lambda = 1.0,         # Smoothing penalty
    lags = 4
)

# Automatic lambda selection via CV
optimal_lambda = cross_validate_lambda(Y, shock_var, H;
    lambda_grid = 10.0 .^ (-4:0.5:2),
    k_folds = 5
)

# Compare smooth vs standard LP
comparison = compare_smooth_lp(Y, shock_var, H; lambda = optimal_lambda)
println(&quot;Variance reduction: &quot;, comparison.variance_reduction)</code></pre><h3 id="SmoothLPModel-Return-Values"><a class="docs-heading-anchor" href="#SmoothLPModel-Return-Values">SmoothLPModel Return Values</a><a id="SmoothLPModel-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#SmoothLPModel-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>Y</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">Original data matrix</td></tr><tr><td style="text-align: right"><code>shock_var</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Shock variable index</td></tr><tr><td style="text-align: right"><code>response_vars</code></td><td style="text-align: right"><code>Vector{Int}</code></td><td style="text-align: right">Response variable indices</td></tr><tr><td style="text-align: right"><code>horizon</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Maximum horizon</td></tr><tr><td style="text-align: right"><code>lags</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of control lags</td></tr><tr><td style="text-align: right"><code>spline_basis</code></td><td style="text-align: right"><code>BSplineBasis{T}</code></td><td style="text-align: right">B-spline basis (knots, degree, basis matrix)</td></tr><tr><td style="text-align: right"><code>theta</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">Spline coefficients</td></tr><tr><td style="text-align: right"><code>vcov_theta</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">Variance-covariance of spline coefficients</td></tr><tr><td style="text-align: right"><code>lambda</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Smoothing penalty parameter</td></tr><tr><td style="text-align: right"><code>irf_values</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">Smoothed IRF point estimates</td></tr><tr><td style="text-align: right"><code>irf_se</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">Standard errors of smoothed IRF</td></tr><tr><td style="text-align: right"><code>residuals</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">Regression residuals</td></tr><tr><td style="text-align: right"><code>T_eff</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Effective sample size</td></tr><tr><td style="text-align: right"><code>cov_estimator</code></td><td style="text-align: right"><code>AbstractCovarianceEstimator</code></td><td style="text-align: right">Covariance estimator used</td></tr></table><hr/><h2 id="State-Dependent-Local-Projections"><a class="docs-heading-anchor" href="#State-Dependent-Local-Projections">State-Dependent Local Projections</a><a id="State-Dependent-Local-Projections-1"></a><a class="docs-heading-anchor-permalink" href="#State-Dependent-Local-Projections" title="Permalink"></a></h2><h3 id="Motivation-3"><a class="docs-heading-anchor" href="#Motivation-3">Motivation</a><a class="docs-heading-anchor-permalink" href="#Motivation-3" title="Permalink"></a></h3><p>Economic responses may differ across states of the economy (e.g., recessions vs. expansions). Auerbach &amp; Gorodnichenko (2012, 2013) develop <strong>state-dependent LPs</strong> using smooth transition functions.</p><h3 id="The-State-Dependent-Model"><a class="docs-heading-anchor" href="#The-State-Dependent-Model">The State-Dependent Model</a><a id="The-State-Dependent-Model-1"></a><a class="docs-heading-anchor-permalink" href="#The-State-Dependent-Model" title="Permalink"></a></h3><p class="math-container">\[y_{t+h} = F(z_t) \left[ \alpha_E + \beta_E x_t + \gamma_E&#39; w_t \right] + (1 - F(z_t)) \left[ \alpha_R + \beta_R x_t + \gamma_R&#39; w_t \right] + \varepsilon_{t+h}\]</p><p>where:</p><ul><li><span>$F(z_t)$</span> is the smooth transition function</li><li><span>$z_t$</span> is the state variable (e.g., moving average of GDP growth)</li><li>Subscript <span>$E$</span> denotes &quot;expansion&quot; regime (<span>$F \to 0$</span>)</li><li>Subscript <span>$R$</span> denotes &quot;recession&quot; regime (<span>$F \to 1$</span>)</li></ul><h3 id="Logistic-Transition-Function"><a class="docs-heading-anchor" href="#Logistic-Transition-Function">Logistic Transition Function</a><a id="Logistic-Transition-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Logistic-Transition-Function" title="Permalink"></a></h3><p>The standard specification uses a logistic function:</p><p class="math-container">\[F(z_t) = \frac{\exp(-\gamma(z_t - c))}{1 + \exp(-\gamma(z_t - c))}\]</p><p>where:</p><ul><li><span>$\gamma &gt; 0$</span> controls the transition speed (higher = sharper)</li><li><span>$c$</span> is the threshold (often set to 0 for standardized <span>$z_t$</span>)</li></ul><p><strong>Properties</strong>:</p><ul><li><span>$F(z) \to 1$</span> as <span>$z \to -\infty$</span> (deep recession)</li><li><span>$F(z) \to 0$</span> as <span>$z \to +\infty$</span> (strong expansion)</li><li><span>$F(c) = 0.5$</span> (neutral state)</li></ul><h3 id="State-Variable-Construction"><a class="docs-heading-anchor" href="#State-Variable-Construction">State Variable Construction</a><a id="State-Variable-Construction-1"></a><a class="docs-heading-anchor-permalink" href="#State-Variable-Construction" title="Permalink"></a></h3><p>Following Auerbach &amp; Gorodnichenko, the state variable is typically:</p><p class="math-container">\[z_t = \frac{1}{k} \sum_{j=0}^{k-1} \Delta y_{t-j}\]</p><p>A <span>$k = 7$</span> quarter moving average of GDP growth is common, then standardized to have zero mean and unit variance.</p><h3 id="Estimation-2"><a class="docs-heading-anchor" href="#Estimation-2">Estimation</a><a class="docs-heading-anchor-permalink" href="#Estimation-2" title="Permalink"></a></h3><p>The model is estimated by nonlinear least squares or by treating it as a linear regression in the interaction terms. The parameters <span>$(\gamma, c)$</span> can be:</p><ol><li>Fixed based on prior research</li><li>Estimated via grid search or NLS</li><li>Selected to maximize fit</li></ol><h3 id="Testing-for-Regime-Differences"><a class="docs-heading-anchor" href="#Testing-for-Regime-Differences">Testing for Regime Differences</a><a id="Testing-for-Regime-Differences-1"></a><a class="docs-heading-anchor-permalink" href="#Testing-for-Regime-Differences" title="Permalink"></a></h3><p>Test whether responses differ across regimes:</p><p class="math-container">\[H_0: \beta_E - \beta_R = 0\]</p><p>using a t-test with HAC standard errors:</p><p class="math-container">\[t = \frac{\hat{\beta}_E - \hat{\beta}_R}{\sqrt{\text{Var}(\hat{\beta}_E) + \text{Var}(\hat{\beta}_R) - 2\text{Cov}(\hat{\beta}_E, \hat{\beta}_R)}}\]</p><p><strong>Reference</strong>: Auerbach &amp; Gorodnichenko (2012, 2013), Ramey &amp; Zubairy (2018)</p><h3 id="Julia-Implementation-4"><a class="docs-heading-anchor" href="#Julia-Implementation-4">Julia Implementation</a><a class="docs-heading-anchor-permalink" href="#Julia-Implementation-4" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MacroEconometricModels

# Construct state variable (e.g., 7-quarter MA of GDP growth)
gdp_growth = diff(log.(Y[:, 1]))
state_var = [mean(gdp_growth[max(1, t-6):t]) for t in 1:length(gdp_growth)]
state_var = (state_var .- mean(state_var)) ./ std(state_var)

# Estimate state-dependent LP
state_model = estimate_state_lp(Y, shock_var, state_var, H;
    gamma = :estimate,      # Estimate transition speed
    threshold = :median,    # Set threshold at median
    lags = 4
)

# Extract regime-specific IRFs
irf_both = state_irf(state_model; regime = :both)
irf_expansion = state_irf(state_model; regime = :expansion)
irf_recession = state_irf(state_model; regime = :recession)

# Test for regime differences
diff_test = test_regime_difference(state_model)</code></pre><h3 id="StateLPModel-Return-Values"><a class="docs-heading-anchor" href="#StateLPModel-Return-Values">StateLPModel Return Values</a><a id="StateLPModel-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#StateLPModel-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>Y</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">Original data matrix</td></tr><tr><td style="text-align: right"><code>shock_var</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Shock variable index</td></tr><tr><td style="text-align: right"><code>response_vars</code></td><td style="text-align: right"><code>Vector{Int}</code></td><td style="text-align: right">Response variable indices</td></tr><tr><td style="text-align: right"><code>horizon</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Maximum horizon</td></tr><tr><td style="text-align: right"><code>lags</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of control lags</td></tr><tr><td style="text-align: right"><code>state</code></td><td style="text-align: right"><code>StateTransition{T}</code></td><td style="text-align: right">State transition function (<span>$\gamma$</span>, threshold, <span>$F(z_t)$</span> values)</td></tr><tr><td style="text-align: right"><code>B_expansion</code></td><td style="text-align: right"><code>Vector{Matrix{T}}</code></td><td style="text-align: right">Expansion regime coefficients</td></tr><tr><td style="text-align: right"><code>B_recession</code></td><td style="text-align: right"><code>Vector{Matrix{T}}</code></td><td style="text-align: right">Recession regime coefficients</td></tr><tr><td style="text-align: right"><code>residuals</code></td><td style="text-align: right"><code>Vector{Matrix{T}}</code></td><td style="text-align: right">Residuals at each horizon</td></tr><tr><td style="text-align: right"><code>vcov_expansion</code></td><td style="text-align: right"><code>Vector{Matrix{T}}</code></td><td style="text-align: right">Expansion regime variance-covariance</td></tr><tr><td style="text-align: right"><code>vcov_recession</code></td><td style="text-align: right"><code>Vector{Matrix{T}}</code></td><td style="text-align: right">Recession regime variance-covariance</td></tr><tr><td style="text-align: right"><code>vcov_diff</code></td><td style="text-align: right"><code>Vector{Matrix{T}}</code></td><td style="text-align: right">Variance-covariance of regime difference</td></tr><tr><td style="text-align: right"><code>T_eff</code></td><td style="text-align: right"><code>Vector{Int}</code></td><td style="text-align: right">Effective sample sizes</td></tr><tr><td style="text-align: right"><code>cov_estimator</code></td><td style="text-align: right"><code>AbstractCovarianceEstimator</code></td><td style="text-align: right">Covariance estimator used</td></tr></table><hr/><h2 id="Propensity-Score-Local-Projections"><a class="docs-heading-anchor" href="#Propensity-Score-Local-Projections">Propensity Score Local Projections</a><a id="Propensity-Score-Local-Projections-1"></a><a class="docs-heading-anchor-permalink" href="#Propensity-Score-Local-Projections" title="Permalink"></a></h2><h3 id="Motivation-4"><a class="docs-heading-anchor" href="#Motivation-4">Motivation</a><a class="docs-heading-anchor-permalink" href="#Motivation-4" title="Permalink"></a></h3><p>When the shock is a discrete treatment (e.g., policy intervention), selection bias may confound causal inference. Angrist, Jordà &amp; Kuersteiner (2018) develop <strong>LP with inverse propensity weighting (IPW)</strong> to address selection.</p><h3 id="The-Setup"><a class="docs-heading-anchor" href="#The-Setup">The Setup</a><a id="The-Setup-1"></a><a class="docs-heading-anchor-permalink" href="#The-Setup" title="Permalink"></a></h3><p>Let <span>$D_t \in \{0, 1\}$</span> be a binary treatment indicator. We want to estimate the Average Treatment Effect (ATE):</p><p class="math-container">\[\text{ATE}_h = E[y_{t+h}(1) - y_{t+h}(0)]\]</p><p>where <span>$y_{t+h}(d)$</span> is the potential outcome under treatment status <span>$d$</span>.</p><h3 id="Propensity-Score"><a class="docs-heading-anchor" href="#Propensity-Score">Propensity Score</a><a id="Propensity-Score-1"></a><a class="docs-heading-anchor-permalink" href="#Propensity-Score" title="Permalink"></a></h3><p>The propensity score is the probability of treatment given covariates:</p><p class="math-container">\[p(X_t) = P(D_t = 1 | X_t)\]</p><p>estimated via logit or probit:</p><p class="math-container">\[p(X_t) = \frac{1}{1 + \exp(-X_t&#39;\beta)}\]</p><h3 id="Inverse-Propensity-Weighting-(IPW)"><a class="docs-heading-anchor" href="#Inverse-Propensity-Weighting-(IPW)">Inverse Propensity Weighting (IPW)</a><a id="Inverse-Propensity-Weighting-(IPW)-1"></a><a class="docs-heading-anchor-permalink" href="#Inverse-Propensity-Weighting-(IPW)" title="Permalink"></a></h3><p>The IPW estimator weights observations by the inverse of their selection probability:</p><ul><li>Treated: weight <span>$= 1/p(X_t)$</span></li><li>Control: weight <span>$= 1/(1-p(X_t))$</span></li></ul><p>This reweighting creates a pseudo-population where treatment is independent of covariates.</p><h3 id="IPW-LP-Estimation"><a class="docs-heading-anchor" href="#IPW-LP-Estimation">IPW-LP Estimation</a><a id="IPW-LP-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#IPW-LP-Estimation" title="Permalink"></a></h3><p>At each horizon <span>$h$</span>:</p><p class="math-container">\[\hat{\text{ATE}}_h = \frac{1}{n} \sum_{t: D_t=1} \frac{y_{t+h}}{\hat{p}(X_t)} - \frac{1}{n} \sum_{t: D_t=0} \frac{y_{t+h}}{1-\hat{p}(X_t)}\]</p><p>Or via weighted regression:</p><p class="math-container">\[y_{t+h} = \alpha_h + \beta_h D_t + \gamma_h&#39; X_t + \varepsilon_{t+h}\]</p><p>estimated by WLS with IPW weights.</p><h3 id="Doubly-Robust-Estimation"><a class="docs-heading-anchor" href="#Doubly-Robust-Estimation">Doubly Robust Estimation</a><a id="Doubly-Robust-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Doubly-Robust-Estimation" title="Permalink"></a></h3><p>The doubly robust (DR) estimator combines IPW with outcome regression:</p><p class="math-container">\[\hat{\text{ATE}}^{DR}_h = \frac{1}{n} \sum_t \left[ \frac{D_t(y_{t+h} - \mu_1(X_t))}{\hat{p}(X_t)} + \mu_1(X_t) \right] - \frac{1}{n} \sum_t \left[ \frac{(1-D_t)(y_{t+h} - \mu_0(X_t))}{1-\hat{p}(X_t)} + \mu_0(X_t) \right]\]</p><p>where <span>$\mu_d(X_t) = E[y_{t+h} | D_t = d, X_t]$</span> is the outcome regression.</p><p><strong>Property</strong>: DR is consistent if either the propensity score or the outcome model is correctly specified.</p><h3 id="Practical-Considerations"><a class="docs-heading-anchor" href="#Practical-Considerations">Practical Considerations</a><a id="Practical-Considerations-1"></a><a class="docs-heading-anchor-permalink" href="#Practical-Considerations" title="Permalink"></a></h3><ol><li><strong>Trimming</strong>: Propensity scores near 0 or 1 lead to extreme weights. Trim at [0.01, 0.99].</li><li><strong>Overlap</strong>: Verify that treated and control groups have overlapping covariate distributions.</li><li><strong>Balance</strong>: Check that covariates are balanced after reweighting (standardized mean differences &lt; 0.1).</li></ol><p><strong>Reference</strong>: Angrist, Jordà &amp; Kuersteiner (2018), Hirano, Imbens &amp; Ridder (2003)</p><h3 id="Julia-Implementation-5"><a class="docs-heading-anchor" href="#Julia-Implementation-5">Julia Implementation</a><a class="docs-heading-anchor-permalink" href="#Julia-Implementation-5" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MacroEconometricModels

# treatment: Bool vector of treatment indicators
# covariates: matrix of selection-relevant covariates

# IPW estimation
prop_model = estimate_propensity_lp(Y, treatment, covariates, H;
    ps_method = :logit,
    trimming = (0.01, 0.99),
    lags = 4
)

# Doubly robust estimation
dr_model = doubly_robust_lp(Y, treatment, covariates, H)

# Extract ATE impulse response
ate_irf = propensity_irf(prop_model)

# Diagnostics
diagnostics = propensity_diagnostics(prop_model)
println(&quot;Propensity score overlap: &quot;, diagnostics.overlap)
println(&quot;Max covariate imbalance: &quot;, diagnostics.balance.max_weighted)</code></pre><h3 id="PropensityLPModel-Return-Values"><a class="docs-heading-anchor" href="#PropensityLPModel-Return-Values">PropensityLPModel Return Values</a><a id="PropensityLPModel-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#PropensityLPModel-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>Y</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">Original data matrix</td></tr><tr><td style="text-align: right"><code>treatment</code></td><td style="text-align: right"><code>Vector{Bool}</code></td><td style="text-align: right">Binary treatment indicator</td></tr><tr><td style="text-align: right"><code>response_vars</code></td><td style="text-align: right"><code>Vector{Int}</code></td><td style="text-align: right">Response variable indices</td></tr><tr><td style="text-align: right"><code>covariates</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">Selection-relevant covariates</td></tr><tr><td style="text-align: right"><code>horizon</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Maximum horizon</td></tr><tr><td style="text-align: right"><code>propensity_scores</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Estimated propensity scores <span>$\hat{p}(X_t)$</span></td></tr><tr><td style="text-align: right"><code>ipw_weights</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Inverse propensity weights</td></tr><tr><td style="text-align: right"><code>B</code></td><td style="text-align: right"><code>Vector{Matrix{T}}</code></td><td style="text-align: right">Weighted regression coefficients</td></tr><tr><td style="text-align: right"><code>residuals</code></td><td style="text-align: right"><code>Vector{Matrix{T}}</code></td><td style="text-align: right">Weighted residuals</td></tr><tr><td style="text-align: right"><code>vcov</code></td><td style="text-align: right"><code>Vector{Matrix{T}}</code></td><td style="text-align: right">Variance-covariance matrices</td></tr><tr><td style="text-align: right"><code>ate</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">Average treatment effect estimates</td></tr><tr><td style="text-align: right"><code>ate_se</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">Standard errors of ATE</td></tr><tr><td style="text-align: right"><code>config</code></td><td style="text-align: right"><code>PropensityScoreConfig{T}</code></td><td style="text-align: right">Configuration (method, trimming, normalize)</td></tr><tr><td style="text-align: right"><code>T_eff</code></td><td style="text-align: right"><code>Vector{Int}</code></td><td style="text-align: right">Effective sample sizes</td></tr><tr><td style="text-align: right"><code>cov_estimator</code></td><td style="text-align: right"><code>AbstractCovarianceEstimator</code></td><td style="text-align: right">Covariance estimator used</td></tr></table><hr/><h2 id="Comparing-LP-and-VAR"><a class="docs-heading-anchor" href="#Comparing-LP-and-VAR">Comparing LP and VAR</a><a id="Comparing-LP-and-VAR-1"></a><a class="docs-heading-anchor-permalink" href="#Comparing-LP-and-VAR" title="Permalink"></a></h2><h3 id="LP-vs.-VAR-Trade-offs"><a class="docs-heading-anchor" href="#LP-vs.-VAR-Trade-offs">LP vs. VAR Trade-offs</a><a id="LP-vs.-VAR-Trade-offs-1"></a><a class="docs-heading-anchor-permalink" href="#LP-vs.-VAR-Trade-offs" title="Permalink"></a></h3><table><tr><th style="text-align: right">Aspect</th><th style="text-align: right">VAR</th><th style="text-align: right">Local Projections</th></tr><tr><td style="text-align: right"><strong>Efficiency</strong></td><td style="text-align: right">More efficient if correctly specified</td><td style="text-align: right">Less efficient, but robust</td></tr><tr><td style="text-align: right"><strong>Bias</strong></td><td style="text-align: right">Biased if dynamics misspecified</td><td style="text-align: right">Consistent under weak conditions</td></tr><tr><td style="text-align: right"><strong>Long horizons</strong></td><td style="text-align: right">Compounds specification error</td><td style="text-align: right">Each horizon estimated directly</td></tr><tr><td style="text-align: right"><strong>Nonlinearities</strong></td><td style="text-align: right">Requires extensions</td><td style="text-align: right">Easy to incorporate</td></tr><tr><td style="text-align: right"><strong>External instruments</strong></td><td style="text-align: right">SVAR-IV</td><td style="text-align: right">LP-IV</td></tr></table><h3 id="Asymptotic-Equivalence"><a class="docs-heading-anchor" href="#Asymptotic-Equivalence">Asymptotic Equivalence</a><a id="Asymptotic-Equivalence-1"></a><a class="docs-heading-anchor-permalink" href="#Asymptotic-Equivalence" title="Permalink"></a></h3><p>Plagborg-Møller &amp; Wolf (2021) show that under correct specification, LP and VAR IRFs are asymptotically equivalent:</p><p class="math-container">\[\sqrt{T}(\hat{\beta}_h^{LP} - \beta_h) \xrightarrow{d} N(0, V^{LP})\]</p><p class="math-container">\[\sqrt{T}(\hat{\theta}_h^{VAR} - \theta_h) \xrightarrow{d} N(0, V^{VAR})\]</p><p>with <span>$V^{LP} \geq V^{VAR}$</span> (VAR is weakly more efficient).</p><h3 id="When-to-Use-LP"><a class="docs-heading-anchor" href="#When-to-Use-LP">When to Use LP</a><a id="When-to-Use-LP-1"></a><a class="docs-heading-anchor-permalink" href="#When-to-Use-LP" title="Permalink"></a></h3><ul><li>Concerned about VAR misspecification</li><li>Need to incorporate external instruments</li><li>Interested in nonlinear/state-dependent responses</li><li>Working with discrete treatments</li><li>Long horizons where VAR error compounds</li></ul><p><strong>Reference</strong>: Plagborg-Møller &amp; Wolf (2021)</p><hr/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><h3 id="Local-Projections-Core"><a class="docs-heading-anchor" href="#Local-Projections-Core">Local Projections - Core</a><a id="Local-Projections-Core-1"></a><a class="docs-heading-anchor-permalink" href="#Local-Projections-Core" title="Permalink"></a></h3><ul><li>Jordà, Òscar. 2005. &quot;Estimation and Inference of Impulse Responses by Local Projections.&quot; <em>American Economic Review</em> 95 (1): 161–182. <a href="https://doi.org/10.1257/0002828053828518">https://doi.org/10.1257/0002828053828518</a></li><li>Plagborg-Møller, Mikkel, and Christian K. Wolf. 2021. &quot;Local Projections and VARs Estimate the Same Impulse Responses.&quot; <em>Econometrica</em> 89 (2): 955–980. <a href="https://doi.org/10.3982/ECTA17813">https://doi.org/10.3982/ECTA17813</a></li></ul><h3 id="LP-IV"><a class="docs-heading-anchor" href="#LP-IV">LP-IV</a><a id="LP-IV-1"></a><a class="docs-heading-anchor-permalink" href="#LP-IV" title="Permalink"></a></h3><ul><li>Stock, James H., and Mark W. Watson. 2018. &quot;Identification and Estimation of Dynamic Causal Effects in Macroeconomics Using External Instruments.&quot; <em>Economic Journal</em> 128 (610): 917–948. <a href="https://doi.org/10.1111/ecoj.12593">https://doi.org/10.1111/ecoj.12593</a></li><li>Stock, James H., and Motohiro Yogo. 2005. &quot;Testing for Weak Instruments in Linear IV Regression.&quot; In <em>Identification and Inference for Econometric Models: Essays in Honor of Thomas Rothenberg</em>, edited by Donald W. K. Andrews and James H. Stock, 80–108. Cambridge: Cambridge University Press.</li></ul><h3 id="Smooth-LP"><a class="docs-heading-anchor" href="#Smooth-LP">Smooth LP</a><a id="Smooth-LP-1"></a><a class="docs-heading-anchor-permalink" href="#Smooth-LP" title="Permalink"></a></h3><ul><li>Barnichon, Regis, and Christian Brownlees. 2019. &quot;Impulse Response Estimation by Smooth Local Projections.&quot; <em>Review of Economics and Statistics</em> 101 (3): 522–530. <a href="https://doi.org/10.1162/rest_a_00778">https://doi.org/10.1162/rest<em>a</em>00778</a></li></ul><h3 id="State-Dependent-LP"><a class="docs-heading-anchor" href="#State-Dependent-LP">State-Dependent LP</a><a id="State-Dependent-LP-1"></a><a class="docs-heading-anchor-permalink" href="#State-Dependent-LP" title="Permalink"></a></h3><ul><li>Auerbach, Alan J., and Yuriy Gorodnichenko. 2012. &quot;Measuring the Output Responses to Fiscal Policy.&quot; <em>American Economic Journal: Economic Policy</em> 4 (2): 1–27. <a href="https://doi.org/10.1257/pol.4.2.1">https://doi.org/10.1257/pol.4.2.1</a></li><li>Auerbach, Alan J., and Yuriy Gorodnichenko. 2013. &quot;Fiscal Multipliers in Recession and Expansion.&quot; In <em>Fiscal Policy after the Financial Crisis</em>, edited by Alberto Alesina and Francesco Giavazzi, 63–98. Chicago: University of Chicago Press. <a href="https://doi.org/10.7208/9780226018584-004">https://doi.org/10.7208/9780226018584-004</a></li><li>Ramey, Valerie A., and Sarah Zubairy. 2018. &quot;Government Spending Multipliers in Good Times and in Bad: Evidence from US Historical Data.&quot; <em>Journal of Political Economy</em> 126 (2): 850–901. <a href="https://doi.org/10.1086/696277">https://doi.org/10.1086/696277</a></li></ul><h3 id="Propensity-Score-Methods"><a class="docs-heading-anchor" href="#Propensity-Score-Methods">Propensity Score Methods</a><a id="Propensity-Score-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Propensity-Score-Methods" title="Permalink"></a></h3><ul><li>Angrist, Joshua D., Òscar Jordà, and Guido M. Kuersteiner. 2018. &quot;Semiparametric Estimates of Monetary Policy Effects: String Theory Revisited.&quot; <em>Journal of Business &amp; Economic Statistics</em> 36 (3): 371–387. <a href="https://doi.org/10.1080/07350015.2016.1204919">https://doi.org/10.1080/07350015.2016.1204919</a></li><li>Hirano, Keisuke, Guido W. Imbens, and Geert Ridder. 2003. &quot;Efficient Estimation of Average Treatment Effects Using the Estimated Propensity Score.&quot; <em>Econometrica</em> 71 (4): 1161–1189. <a href="https://doi.org/10.1111/1468-0262.00442">https://doi.org/10.1111/1468-0262.00442</a></li></ul><h3 id="Inference"><a class="docs-heading-anchor" href="#Inference">Inference</a><a id="Inference-1"></a><a class="docs-heading-anchor-permalink" href="#Inference" title="Permalink"></a></h3><ul><li>Newey, Whitney K., and Kenneth D. West. 1987. &quot;A Simple, Positive Semi-Definite, Heteroskedasticity and Autocorrelation Consistent Covariance Matrix.&quot; <em>Econometrica</em> 55 (3): 703–708. <a href="https://doi.org/10.2307/1913610">https://doi.org/10.2307/1913610</a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../manual/">« VAR</a><a class="docs-footer-nextpage" href="../factormodels/">Factor Models »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 6 February 2026 03:03">Friday 6 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
