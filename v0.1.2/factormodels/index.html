<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Factor Models · MacroEconometricModels.jl</title><meta name="title" content="Factor Models · MacroEconometricModels.jl"/><meta property="og:title" content="Factor Models · MacroEconometricModels.jl"/><meta property="twitter:title" content="Factor Models · MacroEconometricModels.jl"/><meta name="description" content="Documentation for MacroEconometricModels.jl."/><meta property="og:description" content="Documentation for MacroEconometricModels.jl."/><meta property="twitter:description" content="Documentation for MacroEconometricModels.jl."/><meta property="og:url" content="https://chung9207.github.io/MacroEconometricModels.jl/factormodels/"/><meta property="twitter:url" content="https://chung9207.github.io/MacroEconometricModels.jl/factormodels/"/><link rel="canonical" href="https://chung9207.github.io/MacroEconometricModels.jl/factormodels/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MacroEconometricModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Univariate Models</span><ul><li><a class="tocitem" href="../arima/">ARIMA</a></li></ul></li><li><span class="tocitem">Frequentist Models</span><ul><li><a class="tocitem" href="../manual/">VAR</a></li><li><a class="tocitem" href="../lp/">Local Projections</a></li><li class="is-active"><a class="tocitem" href>Factor Models</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Quick-Start"><span>Quick Start</span></a></li><li><a class="tocitem" href="#The-Static-Factor-Model"><span>The Static Factor Model</span></a></li><li><a class="tocitem" href="#Estimation-via-Principal-Components"><span>Estimation via Principal Components</span></a></li><li><a class="tocitem" href="#Determining-the-Number-of-Factors"><span>Determining the Number of Factors</span></a></li><li><a class="tocitem" href="#Scree-Plot-Analysis"><span>Scree Plot Analysis</span></a></li><li><a class="tocitem" href="#Model-Diagnostics"><span>Model Diagnostics</span></a></li><li><a class="tocitem" href="#Applications"><span>Applications</span></a></li><li><a class="tocitem" href="#Forecasting-with-Static-Factor-Models"><span>Forecasting with Static Factor Models</span></a></li><li><a class="tocitem" href="#Asymptotic-Theory"><span>Asymptotic Theory</span></a></li><li><a class="tocitem" href="#Comparison-with-Other-Methods"><span>Comparison with Other Methods</span></a></li><li><a class="tocitem" href="#Dynamic-Factor-Models"><span>Dynamic Factor Models</span></a></li><li><a class="tocitem" href="#Generalized-Dynamic-Factor-Model-(GDFM)"><span>Generalized Dynamic Factor Model (GDFM)</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li></ul></li><li><span class="tocitem">Bayesian Models</span><ul><li><a class="tocitem" href="../bayesian/">Bayesian VAR</a></li></ul></li><li><a class="tocitem" href="../nongaussian/">Non-Gaussian SVAR</a></li><li><a class="tocitem" href="../innovation_accounting/">Innovation Accounting</a></li><li><span class="tocitem">Hypothesis Tests</span><ul><li><a class="tocitem" href="../hypothesis_tests/">Unit Root &amp; Cointegration</a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../api/">Overview</a></li><li><a class="tocitem" href="../api_types/">Types</a></li><li><a class="tocitem" href="../api_functions/">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Frequentist Models</a></li><li class="is-active"><a href>Factor Models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Factor Models</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/chung9207/MacroEconometricModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/main/docs/src/factormodels.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Factor-Models"><a class="docs-heading-anchor" href="#Factor-Models">Factor Models</a><a id="Factor-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Factor-Models" title="Permalink"></a></h1><p>This chapter covers static factor models for dimensionality reduction in large macroeconomic panels, including estimation via principal components and information criteria for selecting the number of factors.</p><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>Factor models are fundamental tools in macroeconometrics for extracting common sources of variation from large panels of economic indicators. They enable:</p><ol><li><strong>Dimensionality Reduction</strong>: Summarize <span>$N$</span> variables with <span>$r \ll N$</span> factors</li><li><strong>Forecasting</strong>: Use factors as predictors in regressions (diffusion indices)</li><li><strong>Structural Analysis</strong>: Identify common shocks driving multiple series</li><li><strong>FAVAR</strong>: Combine factors with VARs for high-dimensional structural analysis</li></ol><p><strong>Reference</strong>: Stock &amp; Watson (2002a, 2002b), Bai &amp; Ng (2002)</p><h2 id="Quick-Start"><a class="docs-heading-anchor" href="#Quick-Start">Quick Start</a><a id="Quick-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Start" title="Permalink"></a></h2><pre><code class="language-julia hljs">fm = estimate_factors(X, r; standardize=true)                       # Static factor model via PCA
ic = ic_criteria(X, 10)                                             # Bai-Ng IC for factor count
dfm = estimate_dynamic_factors(X, r, p; method=:twostep)            # Dynamic factor model
gdfm = estimate_gdfm(X, q; kernel=:bartlett)                        # Generalized DFM (spectral)
fc = forecast(fm, h; ci_method=:theoretical)                        # Static FM forecast with analytical CIs
fc = forecast(dfm, h; ci_method=:bootstrap, n_boot=1000)            # DFM forecast with bootstrap CIs
fc = forecast(gdfm, h; ci_method=:theoretical)                      # GDFM forecast with analytical CIs</code></pre><hr/><h2 id="The-Static-Factor-Model"><a class="docs-heading-anchor" href="#The-Static-Factor-Model">The Static Factor Model</a><a id="The-Static-Factor-Model-1"></a><a class="docs-heading-anchor-permalink" href="#The-Static-Factor-Model" title="Permalink"></a></h2><h3 id="Model-Specification"><a class="docs-heading-anchor" href="#Model-Specification">Model Specification</a><a id="Model-Specification-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Specification" title="Permalink"></a></h3><p>The static factor model decomposes an <span>$N$</span>-dimensional vector of observables <span>$x_t$</span> into common and idiosyncratic components:</p><p class="math-container">\[x_{it} = \lambda_i&#39; F_t + e_{it}, \quad i = 1, \ldots, N, \quad t = 1, \ldots, T\]</p><p>In matrix form:</p><p class="math-container">\[X = F \Lambda&#39; + E\]</p><p>where:</p><ul><li><span>$X$</span> is the <span>$T \times N$</span> data matrix</li><li><span>$F$</span> is the <span>$T \times r$</span> matrix of latent factors</li><li><span>$\Lambda$</span> is the <span>$N \times r$</span> matrix of factor loadings</li><li><span>$E$</span> is the <span>$T \times N$</span> matrix of idiosyncratic errors</li><li><span>$r$</span> is the number of factors (with <span>$r \ll \min(T, N)$</span>)</li></ul><h3 id="Assumptions"><a class="docs-heading-anchor" href="#Assumptions">Assumptions</a><a id="Assumptions-1"></a><a class="docs-heading-anchor-permalink" href="#Assumptions" title="Permalink"></a></h3><p><strong>Factors and Loadings</strong>:</p><ul><li><span>$E[F_t] = 0$</span>, <span>$\text{Var}(F_t) = I_r$</span> (normalization)</li><li><span>$\frac{1}{T} \sum_t F_t F_t&#39; \xrightarrow{p} \Sigma_F$</span> positive definite</li><li><span>$\frac{1}{N} \Lambda&#39; \Lambda \xrightarrow{p} \Sigma_\Lambda$</span> positive definite</li></ul><p><strong>Idiosyncratic Errors</strong>:</p><ul><li><span>$E[e_{it}] = 0$</span></li><li>Weak cross-sectional and temporal dependence allowed</li><li>Weak correlation with factors: <span>$\frac{1}{NT} \sum_{i,t} |E[F_t e_{it}]| \to 0$</span></li></ul><p><strong>Reference</strong>: Bai &amp; Ng (2002), Bai (2003)</p><hr/><h2 id="Estimation-via-Principal-Components"><a class="docs-heading-anchor" href="#Estimation-via-Principal-Components">Estimation via Principal Components</a><a id="Estimation-via-Principal-Components-1"></a><a class="docs-heading-anchor-permalink" href="#Estimation-via-Principal-Components" title="Permalink"></a></h2><h3 id="Principal-Components-Analysis-(PCA)"><a class="docs-heading-anchor" href="#Principal-Components-Analysis-(PCA)">Principal Components Analysis (PCA)</a><a id="Principal-Components-Analysis-(PCA)-1"></a><a class="docs-heading-anchor-permalink" href="#Principal-Components-Analysis-(PCA)" title="Permalink"></a></h3><p>The factors and loadings are estimated by minimizing the sum of squared idiosyncratic errors:</p><p class="math-container">\[\min_{F, \Lambda} \sum_{i=1}^N \sum_{t=1}^T (x_{it} - \lambda_i&#39; F_t)^2\]</p><p>subject to the normalization <span>$F&#39;F/T = I_r$</span>.</p><h3 id="Solution"><a class="docs-heading-anchor" href="#Solution">Solution</a><a id="Solution-1"></a><a class="docs-heading-anchor-permalink" href="#Solution" title="Permalink"></a></h3><p>The solution involves the eigenvalue decomposition of <span>$X&#39;X$</span> (or <span>$XX&#39;$</span>):</p><p><strong>Case 1</strong>: <span>$T &lt; N$</span> (short panel)</p><ul><li>Compute <span>$XX&#39;$</span> (<span>$T \times T$</span> matrix)</li><li><span>$\hat{F} = \sqrt{T} \times$</span> (first <span>$r$</span> eigenvectors of <span>$XX&#39;$</span>)</li><li><span>$\hat{\Lambda} = X&#39; \hat{F} / T$</span></li></ul><p><strong>Case 2</strong>: <span>$N \leq T$</span> (tall panel)</p><ul><li>Compute <span>$X&#39;X$</span> (<span>$N \times N$</span> matrix)</li><li><span>$\hat{\Lambda} = \sqrt{N} \times$</span> (first <span>$r$</span> eigenvectors of <span>$X&#39;X$</span>)</li><li><span>$\hat{F} = X \hat{\Lambda} / N$</span></li></ul><h3 id="Data-Preprocessing"><a class="docs-heading-anchor" href="#Data-Preprocessing">Data Preprocessing</a><a id="Data-Preprocessing-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Preprocessing" title="Permalink"></a></h3><p>Before estimation, data is typically:</p><ol><li><strong>Demeaned</strong>: Center each series to have zero mean</li><li><strong>Standardized</strong>: Scale each series to have unit variance</li></ol><p>This prevents high-variance series from dominating the factor extraction.</p><h3 id="Identification"><a class="docs-heading-anchor" href="#Identification">Identification</a><a id="Identification-1"></a><a class="docs-heading-anchor-permalink" href="#Identification" title="Permalink"></a></h3><p>The factors and loadings are identified only up to an <span>$r \times r$</span> invertible rotation. If <span>$(F, \Lambda)$</span> is a solution, so is <span>$(FH, \Lambda H^{-1})$</span> for any invertible <span>$H$</span>.</p><p>The normalization <span>$F&#39;F/T = I_r$</span> and <span>$\Lambda&#39;\Lambda$</span> diagonal pins down rotation up to sign.</p><p><strong>Reference</strong>: Stock &amp; Watson (2002a), Bai &amp; Ng (2002)</p><h3 id="Julia-Implementation"><a class="docs-heading-anchor" href="#Julia-Implementation">Julia Implementation</a><a id="Julia-Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-Implementation" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MacroEconometricModels

# X is T×N data matrix
# Estimate r-factor model

model = estimate_factors(X, r;
    standardize = true,    # Standardize data
    method = :pca          # Principal components
)

# Access results
F = model.factors          # T×r estimated factors
Λ = model.loadings         # N×r estimated loadings</code></pre><h3 id="FactorModel-Return-Values"><a class="docs-heading-anchor" href="#FactorModel-Return-Values">FactorModel Return Values</a><a id="FactorModel-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#FactorModel-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>X</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">Original <span>$T \times N$</span> data matrix</td></tr><tr><td style="text-align: right"><code>factors</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$T \times r$</span> estimated factor matrix</td></tr><tr><td style="text-align: right"><code>loadings</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$N \times r$</span> estimated loading matrix</td></tr><tr><td style="text-align: right"><code>eigenvalues</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Eigenvalues from PCA (in descending order)</td></tr><tr><td style="text-align: right"><code>explained_variance</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Fraction of variance explained by each factor</td></tr><tr><td style="text-align: right"><code>cumulative_variance</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Cumulative fraction of variance explained</td></tr><tr><td style="text-align: right"><code>r</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of factors</td></tr><tr><td style="text-align: right"><code>standardized</code></td><td style="text-align: right"><code>Bool</code></td><td style="text-align: right">Whether data was standardized before estimation</td></tr></table><div class="admonition is-info" id="Technical-Note-17bc4edb5b445461"><header class="admonition-header">Technical Note<a class="admonition-anchor" href="#Technical-Note-17bc4edb5b445461" title="Permalink"></a></header><div class="admonition-body"><p>Factor models are identified only up to an <span>$r \times r$</span> rotation: if <span>$(\hat{F}, \hat{\Lambda})$</span> is a solution, then <span>$(\hat{F}H, \hat{\Lambda}H^{-1&#39;})$</span> is equally valid for any invertible <span>$H$</span>. The normalization <span>$F&#39;F/T = I_r$</span> pins down orientation but not sign. Consequently, individual factor loadings should not be interpreted as structural parameters. To compare estimated factors with &quot;true&quot; factors (e.g., in simulations), compute absolute correlations rather than raw correlations.</p></div></div><hr/><h2 id="Determining-the-Number-of-Factors"><a class="docs-heading-anchor" href="#Determining-the-Number-of-Factors">Determining the Number of Factors</a><a id="Determining-the-Number-of-Factors-1"></a><a class="docs-heading-anchor-permalink" href="#Determining-the-Number-of-Factors" title="Permalink"></a></h2><h3 id="The-Selection-Problem"><a class="docs-heading-anchor" href="#The-Selection-Problem">The Selection Problem</a><a id="The-Selection-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#The-Selection-Problem" title="Permalink"></a></h3><p>Choosing <span>$r$</span> is crucial:</p><ul><li>Too few factors: Omitted common variation, biased estimates</li><li>Too many factors: Overfitting, including noise as signal</li></ul><h3 id="Bai-and-Ng-(2002)-Information-Criteria"><a class="docs-heading-anchor" href="#Bai-and-Ng-(2002)-Information-Criteria">Bai &amp; Ng (2002) Information Criteria</a><a id="Bai-and-Ng-(2002)-Information-Criteria-1"></a><a class="docs-heading-anchor-permalink" href="#Bai-and-Ng-(2002)-Information-Criteria" title="Permalink"></a></h3><p>Bai &amp; Ng propose three information criteria:</p><p><strong>IC1</strong>:</p><p class="math-container">\[IC_1(r) = \log \hat{\sigma}^2(r) + r \cdot \frac{N + T}{NT} \log\left( \frac{NT}{N+T} \right)\]</p><p><strong>IC2</strong>:</p><p class="math-container">\[IC_2(r) = \log \hat{\sigma}^2(r) + r \cdot \frac{N + T}{NT} \log(C_{NT}^2)\]</p><p><strong>IC3</strong>:</p><p class="math-container">\[IC_3(r) = \log \hat{\sigma}^2(r) + r \cdot \frac{\log(C_{NT}^2)}{C_{NT}^2}\]</p><p>where:</p><ul><li><span>$\hat{\sigma}^2(r) = \frac{1}{NT} \sum_{i,t} \hat{e}_{it}^2$</span> is the average squared residual</li><li><span>$C_{NT}^2 = \min(N, T)$</span></li></ul><p><strong>Selection Rule</strong>: Choose <span>$\hat{r}$</span> that minimizes <span>$IC_k(r)$</span> over <span>$r \in \{1, \ldots, r_{max}\}$</span>.</p><p><strong>Properties</strong>:</p><ul><li>IC2 and IC3 perform best in simulations</li><li>All three are consistent: <span>$\hat{r} \xrightarrow{p} r_0$</span> as <span>$N, T \to \infty$</span></li></ul><p><strong>Reference</strong>: Bai &amp; Ng (2002)</p><h3 id="Julia-Implementation-2"><a class="docs-heading-anchor" href="#Julia-Implementation-2">Julia Implementation</a><a class="docs-heading-anchor-permalink" href="#Julia-Implementation-2" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MacroEconometricModels

# Compute IC for r = 1, ..., r_max
r_max = 10
ic = ic_criteria(X, r_max)

# Optimal number by each criterion
println(&quot;IC1 selects: &quot;, ic.r_IC1, &quot; factors&quot;)
println(&quot;IC2 selects: &quot;, ic.r_IC2, &quot; factors&quot;)
println(&quot;IC3 selects: &quot;, ic.r_IC3, &quot; factors&quot;)

# IC values for all r
for r in 1:r_max
    println(&quot;r=$r: IC1=$(ic.IC1[r]), IC2=$(ic.IC2[r]), IC3=$(ic.IC3[r])&quot;)
end</code></pre><hr/><h2 id="Scree-Plot-Analysis"><a class="docs-heading-anchor" href="#Scree-Plot-Analysis">Scree Plot Analysis</a><a id="Scree-Plot-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Scree-Plot-Analysis" title="Permalink"></a></h2><h3 id="Visual-Factor-Selection"><a class="docs-heading-anchor" href="#Visual-Factor-Selection">Visual Factor Selection</a><a id="Visual-Factor-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#Visual-Factor-Selection" title="Permalink"></a></h3><p>The scree plot displays eigenvalues (or variance explained) against factor number. The &quot;elbow&quot; in the plot suggests the number of significant factors.</p><h3 id="Variance-Explained"><a class="docs-heading-anchor" href="#Variance-Explained">Variance Explained</a><a id="Variance-Explained-1"></a><a class="docs-heading-anchor-permalink" href="#Variance-Explained" title="Permalink"></a></h3><p>For each factor <span>$j$</span>:</p><p><strong>Individual Variance</strong>:</p><p class="math-container">\[\text{VarExp}_j = \frac{\mu_j}{\sum_{k=1}^N \mu_k}\]</p><p><strong>Cumulative Variance</strong>:</p><p class="math-container">\[\text{CumVarExp}_r = \sum_{j=1}^r \text{VarExp}_j\]</p><p>where <span>$\mu_j$</span> is the <span>$j$</span>-th largest eigenvalue of <span>$X&#39;X/T$</span> (or <span>$XX&#39;/N$</span>).</p><h3 id="Julia-Implementation-3"><a class="docs-heading-anchor" href="#Julia-Implementation-3">Julia Implementation</a><a class="docs-heading-anchor-permalink" href="#Julia-Implementation-3" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MacroEconometricModels

model = estimate_factors(X, r)

# Get scree plot data
scree = scree_plot_data(model)

# Variance explained
for j in 1:min(10, length(scree.factors))
    println(&quot;Factor $j: $(round(scree.explained_variance[j]*100, digits=2))% &quot;,
            &quot;(cumulative: $(round(scree.cumulative_variance[j]*100, digits=2))%)&quot;)
end</code></pre><hr/><h2 id="Model-Diagnostics"><a class="docs-heading-anchor" href="#Model-Diagnostics">Model Diagnostics</a><a id="Model-Diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Diagnostics" title="Permalink"></a></h2><h3 id="R-squared-for-Each-Variable"><a class="docs-heading-anchor" href="#R-squared-for-Each-Variable">R-squared for Each Variable</a><a id="R-squared-for-Each-Variable-1"></a><a class="docs-heading-anchor-permalink" href="#R-squared-for-Each-Variable" title="Permalink"></a></h3><p>The <span>$R^2$</span> measures how much of variable <span>$i$</span>&#39;s variation is explained by the common factors:</p><p class="math-container">\[R^2_i = 1 - \frac{\sum_t \hat{e}_{it}^2}{\sum_t (x_{it} - \bar{x}_i)^2}\]</p><p>Variables with low <span>$R^2$</span> are mainly driven by idiosyncratic shocks.</p><h3 id="Julia-Implementation-4"><a class="docs-heading-anchor" href="#Julia-Implementation-4">Julia Implementation</a><a class="docs-heading-anchor-permalink" href="#Julia-Implementation-4" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MacroEconometricModels

model = estimate_factors(X, r)

# R² for each variable
r2_values = r2(model)

# Summary statistics
println(&quot;Mean R²: &quot;, round(mean(r2_values), digits=3))
println(&quot;Median R²: &quot;, round(median(r2_values), digits=3))
println(&quot;Min R²: &quot;, round(minimum(r2_values), digits=3))
println(&quot;Max R²: &quot;, round(maximum(r2_values), digits=3))

# Variables well-explained by factors
well_explained = findall(r2_values .&gt; 0.7)</code></pre><h3 id="Fitted-Values-and-Residuals"><a class="docs-heading-anchor" href="#Fitted-Values-and-Residuals">Fitted Values and Residuals</a><a id="Fitted-Values-and-Residuals-1"></a><a class="docs-heading-anchor-permalink" href="#Fitted-Values-and-Residuals" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Fitted values: X̂ = FΛ&#39;
X_fitted = predict(model)

# Residuals: E = X - X̂
resid = residuals(model)

# Model statistics
println(&quot;Number of observations: &quot;, nobs(model))
println(&quot;Degrees of freedom: &quot;, dof(model))</code></pre><hr/><h2 id="Applications"><a class="docs-heading-anchor" href="#Applications">Applications</a><a id="Applications-1"></a><a class="docs-heading-anchor-permalink" href="#Applications" title="Permalink"></a></h2><h3 id="Diffusion-Index-Forecasting"><a class="docs-heading-anchor" href="#Diffusion-Index-Forecasting">Diffusion Index Forecasting</a><a id="Diffusion-Index-Forecasting-1"></a><a class="docs-heading-anchor-permalink" href="#Diffusion-Index-Forecasting" title="Permalink"></a></h3><p>Use factors as predictors for forecasting a target variable <span>$y_{t+h}$</span>:</p><p class="math-container">\[y_{t+h} = \alpha + \beta&#39; \hat{F}_t + \gamma&#39; y_{t:t-p} + \varepsilon_{t+h}\]</p><p>Factors summarize information from a large panel, improving forecast accuracy.</p><p><strong>Reference</strong>: Stock &amp; Watson (2002b)</p><h3 id="Factor-Augmented-VAR-(FAVAR)"><a class="docs-heading-anchor" href="#Factor-Augmented-VAR-(FAVAR)">Factor-Augmented VAR (FAVAR)</a><a id="Factor-Augmented-VAR-(FAVAR)-1"></a><a class="docs-heading-anchor-permalink" href="#Factor-Augmented-VAR-(FAVAR)" title="Permalink"></a></h3><p>Combine factors with key observable variables in a VAR:</p><p class="math-container">\[\begin{bmatrix} y_t \\ F_t \end{bmatrix} = A_1 \begin{bmatrix} y_{t-1} \\ F_{t-1} \end{bmatrix} + \cdots + A_p \begin{bmatrix} y_{t-p} \\ F_{t-p} \end{bmatrix} + u_t\]</p><p>This allows structural analysis with high-dimensional information sets.</p><p><strong>Reference</strong>: Bernanke, Boivin &amp; Eliasz (2005)</p><h3 id="Example:-FAVAR-Setup"><a class="docs-heading-anchor" href="#Example:-FAVAR-Setup">Example: FAVAR Setup</a><a id="Example:-FAVAR-Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-FAVAR-Setup" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MacroEconometricModels

# Estimate factors from large panel X
fm = estimate_factors(X, r)
F = fm.factors

# Combine with key observables (e.g., FFR, GDP, inflation)
Y_key = Matrix(data[:, [:FFR, :GDP, :CPI]])
Y_favar = hcat(Y_key, F)

# Estimate FAVAR
favar_model = estimate_var(Y_favar, p)

# Structural analysis
irf_favar = irf(favar_model, H; method=:cholesky)</code></pre><hr/><h2 id="Forecasting-with-Static-Factor-Models"><a class="docs-heading-anchor" href="#Forecasting-with-Static-Factor-Models">Forecasting with Static Factor Models</a><a id="Forecasting-with-Static-Factor-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Forecasting-with-Static-Factor-Models" title="Permalink"></a></h2><h3 id="Forecast-Method"><a class="docs-heading-anchor" href="#Forecast-Method">Forecast Method</a><a id="Forecast-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Forecast-Method" title="Permalink"></a></h3><p>The static factor model does not directly specify factor dynamics, but forecasting is possible by fitting a VAR(p) on the extracted factors:</p><p class="math-container">\[\hat{F}_{T+h|T} = \hat{A}_1 \hat{F}_{T+h-1|T} + \cdots + \hat{A}_p \hat{F}_{T+h-p|T}\]</p><p>Observable forecasts are obtained via the loading matrix:</p><p class="math-container">\[\hat{X}_{T+h|T} = \hat{\Lambda} \hat{F}_{T+h|T}\]</p><h3 id="Confidence-Intervals"><a class="docs-heading-anchor" href="#Confidence-Intervals">Confidence Intervals</a><a id="Confidence-Intervals-1"></a><a class="docs-heading-anchor-permalink" href="#Confidence-Intervals" title="Permalink"></a></h3><p><strong>Theoretical CIs</strong> use the VMA(<span>$\infty$</span>) representation of the factor VAR to compute the <span>$h$</span>-step forecast error covariance analytically:</p><p class="math-container">\[\text{MSE}_h = \sum_{j=0}^{h-1} \Psi_j \Sigma_\eta \Psi_j&#39;\]</p><p>where <span>$\Psi_j = J C^j$</span> are the VMA coefficient matrices from the companion form.</p><p><strong>Bootstrap CIs</strong> resample factor VAR residuals to construct simulated forecast paths and compute percentile intervals.</p><h3 id="Julia-Implementation-5"><a class="docs-heading-anchor" href="#Julia-Implementation-5">Julia Implementation</a><a class="docs-heading-anchor-permalink" href="#Julia-Implementation-5" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MacroEconometricModels

# Estimate static factor model
fm = estimate_factors(X, 3)

# Point forecast (fits VAR(1) on factors internally)
fc = forecast(fm, 12)
fc.factors       # 12×3 factor forecasts
fc.observables   # 12×N observable forecasts

# Forecast with theoretical (analytical) confidence intervals
fc = forecast(fm, 12; ci_method=:theoretical, conf_level=0.95)
fc.factors_lower   # 12×3 lower CI for factors
fc.factors_upper   # 12×3 upper CI for factors
fc.observables_se  # 12×N standard errors for observables

# Forecast with bootstrap CIs
fc = forecast(fm, 12; ci_method=:bootstrap, n_boot=1000, conf_level=0.90)

# Use higher-order VAR for factor dynamics
fc = forecast(fm, 12; p=2, ci_method=:theoretical)</code></pre><p>The theoretical SEs increase with the forecast horizon, reflecting growing uncertainty. For stationary factor dynamics, the SEs converge to the unconditional forecast error standard deviation. Bootstrap CIs are preferred when the Gaussian assumption may not hold.</p><p><strong>Reference</strong>: Stock &amp; Watson (2002b)</p><hr/><h2 id="Asymptotic-Theory"><a class="docs-heading-anchor" href="#Asymptotic-Theory">Asymptotic Theory</a><a id="Asymptotic-Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Asymptotic-Theory" title="Permalink"></a></h2><h3 id="Consistency-of-Factor-Estimates"><a class="docs-heading-anchor" href="#Consistency-of-Factor-Estimates">Consistency of Factor Estimates</a><a id="Consistency-of-Factor-Estimates-1"></a><a class="docs-heading-anchor-permalink" href="#Consistency-of-Factor-Estimates" title="Permalink"></a></h3><p>Under the assumptions of Bai &amp; Ng (2002), as <span>$T, N \to \infty$</span>:</p><p class="math-container">\[\frac{1}{T} \sum_{t=1}^T \|\hat{F}_t - H F_t\|^2 = O_p\left( \frac{1}{\min(N, T)} \right)\]</p><p>where <span>$H$</span> is an <span>$r \times r$</span> rotation matrix.</p><p>The factors are consistently estimated up to rotation at rate <span>$\min(\sqrt{N}, \sqrt{T})$</span>.</p><h3 id="Distribution-Theory"><a class="docs-heading-anchor" href="#Distribution-Theory">Distribution Theory</a><a id="Distribution-Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Distribution-Theory" title="Permalink"></a></h3><p>For large <span>$N, T$</span>, the factor estimates are asymptotically normal:</p><p class="math-container">\[\sqrt{T} (\hat{F}_t - H F_t) \xrightarrow{d} N(0, V)\]</p><p>where <span>$V$</span> depends on the cross-sectional and temporal dependence structure.</p><p><strong>Reference</strong>: Bai (2003), Bai &amp; Ng (2006)</p><hr/><h2 id="Comparison-with-Other-Methods"><a class="docs-heading-anchor" href="#Comparison-with-Other-Methods">Comparison with Other Methods</a><a id="Comparison-with-Other-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison-with-Other-Methods" title="Permalink"></a></h2><h3 id="Static-vs.-Dynamic-Factor-Models"><a class="docs-heading-anchor" href="#Static-vs.-Dynamic-Factor-Models">Static vs. Dynamic Factor Models</a><a id="Static-vs.-Dynamic-Factor-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Static-vs.-Dynamic-Factor-Models" title="Permalink"></a></h3><table><tr><th style="text-align: right">Aspect</th><th style="text-align: right">Static FM</th><th style="text-align: right">Dynamic FM</th></tr><tr><td style="text-align: right"><strong>Model</strong></td><td style="text-align: right"><span>$X_t = \Lambda F_t + e_t$</span></td><td style="text-align: right"><span>$X_t = \Lambda(L) f_t + e_t$</span></td></tr><tr><td style="text-align: right"><strong>Factors</strong></td><td style="text-align: right">Contemporaneous</td><td style="text-align: right">May include lags</td></tr><tr><td style="text-align: right"><strong>Estimation</strong></td><td style="text-align: right">PCA</td><td style="text-align: right">Spectral methods, Kalman filter</td></tr><tr><td style="text-align: right"><strong>Use case</strong></td><td style="text-align: right">Large N, moderate T</td><td style="text-align: right">Time series dynamics important</td></tr></table><p><strong>Reference</strong>: Forni, Hallin, Lippi &amp; Reichlin (2000)</p><h3 id="Maximum-Likelihood-Estimation"><a class="docs-heading-anchor" href="#Maximum-Likelihood-Estimation">Maximum Likelihood Estimation</a><a id="Maximum-Likelihood-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Maximum-Likelihood-Estimation" title="Permalink"></a></h3><p>ML estimation assumes Gaussian factors and errors:</p><p class="math-container">\[F_t \sim N(0, I_r), \quad e_t \sim N(0, \Psi)\]</p><p>Estimated via EM algorithm. More efficient than PCA if model is correctly specified, but computationally intensive.</p><hr/><h2 id="Dynamic-Factor-Models"><a class="docs-heading-anchor" href="#Dynamic-Factor-Models">Dynamic Factor Models</a><a id="Dynamic-Factor-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Dynamic-Factor-Models" title="Permalink"></a></h2><h3 id="Model-Specification-2"><a class="docs-heading-anchor" href="#Model-Specification-2">Model Specification</a><a class="docs-heading-anchor-permalink" href="#Model-Specification-2" title="Permalink"></a></h3><p>The dynamic factor model extends the static model by allowing factors to follow a VAR process:</p><p><strong>Observation Equation</strong>:</p><p class="math-container">\[X_t = \Lambda F_t + e_t\]</p><p><strong>State Equation (Factor Dynamics)</strong>:</p><p class="math-container">\[F_t = A_1 F_{t-1} + A_2 F_{t-2} + \cdots + A_p F_{t-p} + \eta_t\]</p><p>where:</p><ul><li><span>$F_t$</span> is the <span>$r \times 1$</span> vector of latent factors</li><li><span>$\Lambda$</span> is the <span>$N \times r$</span> loading matrix</li><li><span>$A_1, \ldots, A_p$</span> are <span>$r \times r$</span> autoregressive coefficient matrices</li><li><span>$\eta_t \sim N(0, \Sigma_\eta)$</span> are factor innovations</li><li><span>$e_t \sim N(0, \Sigma_e)$</span> are idiosyncratic errors (typically diagonal)</li></ul><h3 id="Estimation-Methods"><a class="docs-heading-anchor" href="#Estimation-Methods">Estimation Methods</a><a id="Estimation-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Estimation-Methods" title="Permalink"></a></h3><p><strong>Two-Step Estimation</strong>:</p><ol><li>Extract factors using PCA (as in static model)</li><li>Estimate VAR(p) on extracted factors</li></ol><p><strong>EM Algorithm</strong>:</p><ul><li>Iterates between E-step (Kalman smoother) and M-step (parameter updates)</li><li>More efficient but computationally intensive</li></ul><h3 id="Julia-Implementation-6"><a class="docs-heading-anchor" href="#Julia-Implementation-6">Julia Implementation</a><a class="docs-heading-anchor-permalink" href="#Julia-Implementation-6" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MacroEconometricModels

# Estimate dynamic factor model with r factors and p lags
model = estimate_dynamic_factors(X, r, p;
    method = :twostep,      # or :em
    standardize = true,
    diagonal_idio = true    # Diagonal idiosyncratic covariance
)

# Access results
F = model.factors           # T×r estimated factors
Λ = model.loadings          # N×r loadings
A = model.A                 # Vector of r×r AR coefficient matrices
Σ_η = model.Sigma_eta       # r×r factor innovation covariance
Σ_e = model.Sigma_e         # N×N idiosyncratic covariance</code></pre><h3 id="DynamicFactorModel-Return-Values"><a class="docs-heading-anchor" href="#DynamicFactorModel-Return-Values">DynamicFactorModel Return Values</a><a id="DynamicFactorModel-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#DynamicFactorModel-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>X</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">Original <span>$T \times N$</span> data matrix</td></tr><tr><td style="text-align: right"><code>factors</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$T \times r$</span> estimated factors</td></tr><tr><td style="text-align: right"><code>loadings</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$N \times r$</span> loading matrix</td></tr><tr><td style="text-align: right"><code>A</code></td><td style="text-align: right"><code>Vector{Matrix{T}}</code></td><td style="text-align: right"><span>$r \times r$</span> autoregressive coefficient matrices</td></tr><tr><td style="text-align: right"><code>factor_residuals</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">Factor VAR residuals</td></tr><tr><td style="text-align: right"><code>Sigma_eta</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$r \times r$</span> factor innovation covariance</td></tr><tr><td style="text-align: right"><code>Sigma_e</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$N \times N$</span> idiosyncratic covariance</td></tr><tr><td style="text-align: right"><code>eigenvalues</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Eigenvalues from initial PCA</td></tr><tr><td style="text-align: right"><code>explained_variance</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Variance explained by each factor</td></tr><tr><td style="text-align: right"><code>cumulative_variance</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Cumulative variance explained</td></tr><tr><td style="text-align: right"><code>r</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of factors</td></tr><tr><td style="text-align: right"><code>p</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of factor VAR lags</td></tr><tr><td style="text-align: right"><code>method</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Estimation method (<code>:twostep</code> or <code>:em</code>)</td></tr><tr><td style="text-align: right"><code>standardized</code></td><td style="text-align: right"><code>Bool</code></td><td style="text-align: right">Whether data was standardized</td></tr><tr><td style="text-align: right"><code>converged</code></td><td style="text-align: right"><code>Bool</code></td><td style="text-align: right">Convergence status (relevant for <code>:em</code>)</td></tr><tr><td style="text-align: right"><code>iterations</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of iterations (relevant for <code>:em</code>)</td></tr><tr><td style="text-align: right"><code>loglik</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Log-likelihood value</td></tr></table><h3 id="Model-Selection-for-DFM"><a class="docs-heading-anchor" href="#Model-Selection-for-DFM">Model Selection for DFM</a><a id="Model-Selection-for-DFM-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Selection-for-DFM" title="Permalink"></a></h3><p>Select the number of factors <span>$r$</span> and lag order <span>$p$</span> using information criteria:</p><pre><code class="language-julia hljs"># Grid search over (r, p) combinations
ic = ic_criteria_dynamic(X, max_r, max_p;
    method = :twostep,
    standardize = true
)

println(&quot;AIC selects: r=$(ic.r_AIC), p=$(ic.p_AIC)&quot;)
println(&quot;BIC selects: r=$(ic.r_BIC), p=$(ic.p_BIC)&quot;)

# View full IC matrices
ic.AIC  # r×p matrix of AIC values
ic.BIC  # r×p matrix of BIC values</code></pre><h3 id="Forecasting-with-DFM"><a class="docs-heading-anchor" href="#Forecasting-with-DFM">Forecasting with DFM</a><a id="Forecasting-with-DFM-1"></a><a class="docs-heading-anchor-permalink" href="#Forecasting-with-DFM" title="Permalink"></a></h3><p>The DFM forecast extrapolates the factor VAR dynamics forward and projects to observables via the loading matrix. Four CI methods are available:</p><table><tr><th style="text-align: right"><code>ci_method</code></th><th style="text-align: right">Description</th><th style="text-align: right">Best for</th></tr><tr><td style="text-align: right"><code>:none</code></td><td style="text-align: right">Point forecast only</td><td style="text-align: right">Quick exploration</td></tr><tr><td style="text-align: right"><code>:theoretical</code></td><td style="text-align: right">Analytical VMA CIs (Gaussian)</td><td style="text-align: right">Large samples, fast</td></tr><tr><td style="text-align: right"><code>:bootstrap</code></td><td style="text-align: right">Residual resampling</td><td style="text-align: right">Non-Gaussian innovations</td></tr><tr><td style="text-align: right"><code>:simulation</code></td><td style="text-align: right">Monte Carlo draws from estimated model</td><td style="text-align: right">Full uncertainty propagation</td></tr></table><pre><code class="language-julia hljs"># Point forecasts h steps ahead
fc = forecast(model, h)
fc.factors       # h×r factor forecasts
fc.observables   # h×N observable forecasts

# Theoretical (analytical) confidence intervals
fc = forecast(model, h; ci_method=:theoretical, conf_level=0.95)
fc.factors_se           # h×r standard errors
fc.observables_lower    # h×N lower CI bounds
fc.observables_upper    # h×N upper CI bounds

# Bootstrap confidence intervals
fc = forecast(model, h; ci_method=:bootstrap, n_boot=1000, conf_level=0.90)

# Simulation-based CIs (original method, also accessible via legacy ci=true)
fc = forecast(model, h; ci_method=:simulation, n_boot=2000)
fc = forecast(model, h; ci=true, ci_level=0.90)  # Legacy interface</code></pre><p>All forecast methods return a <code>FactorForecast</code> struct. When <code>ci_method=:none</code>, the CI and SE fields are zero matrices.</p><h3 id="FactorForecast-Return-Values"><a class="docs-heading-anchor" href="#FactorForecast-Return-Values">FactorForecast Return Values</a><a id="FactorForecast-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#FactorForecast-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>factors</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$h \times r$</span> factor point forecasts</td></tr><tr><td style="text-align: right"><code>observables</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$h \times N$</span> observable point forecasts</td></tr><tr><td style="text-align: right"><code>factors_lower</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$h \times r$</span> lower CI bounds for factors</td></tr><tr><td style="text-align: right"><code>factors_upper</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$h \times r$</span> upper CI bounds for factors</td></tr><tr><td style="text-align: right"><code>observables_lower</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$h \times N$</span> lower CI bounds for observables</td></tr><tr><td style="text-align: right"><code>observables_upper</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$h \times N$</span> upper CI bounds for observables</td></tr><tr><td style="text-align: right"><code>factors_se</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$h \times r$</span> factor forecast standard errors</td></tr><tr><td style="text-align: right"><code>observables_se</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$h \times N$</span> observable forecast standard errors</td></tr><tr><td style="text-align: right"><code>horizon</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Forecast horizon <span>$h$</span></td></tr><tr><td style="text-align: right"><code>conf_level</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Confidence level (e.g., 0.95)</td></tr><tr><td style="text-align: right"><code>ci_method</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">CI method used (<code>:none</code>, <code>:theoretical</code>, <code>:bootstrap</code>, <code>:simulation</code>)</td></tr></table><div class="admonition is-info" id="Technical-Note-6bb4bbc61a48dbf3"><header class="admonition-header">Technical Note<a class="admonition-anchor" href="#Technical-Note-6bb4bbc61a48dbf3" title="Permalink"></a></header><div class="admonition-body"><p>The theoretical CIs compute the <span>$h$</span>-step forecast MSE via the VMA(<span>$\infty$</span>) representation: <span>$\text{MSE}_h = \sum_{j=0}^{h-1} \Psi_j \Sigma_\eta \Psi_j&#39;$</span> where <span>$\Psi_j = J C^j$</span> with <span>$C$</span> the companion matrix and <span>$J$</span> the selector for the first <span>$r$</span> rows. Observable SEs combine factor uncertainty with idiosyncratic variance: <span>$\text{Var}(\hat{X}_{T+h}) = \Lambda \cdot \text{MSE}_h \cdot \Lambda&#39; + \Sigma_e$</span>.</p></div></div><h3 id="Stationarity-Check"><a class="docs-heading-anchor" href="#Stationarity-Check">Stationarity Check</a><a id="Stationarity-Check-1"></a><a class="docs-heading-anchor-permalink" href="#Stationarity-Check" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Check if factor dynamics are stationary
is_stationary(model)  # true if max|eigenvalue| &lt; 1

# Get companion matrix for factor VAR
C = companion_matrix_factors(model)
eigvals(C)  # Eigenvalues determine stability</code></pre><p><strong>Reference</strong>: Stock &amp; Watson (2002a), Doz, Giannone &amp; Reichlin (2011)</p><hr/><h2 id="Generalized-Dynamic-Factor-Model-(GDFM)"><a class="docs-heading-anchor" href="#Generalized-Dynamic-Factor-Model-(GDFM)">Generalized Dynamic Factor Model (GDFM)</a><a id="Generalized-Dynamic-Factor-Model-(GDFM)-1"></a><a class="docs-heading-anchor-permalink" href="#Generalized-Dynamic-Factor-Model-(GDFM)" title="Permalink"></a></h2><h3 id="Theoretical-Foundation"><a class="docs-heading-anchor" href="#Theoretical-Foundation">Theoretical Foundation</a><a id="Theoretical-Foundation-1"></a><a class="docs-heading-anchor-permalink" href="#Theoretical-Foundation" title="Permalink"></a></h3><p>The Generalized Dynamic Factor Model of Forni, Hallin, Lippi &amp; Reichlin (2000, 2005) provides a fully dynamic approach to factor analysis using spectral methods. Unlike the standard DFM which uses static PCA followed by VAR, the GDFM extracts factors directly in the frequency domain.</p><h3 id="Model-Specification-3"><a class="docs-heading-anchor" href="#Model-Specification-3">Model Specification</a><a class="docs-heading-anchor-permalink" href="#Model-Specification-3" title="Permalink"></a></h3><p>The GDFM decomposes each observable as:</p><p class="math-container">\[x_{it} = \chi_{it} + \xi_{it}\]</p><p>where:</p><ul><li><span>$\chi_{it}$</span> is the <strong>common component</strong> driven by <span>$q$</span> common shocks</li><li><span>$\xi_{it}$</span> is the <strong>idiosyncratic component</strong></li></ul><p>The common component has the representation:</p><p class="math-container">\[\chi_{it} = b_{i1}(L) u_{1t} + b_{i2}(L) u_{2t} + \cdots + b_{iq}(L) u_{qt}\]</p><p>where <span>$b_{ij}(L)$</span> are square-summable filters and <span>$u_{jt}$</span> are orthonormal white noise shocks.</p><h3 id="Spectral-Representation"><a class="docs-heading-anchor" href="#Spectral-Representation">Spectral Representation</a><a id="Spectral-Representation-1"></a><a class="docs-heading-anchor-permalink" href="#Spectral-Representation" title="Permalink"></a></h3><p>In the frequency domain, the spectral density of <span>$X_t$</span> decomposes as:</p><p class="math-container">\[\Sigma_X(\omega) = \Sigma_\chi(\omega) + \Sigma_\xi(\omega)\]</p><p>The key insight is that common factors produce <strong>diverging eigenvalues</strong> (growing with <span>$N$</span>) while idiosyncratic components produce <strong>bounded eigenvalues</strong>.</p><h3 id="Estimation-Algorithm"><a class="docs-heading-anchor" href="#Estimation-Algorithm">Estimation Algorithm</a><a id="Estimation-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Estimation-Algorithm" title="Permalink"></a></h3><ol><li><strong>Spectral Density Estimation</strong>: Estimate <span>$\hat{\Sigma}_X(\omega)$</span> using kernel smoothing of the periodogram</li><li><strong>Dynamic Eigenanalysis</strong>: Compute eigenvalue decomposition at each frequency</li><li><strong>Factor Extraction</strong>: Select top <span>$q$</span> eigenvectors (dynamic principal components)</li><li><strong>Common Component</strong>: Reconstruct <span>$\chi_t$</span> via inverse Fourier transform</li></ol><h3 id="Julia-Implementation-7"><a class="docs-heading-anchor" href="#Julia-Implementation-7">Julia Implementation</a><a class="docs-heading-anchor-permalink" href="#Julia-Implementation-7" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MacroEconometricModels

# Estimate GDFM with q dynamic factors
model = estimate_gdfm(X, q;
    standardize = true,
    bandwidth = 0,           # Auto-select: T^(1/3)
    kernel = :bartlett,      # :bartlett, :parzen, or :tukey
    r = 0                    # Static factors (0 = same as q)
)

# Access results
F = model.factors                 # T×q time-domain factors
χ = model.common_component        # T×N common component
ξ = model.idiosyncratic           # T×N idiosyncratic component
Λ = model.loadings_spectral       # N×q×n_freq frequency-domain loadings

# Variance explained by dynamic factors
model.variance_explained          # q-vector of variance shares</code></pre><h3 id="GeneralizedDynamicFactorModel-Return-Values"><a class="docs-heading-anchor" href="#GeneralizedDynamicFactorModel-Return-Values">GeneralizedDynamicFactorModel Return Values</a><a id="GeneralizedDynamicFactorModel-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#GeneralizedDynamicFactorModel-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>X</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">Original <span>$T \times N$</span> data matrix</td></tr><tr><td style="text-align: right"><code>factors</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$T \times q$</span> time-domain factors</td></tr><tr><td style="text-align: right"><code>common_component</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$T \times N$</span> common component <span>$\chi_t$</span></td></tr><tr><td style="text-align: right"><code>idiosyncratic</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$T \times N$</span> idiosyncratic component <span>$\xi_t$</span></td></tr><tr><td style="text-align: right"><code>loadings_spectral</code></td><td style="text-align: right"><code>Array{Complex{T},3}</code></td><td style="text-align: right"><span>$N \times q \times n_{freq}$</span> frequency-domain loadings</td></tr><tr><td style="text-align: right"><code>spectral_density_X</code></td><td style="text-align: right"><code>Array{Complex{T},3}</code></td><td style="text-align: right">Spectral density of <span>$X_t$</span></td></tr><tr><td style="text-align: right"><code>spectral_density_chi</code></td><td style="text-align: right"><code>Array{Complex{T},3}</code></td><td style="text-align: right">Spectral density of common component</td></tr><tr><td style="text-align: right"><code>eigenvalues_spectral</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$N \times n_{freq}$</span> eigenvalues across frequencies</td></tr><tr><td style="text-align: right"><code>frequencies</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Frequency grid (0 to <span>$\pi$</span>)</td></tr><tr><td style="text-align: right"><code>q</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of dynamic factors</td></tr><tr><td style="text-align: right"><code>r</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of static factors</td></tr><tr><td style="text-align: right"><code>bandwidth</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Kernel smoothing bandwidth</td></tr><tr><td style="text-align: right"><code>kernel</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Kernel type (<code>:bartlett</code>, <code>:parzen</code>, <code>:tukey</code>)</td></tr><tr><td style="text-align: right"><code>standardized</code></td><td style="text-align: right"><code>Bool</code></td><td style="text-align: right">Whether data was standardized</td></tr><tr><td style="text-align: right"><code>variance_explained</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Variance share per dynamic factor</td></tr></table><h3 id="Selecting-the-Number-of-Dynamic-Factors"><a class="docs-heading-anchor" href="#Selecting-the-Number-of-Dynamic-Factors">Selecting the Number of Dynamic Factors</a><a id="Selecting-the-Number-of-Dynamic-Factors-1"></a><a class="docs-heading-anchor-permalink" href="#Selecting-the-Number-of-Dynamic-Factors" title="Permalink"></a></h3><p>The GDFM uses eigenvalue-based criteria rather than information criteria:</p><pre><code class="language-julia hljs"># Compute selection criteria
ic = ic_criteria_gdfm(X, max_q;
    standardize = true,
    bandwidth = 0,
    kernel = :bartlett
)

# Eigenvalue ratio criterion (Ahn &amp; Horenstein 2013)
println(&quot;Ratio criterion selects: q=$(ic.q_ratio)&quot;)

# Variance threshold criterion (90% of spectral variance)
println(&quot;Variance criterion selects: q=$(ic.q_variance)&quot;)

# Diagnostic data
ic.eigenvalue_ratios      # λ_i / λ_{i+1} ratios
ic.cumulative_variance    # Cumulative variance explained
ic.avg_eigenvalues        # Average eigenvalues across frequencies</code></pre><h3 id="Spectral-Diagnostics"><a class="docs-heading-anchor" href="#Spectral-Diagnostics">Spectral Diagnostics</a><a id="Spectral-Diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Spectral-Diagnostics" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Get data for eigenvalue plots across frequencies
plot_data = spectral_eigenvalue_plot_data(model)
plot_data.frequencies     # Vector of frequencies (0 to π)
plot_data.eigenvalues     # N×n_freq matrix of eigenvalues

# First eigenvalue should dominate if one strong factor
# Gap between q-th and (q+1)-th eigenvalue indicates factor count</code></pre><h3 id="Common-Variance-Share"><a class="docs-heading-anchor" href="#Common-Variance-Share">Common Variance Share</a><a id="Common-Variance-Share-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Variance-Share" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Fraction of variance explained by common component for each variable
shares = common_variance_share(model)

# Variables well-explained by common factors
well_explained = findall(shares .&gt; 0.5)

# Summary statistics
println(&quot;Mean common variance share: &quot;, round(mean(shares), digits=3))
println(&quot;Variables with &gt;50% common: &quot;, length(well_explained))</code></pre><h3 id="Forecasting-with-GDFM"><a class="docs-heading-anchor" href="#Forecasting-with-GDFM">Forecasting with GDFM</a><a id="Forecasting-with-GDFM-1"></a><a class="docs-heading-anchor-permalink" href="#Forecasting-with-GDFM" title="Permalink"></a></h3><p>The GDFM forecast uses AR(1) extrapolation of each factor series, with observable forecasts computed via the average spectral loadings. Confidence intervals are available via analytical or bootstrap methods.</p><pre><code class="language-julia hljs"># Point forecast
fc = forecast(model, h; method=:ar)
fc.factors       # h×q factor forecasts
fc.observables   # h×N observable forecasts

# Theoretical CIs (closed-form AR(1) variance)
fc = forecast(model, h; ci_method=:theoretical, conf_level=0.95)
fc.factors_se           # h×q SEs (non-decreasing with horizon)
fc.observables_lower    # h×N lower CI bounds
fc.observables_upper    # h×N upper CI bounds

# Bootstrap CIs (resample AR(1) residuals per factor)
fc = forecast(model, h; ci_method=:bootstrap, n_boot=1000)</code></pre><p>The theoretical CIs use the closed-form AR(1) forecast variance: <span>$\text{Var}(\hat{F}_{T+h,i}) = \sigma_i^2 \sum_{j=0}^{h-1} \phi_i^{2j}$</span> where <span>$\phi_i$</span> and <span>$\sigma_i^2$</span> are the AR(1) coefficient and innovation variance for factor <span>$i$</span>. Observable SEs combine factor uncertainty with idiosyncratic variance.</p><h3 id="Comparison:-DFM-vs-GDFM"><a class="docs-heading-anchor" href="#Comparison:-DFM-vs-GDFM">Comparison: DFM vs GDFM</a><a id="Comparison:-DFM-vs-GDFM-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison:-DFM-vs-GDFM" title="Permalink"></a></h3><table><tr><th style="text-align: right">Aspect</th><th style="text-align: right">Dynamic Factor Model</th><th style="text-align: right">Generalized DFM</th></tr><tr><td style="text-align: right"><strong>Approach</strong></td><td style="text-align: right">Time domain (PCA + VAR)</td><td style="text-align: right">Frequency domain (spectral)</td></tr><tr><td style="text-align: right"><strong>Factor dynamics</strong></td><td style="text-align: right">Explicit VAR structure</td><td style="text-align: right">Implicit through spectral density</td></tr><tr><td style="text-align: right"><strong>Estimation</strong></td><td style="text-align: right">Two-step or EM</td><td style="text-align: right">Kernel-smoothed periodogram</td></tr><tr><td style="text-align: right"><strong>Computational cost</strong></td><td style="text-align: right">Moderate</td><td style="text-align: right">Higher (FFT at each frequency)</td></tr><tr><td style="text-align: right"><strong>Asymptotics</strong></td><td style="text-align: right"><span>$T \to \infty$</span></td><td style="text-align: right"><span>$N, T \to \infty$</span> jointly</td></tr><tr><td style="text-align: right"><strong>Best for</strong></td><td style="text-align: right">Moderate N, focus on forecasting</td><td style="text-align: right">Large N, structural decomposition</td></tr></table><h3 id="Example:-Complete-GDFM-Workflow"><a class="docs-heading-anchor" href="#Example:-Complete-GDFM-Workflow">Example: Complete GDFM Workflow</a><a id="Example:-Complete-GDFM-Workflow-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Complete-GDFM-Workflow" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MacroEconometricModels

# Load large macroeconomic panel (e.g., FRED-MD)
X = load_data()  # T×N matrix

# Step 1: Select number of factors
ic = ic_criteria_gdfm(X, 10)
q = ic.q_ratio
println(&quot;Selected q = $q dynamic factors&quot;)

# Step 2: Estimate GDFM
model = estimate_gdfm(X, q; kernel=:parzen)

# Step 3: Diagnostics
println(&quot;Variance explained: &quot;, round.(model.variance_explained, digits=3))
println(&quot;Mean R²: &quot;, round(mean(r2(model)), digits=3))

# Step 4: Extract common component for further analysis
χ = model.common_component  # Use in FAVAR, forecasting, etc.

# Step 5: Identify variables driven by common vs idiosyncratic shocks
shares = common_variance_share(model)
common_driven = findall(shares .&gt; 0.7)
idio_driven = findall(shares .&lt; 0.3)</code></pre><p><strong>References</strong>:</p><ul><li>Forni, M., Hallin, M., Lippi, M., &amp; Reichlin, L. (2000). &quot;The Generalized Dynamic-Factor Model: Identification and Estimation.&quot;</li><li>Forni, M., Hallin, M., Lippi, M., &amp; Reichlin, L. (2005). &quot;The Generalized Dynamic Factor Model: One-Sided Estimation and Forecasting.&quot;</li><li>Hallin, M., &amp; Liška, R. (2007). &quot;Determining the Number of Factors in the General Dynamic Factor Model.&quot;</li></ul><hr/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><h3 id="Core-References"><a class="docs-heading-anchor" href="#Core-References">Core References</a><a id="Core-References-1"></a><a class="docs-heading-anchor-permalink" href="#Core-References" title="Permalink"></a></h3><ul><li>Bai, Jushan. 2003. &quot;Inferential Theory for Factor Models of Large Dimensions.&quot; <em>Econometrica</em> 71 (1): 135–171. <a href="https://doi.org/10.1111/1468-0262.00392">https://doi.org/10.1111/1468-0262.00392</a></li><li>Bai, Jushan, and Serena Ng. 2002. &quot;Determining the Number of Factors in Approximate Factor Models.&quot; <em>Econometrica</em> 70 (1): 191–221. <a href="https://doi.org/10.1111/1468-0262.00273">https://doi.org/10.1111/1468-0262.00273</a></li><li>Bai, Jushan, and Serena Ng. 2006. &quot;Confidence Intervals for Diffusion Index Forecasts and Inference for Factor-Augmented Regressions.&quot; <em>Econometrica</em> 74 (4): 1133–1150. <a href="https://doi.org/10.1111/j.1468-0262.2006.00696.x">https://doi.org/10.1111/j.1468-0262.2006.00696.x</a></li><li>Stock, James H., and Mark W. Watson. 2002a. &quot;Forecasting Using Principal Components from a Large Number of Predictors.&quot; <em>Journal of the American Statistical Association</em> 97 (460): 1167–1179. <a href="https://doi.org/10.1198/016214502388618960">https://doi.org/10.1198/016214502388618960</a></li><li>Stock, James H., and Mark W. Watson. 2002b. &quot;Macroeconomic Forecasting Using Diffusion Indexes.&quot; <em>Journal of Business &amp; Economic Statistics</em> 20 (2): 147–162. <a href="https://doi.org/10.1198/073500102317351921">https://doi.org/10.1198/073500102317351921</a></li></ul><h3 id="Dynamic-Factor-Models-2"><a class="docs-heading-anchor" href="#Dynamic-Factor-Models-2">Dynamic Factor Models</a><a class="docs-heading-anchor-permalink" href="#Dynamic-Factor-Models-2" title="Permalink"></a></h3><ul><li>Doz, Catherine, Domenico Giannone, and Lucrezia Reichlin. 2011. &quot;A Two-Step Estimator for Large Approximate Dynamic Factor Models Based on Kalman Filtering.&quot; <em>Journal of Econometrics</em> 164 (1): 188–205. <a href="https://doi.org/10.1016/j.jeconom.2011.02.012">https://doi.org/10.1016/j.jeconom.2011.02.012</a></li><li>Doz, Catherine, Domenico Giannone, and Lucrezia Reichlin. 2012. &quot;A Quasi-Maximum Likelihood Approach for Large, Approximate Dynamic Factor Models.&quot; <em>Review of Economics and Statistics</em> 94 (4): 1014–1024. <a href="https://doi.org/10.1162/REST_a_00225">https://doi.org/10.1162/REST<em>a</em>00225</a></li><li>Forni, Mario, Marc Hallin, Marco Lippi, and Lucrezia Reichlin. 2000. &quot;The Generalized Dynamic-Factor Model: Identification and Estimation.&quot; <em>Review of Economics and Statistics</em> 82 (4): 540–554. <a href="https://doi.org/10.1162/003465300559037">https://doi.org/10.1162/003465300559037</a></li><li>Forni, Mario, Marc Hallin, Marco Lippi, and Lucrezia Reichlin. 2005. &quot;The Generalized Dynamic Factor Model: One-Sided Estimation and Forecasting.&quot; <em>Journal of the American Statistical Association</em> 100 (471): 830–840. <a href="https://doi.org/10.1198/016214504000002050">https://doi.org/10.1198/016214504000002050</a></li><li>Hallin, Marc, and Roman Liška. 2007. &quot;Determining the Number of Factors in the General Dynamic Factor Model.&quot; <em>Journal of the American Statistical Association</em> 102 (478): 603–617. <a href="https://doi.org/10.1198/016214506000001275">https://doi.org/10.1198/016214506000001275</a></li></ul><h3 id="Applications-2"><a class="docs-heading-anchor" href="#Applications-2">Applications</a><a class="docs-heading-anchor-permalink" href="#Applications-2" title="Permalink"></a></h3><ul><li>Bernanke, Ben S., Jean Boivin, and Piotr Eliasz. 2005. &quot;Measuring the Effects of Monetary Policy: A Factor-Augmented Vector Autoregressive (FAVAR) Approach.&quot; <em>Quarterly Journal of Economics</em> 120 (1): 387–422. <a href="https://doi.org/10.1162/0033553053327452">https://doi.org/10.1162/0033553053327452</a></li><li>McCracken, Michael W., and Serena Ng. 2016. &quot;FRED-MD: A Monthly Database for Macroeconomic Research.&quot; <em>Journal of Business &amp; Economic Statistics</em> 34 (4): 574–589. <a href="https://doi.org/10.1080/07350015.2015.1086655">https://doi.org/10.1080/07350015.2015.1086655</a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lp/">« Local Projections</a><a class="docs-footer-nextpage" href="../bayesian/">Bayesian VAR »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 6 February 2026 03:03">Friday 6 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
