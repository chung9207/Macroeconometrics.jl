<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ARIMA · MacroEconometricModels.jl</title><meta name="title" content="ARIMA · MacroEconometricModels.jl"/><meta property="og:title" content="ARIMA · MacroEconometricModels.jl"/><meta property="twitter:title" content="ARIMA · MacroEconometricModels.jl"/><meta name="description" content="Documentation for MacroEconometricModels.jl."/><meta property="og:description" content="Documentation for MacroEconometricModels.jl."/><meta property="twitter:description" content="Documentation for MacroEconometricModels.jl."/><meta property="og:url" content="https://chung9207.github.io/MacroEconometricModels.jl/arima/"/><meta property="twitter:url" content="https://chung9207.github.io/MacroEconometricModels.jl/arima/"/><link rel="canonical" href="https://chung9207.github.io/MacroEconometricModels.jl/arima/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MacroEconometricModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Univariate Models</span><ul><li class="is-active"><a class="tocitem" href>ARIMA</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Quick-Start"><span>Quick Start</span></a></li><li><a class="tocitem" href="#The-AR(p)-Model"><span>The AR(p) Model</span></a></li><li><a class="tocitem" href="#The-MA(q)-Model"><span>The MA(q) Model</span></a></li><li><a class="tocitem" href="#The-ARMA(p,q)-Model"><span>The ARMA(p,q) Model</span></a></li><li><a class="tocitem" href="#The-ARIMA(p,d,q)-Model"><span>The ARIMA(p,d,q) Model</span></a></li><li><a class="tocitem" href="#kalman_mle"><span>Exact MLE via Kalman Filter</span></a></li><li><a class="tocitem" href="#Forecasting"><span>Forecasting</span></a></li><li><a class="tocitem" href="#Order-Selection"><span>Order Selection</span></a></li><li><a class="tocitem" href="#StatsAPI-Interface"><span>StatsAPI Interface</span></a></li><li><a class="tocitem" href="#Complete-Example"><span>Complete Example</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li></ul></li><li><span class="tocitem">Frequentist Models</span><ul><li><a class="tocitem" href="../manual/">VAR</a></li><li><a class="tocitem" href="../lp/">Local Projections</a></li><li><a class="tocitem" href="../factormodels/">Factor Models</a></li></ul></li><li><span class="tocitem">Bayesian Models</span><ul><li><a class="tocitem" href="../bayesian/">Bayesian VAR</a></li></ul></li><li><a class="tocitem" href="../nongaussian/">Non-Gaussian SVAR</a></li><li><a class="tocitem" href="../innovation_accounting/">Innovation Accounting</a></li><li><span class="tocitem">Hypothesis Tests</span><ul><li><a class="tocitem" href="../hypothesis_tests/">Unit Root &amp; Cointegration</a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../api/">Overview</a></li><li><a class="tocitem" href="../api_types/">Types</a></li><li><a class="tocitem" href="../api_functions/">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Univariate Models</a></li><li class="is-active"><a href>ARIMA</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ARIMA</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/chung9207/MacroEconometricModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/chung9207/MacroEconometricModels.jl/blob/main/docs/src/arima.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Univariate-Time-Series-(ARIMA)"><a class="docs-heading-anchor" href="#Univariate-Time-Series-(ARIMA)">Univariate Time Series (ARIMA)</a><a id="Univariate-Time-Series-(ARIMA)-1"></a><a class="docs-heading-anchor-permalink" href="#Univariate-Time-Series-(ARIMA)" title="Permalink"></a></h1><p>This chapter covers univariate ARIMA-class models: AR, MA, ARMA, and ARIMA. These models are fundamental building blocks for time series analysis, forecasting, and as diagnostic tools for checking residual autocorrelation in multivariate models.</p><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>Univariate time series models capture temporal dependence through autoregressive (AR) and moving average (MA) components. The general ARIMA(p,d,q) model nests:</p><ol><li><strong>AR(p)</strong>: Autoregressive model — current value depends on past values</li><li><strong>MA(q)</strong>: Moving average model — current value depends on past shocks</li><li><strong>ARMA(p,q)</strong>: Combined autoregressive–moving average</li><li><strong>ARIMA(p,d,q)</strong>: Integrated ARMA — models non-stationary series via differencing</li></ol><p><strong>References</strong>: Box &amp; Jenkins (1976), Hamilton (1994, Chapters 3–5), Brockwell &amp; Davis (1991)</p><h2 id="Quick-Start"><a class="docs-heading-anchor" href="#Quick-Start">Quick Start</a><a id="Quick-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Start" title="Permalink"></a></h2><pre><code class="language-julia hljs">ar = estimate_ar(y, 2)                                    # AR(2) via OLS
ma = estimate_ma(y, 1; method=:css_mle)                   # MA(1) via CSS-MLE
arma = estimate_arma(y, 1, 1)                              # ARMA(1,1)
arima = estimate_arima(y, 1, 1, 0)                         # ARIMA(1,1,0)
fc = forecast(arma, 12; conf_level=0.95)                   # 12-step forecast with CI
sel = select_arima_order(y, 4, 4)                          # Grid search for best (p,q)</code></pre><hr/><h2 id="The-AR(p)-Model"><a class="docs-heading-anchor" href="#The-AR(p)-Model">The AR(p) Model</a><a id="The-AR(p)-Model-1"></a><a class="docs-heading-anchor-permalink" href="#The-AR(p)-Model" title="Permalink"></a></h2><h3 id="Model-Specification"><a class="docs-heading-anchor" href="#Model-Specification">Model Specification</a><a id="Model-Specification-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Specification" title="Permalink"></a></h3><p>An autoregressive model of order <span>$p$</span> is:</p><p class="math-container">\[y_t = c + \phi_1 y_{t-1} + \phi_2 y_{t-2} + \cdots + \phi_p y_{t-p} + \varepsilon_t\]</p><p>where <span>$\varepsilon_t \sim \text{WN}(0, \sigma^2)$</span> is white noise. Using the lag operator <span>$L$</span>:</p><p class="math-container">\[\phi(L) y_t = c + \varepsilon_t, \quad \phi(L) = 1 - \phi_1 L - \phi_2 L^2 - \cdots - \phi_p L^p\]</p><h3 id="Stationarity"><a class="docs-heading-anchor" href="#Stationarity">Stationarity</a><a id="Stationarity-1"></a><a class="docs-heading-anchor-permalink" href="#Stationarity" title="Permalink"></a></h3><p>The process is stationary if all roots of the characteristic polynomial <span>$\phi(z) = 0$</span> lie outside the unit circle, equivalently if all eigenvalues of the companion matrix</p><p class="math-container">\[F = \begin{bmatrix}
\phi_1 &amp; \phi_2 &amp; \cdots &amp; \phi_{p-1} &amp; \phi_p \\
1 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; \cdots &amp; 0 &amp; 0 \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\
0 &amp; 0 &amp; \cdots &amp; 1 &amp; 0
\end{bmatrix}_{p \times p}\]</p><p>have modulus less than 1: <span>$|\lambda_i(F)| &lt; 1$</span> for all <span>$i$</span>.</p><h3 id="Estimation"><a class="docs-heading-anchor" href="#Estimation">Estimation</a><a id="Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Estimation" title="Permalink"></a></h3><p>AR models support two estimation methods:</p><p><strong>OLS</strong> (<code>:ols</code>, default): For AR(p), construct the regression:</p><p class="math-container">\[y_t = \beta_0 + \beta_1 y_{t-1} + \cdots + \beta_p y_{t-p} + \varepsilon_t\]</p><p>and apply ordinary least squares. This is consistent and asymptotically efficient for stationary AR processes.</p><p><strong>Maximum Likelihood</strong> (<code>:mle</code>): Maximizes the exact Gaussian log-likelihood via the Kalman filter (see <a href="#kalman_mle">Exact MLE via Kalman Filter</a> below).</p><pre><code class="language-julia hljs">using MacroEconometricModels

y = randn(200)

# OLS estimation (default)
ar_ols = estimate_ar(y, 2)

# MLE estimation
ar_mle = estimate_ar(y, 2; method=:mle)

# Access results
ar_ols.phi      # AR coefficients [φ₁, φ₂]
ar_ols.sigma2   # Innovation variance
ar_ols.aic      # Akaike Information Criterion
ar_ols.bic      # Bayesian Information Criterion</code></pre><h3 id="ARModel-Return-Values"><a class="docs-heading-anchor" href="#ARModel-Return-Values">ARModel Return Values</a><a id="ARModel-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#ARModel-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>y</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Original time series</td></tr><tr><td style="text-align: right"><code>p</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">AR order</td></tr><tr><td style="text-align: right"><code>c</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Intercept (constant term)</td></tr><tr><td style="text-align: right"><code>phi</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">AR coefficients <span>$[\phi_1, \ldots, \phi_p]$</span></td></tr><tr><td style="text-align: right"><code>sigma2</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Innovation variance <span>$\hat{\sigma}^2$</span></td></tr><tr><td style="text-align: right"><code>residuals</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Estimated residuals</td></tr><tr><td style="text-align: right"><code>fitted</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Fitted values</td></tr><tr><td style="text-align: right"><code>loglik</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Log-likelihood</td></tr><tr><td style="text-align: right"><code>aic</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Akaike Information Criterion</td></tr><tr><td style="text-align: right"><code>bic</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Bayesian Information Criterion</td></tr><tr><td style="text-align: right"><code>method</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Estimation method (<code>:ols</code> or <code>:mle</code>)</td></tr><tr><td style="text-align: right"><code>converged</code></td><td style="text-align: right"><code>Bool</code></td><td style="text-align: right">Convergence indicator</td></tr><tr><td style="text-align: right"><code>iterations</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of optimization iterations</td></tr></table><p><strong>Reference</strong>: Hamilton (1994, Section 5.2)</p><hr/><h2 id="The-MA(q)-Model"><a class="docs-heading-anchor" href="#The-MA(q)-Model">The MA(q) Model</a><a id="The-MA(q)-Model-1"></a><a class="docs-heading-anchor-permalink" href="#The-MA(q)-Model" title="Permalink"></a></h2><h3 id="Model-Specification-2"><a class="docs-heading-anchor" href="#Model-Specification-2">Model Specification</a><a class="docs-heading-anchor-permalink" href="#Model-Specification-2" title="Permalink"></a></h3><p>A moving average model of order <span>$q$</span> is:</p><p class="math-container">\[y_t = c + \varepsilon_t + \theta_1 \varepsilon_{t-1} + \theta_2 \varepsilon_{t-2} + \cdots + \theta_q \varepsilon_{t-q}\]</p><p>or equivalently:</p><p class="math-container">\[y_t = c + \theta(L) \varepsilon_t, \quad \theta(L) = 1 + \theta_1 L + \theta_2 L^2 + \cdots + \theta_q L^q\]</p><h3 id="Invertibility"><a class="docs-heading-anchor" href="#Invertibility">Invertibility</a><a id="Invertibility-1"></a><a class="docs-heading-anchor-permalink" href="#Invertibility" title="Permalink"></a></h3><p>The MA process is invertible if all roots of <span>$\theta(z) = 0$</span> lie outside the unit circle. Invertibility ensures a unique MA representation and is checked via the companion matrix eigenvalue condition, identical in form to the AR stationarity check.</p><h3 id="Estimation-2"><a class="docs-heading-anchor" href="#Estimation-2">Estimation</a><a class="docs-heading-anchor-permalink" href="#Estimation-2" title="Permalink"></a></h3><p>MA parameters cannot be estimated by OLS. Three methods are available:</p><ul><li><strong>CSS</strong> (<code>:css</code>): Conditional Sum of Squares — fast, approximate</li><li><strong>MLE</strong> (<code>:mle</code>): Exact MLE via Kalman filter</li><li><strong>CSS-MLE</strong> (<code>:css_mle</code>, default): CSS initialization followed by MLE refinement</li></ul><pre><code class="language-julia hljs">ma_model = estimate_ma(y, 1; method=:css_mle)
ma_model.theta   # MA coefficient [θ₁]</code></pre><h3 id="MAModel-Return-Values"><a class="docs-heading-anchor" href="#MAModel-Return-Values">MAModel Return Values</a><a id="MAModel-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#MAModel-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>y</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Original time series</td></tr><tr><td style="text-align: right"><code>q</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">MA order</td></tr><tr><td style="text-align: right"><code>c</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Intercept</td></tr><tr><td style="text-align: right"><code>theta</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">MA coefficients <span>$[\theta_1, \ldots, \theta_q]$</span></td></tr><tr><td style="text-align: right"><code>sigma2</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Innovation variance</td></tr><tr><td style="text-align: right"><code>residuals</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Estimated residuals</td></tr><tr><td style="text-align: right"><code>fitted</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Fitted values</td></tr><tr><td style="text-align: right"><code>loglik</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Log-likelihood</td></tr><tr><td style="text-align: right"><code>aic</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">AIC</td></tr><tr><td style="text-align: right"><code>bic</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">BIC</td></tr><tr><td style="text-align: right"><code>method</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Estimation method (<code>:css</code>, <code>:mle</code>, <code>:css_mle</code>)</td></tr><tr><td style="text-align: right"><code>converged</code></td><td style="text-align: right"><code>Bool</code></td><td style="text-align: right">Convergence indicator</td></tr><tr><td style="text-align: right"><code>iterations</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of optimization iterations</td></tr></table><hr/><h2 id="The-ARMA(p,q)-Model"><a class="docs-heading-anchor" href="#The-ARMA(p,q)-Model">The ARMA(p,q) Model</a><a id="The-ARMA(p,q)-Model-1"></a><a class="docs-heading-anchor-permalink" href="#The-ARMA(p,q)-Model" title="Permalink"></a></h2><h3 id="Model-Specification-3"><a class="docs-heading-anchor" href="#Model-Specification-3">Model Specification</a><a class="docs-heading-anchor-permalink" href="#Model-Specification-3" title="Permalink"></a></h3><p>The ARMA(p,q) model combines autoregressive and moving average components:</p><p class="math-container">\[y_t = c + \sum_{i=1}^p \phi_i y_{t-i} + \varepsilon_t + \sum_{j=1}^q \theta_j \varepsilon_{t-j}\]</p><p>or in lag-operator form:</p><p class="math-container">\[\phi(L) y_t = c + \theta(L) \varepsilon_t\]</p><p>The process is stationary and invertible when all roots of <span>$\phi(z)$</span> and <span>$\theta(z)$</span> lie outside the unit circle, respectively.</p><h3 id="Estimation-3"><a class="docs-heading-anchor" href="#Estimation-3">Estimation</a><a class="docs-heading-anchor-permalink" href="#Estimation-3" title="Permalink"></a></h3><p>The same three methods (<code>:css</code>, <code>:mle</code>, <code>:css_mle</code>) are available. The unified internal pipeline <code>_estimate_arma_internal</code> dispatches to the appropriate method:</p><ol><li><p><strong>CSS</strong>: Minimizes the conditional sum of squared residuals using Nelder-Mead. Residuals are computed recursively: <span>$\hat{\varepsilon}_t = y_t - c - \sum_i \phi_i y_{t-i} - \sum_j \theta_j \hat{\varepsilon}_{t-j}$</span></p></li><li><p><strong>MLE</strong>: Maximizes the exact Gaussian log-likelihood via the Kalman filter using L-BFGS optimization. The variance parameter is optimized on the log scale for unconstrained optimization.</p></li><li><p><strong>CSS-MLE</strong> (default): Uses CSS estimates to initialize MLE, combining the robustness of CSS with the efficiency of exact MLE.</p></li></ol><pre><code class="language-julia hljs">arma_model = estimate_arma(y, 1, 1; method=:css_mle)
arma_model.phi     # AR coefficients
arma_model.theta   # MA coefficients
arma_model.loglik  # Log-likelihood</code></pre><h3 id="ARMAModel-Return-Values"><a class="docs-heading-anchor" href="#ARMAModel-Return-Values">ARMAModel Return Values</a><a id="ARMAModel-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#ARMAModel-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>y</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Original time series</td></tr><tr><td style="text-align: right"><code>p</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">AR order</td></tr><tr><td style="text-align: right"><code>q</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">MA order</td></tr><tr><td style="text-align: right"><code>c</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Intercept</td></tr><tr><td style="text-align: right"><code>phi</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">AR coefficients <span>$[\phi_1, \ldots, \phi_p]$</span></td></tr><tr><td style="text-align: right"><code>theta</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">MA coefficients <span>$[\theta_1, \ldots, \theta_q]$</span></td></tr><tr><td style="text-align: right"><code>sigma2</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Innovation variance</td></tr><tr><td style="text-align: right"><code>residuals</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Estimated residuals</td></tr><tr><td style="text-align: right"><code>fitted</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Fitted values</td></tr><tr><td style="text-align: right"><code>loglik</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Log-likelihood</td></tr><tr><td style="text-align: right"><code>aic</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">AIC</td></tr><tr><td style="text-align: right"><code>bic</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">BIC</td></tr><tr><td style="text-align: right"><code>method</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Estimation method</td></tr><tr><td style="text-align: right"><code>converged</code></td><td style="text-align: right"><code>Bool</code></td><td style="text-align: right">Convergence indicator</td></tr><tr><td style="text-align: right"><code>iterations</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of iterations</td></tr></table><div class="admonition is-info" id="Technical-Note-891b1196b12b5696"><header class="admonition-header">Technical Note<a class="admonition-anchor" href="#Technical-Note-891b1196b12b5696" title="Permalink"></a></header><div class="admonition-body"><p>CSS (Conditional Sum of Squares) is fast but approximate: it conditions on initial residuals being zero, which introduces bias in small samples. MLE via the Kalman filter provides exact inference by properly handling initialization but is computationally more expensive and can be sensitive to starting values. The default <code>:css_mle</code> combines both: CSS provides robust starting values, then MLE refines to the exact optimum. For pure AR models, OLS is equivalent to CSS and is preferred for speed.</p></div></div><p><strong>Reference</strong>: Hamilton (1994, Chapter 5), Harvey (1993, Chapter 3)</p><hr/><h2 id="The-ARIMA(p,d,q)-Model"><a class="docs-heading-anchor" href="#The-ARIMA(p,d,q)-Model">The ARIMA(p,d,q) Model</a><a id="The-ARIMA(p,d,q)-Model-1"></a><a class="docs-heading-anchor-permalink" href="#The-ARIMA(p,d,q)-Model" title="Permalink"></a></h2><h3 id="Model-Specification-4"><a class="docs-heading-anchor" href="#Model-Specification-4">Model Specification</a><a class="docs-heading-anchor-permalink" href="#Model-Specification-4" title="Permalink"></a></h3><p>The ARIMA(p,d,q) model applies <span>$d$</span>-fold differencing to produce a stationary series, then fits an ARMA(p,q):</p><p class="math-container">\[\phi(L) (1-L)^d y_t = c + \theta(L) \varepsilon_t\]</p><p>where <span>$(1-L)^d y_t$</span> denotes the <span>$d$</span>-th difference of <span>$y_t$</span>. Common cases:</p><ul><li><span>$d = 1$</span>: <span>$\Delta y_t = y_t - y_{t-1}$</span> (first difference, for I(1) series)</li><li><span>$d = 2$</span>: <span>$\Delta^2 y_t = \Delta y_t - \Delta y_{t-1}$</span> (second difference, for I(2) series)</li></ul><h3 id="Estimation-4"><a class="docs-heading-anchor" href="#Estimation-4">Estimation</a><a class="docs-heading-anchor-permalink" href="#Estimation-4" title="Permalink"></a></h3><p>The implementation differences the series <span>$d$</span> times, then estimates ARMA(p,q) on the differenced series using the unified estimation pipeline.</p><pre><code class="language-julia hljs"># Random walk with drift
y = cumsum(randn(200))

# Fit ARIMA(1,1,0) — differenced once, then AR(1)
model = estimate_arima(y, 1, 1, 0)
model.phi    # AR coefficients on differenced series
model.d      # Integration order</code></pre><h3 id="ARIMAModel-Return-Values"><a class="docs-heading-anchor" href="#ARIMAModel-Return-Values">ARIMAModel Return Values</a><a id="ARIMAModel-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#ARIMAModel-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>y</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Original (undifferenced) time series</td></tr><tr><td style="text-align: right"><code>y_diff</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right"><span>$d$</span>-fold differenced series</td></tr><tr><td style="text-align: right"><code>p</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">AR order</td></tr><tr><td style="text-align: right"><code>d</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Integration order</td></tr><tr><td style="text-align: right"><code>q</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">MA order</td></tr><tr><td style="text-align: right"><code>c</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Intercept (on differenced series)</td></tr><tr><td style="text-align: right"><code>phi</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">AR coefficients</td></tr><tr><td style="text-align: right"><code>theta</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">MA coefficients</td></tr><tr><td style="text-align: right"><code>sigma2</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Innovation variance</td></tr><tr><td style="text-align: right"><code>residuals</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Estimated residuals</td></tr><tr><td style="text-align: right"><code>fitted</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Fitted values (on differenced scale)</td></tr><tr><td style="text-align: right"><code>loglik</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Log-likelihood</td></tr><tr><td style="text-align: right"><code>aic</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">AIC</td></tr><tr><td style="text-align: right"><code>bic</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">BIC</td></tr><tr><td style="text-align: right"><code>method</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Estimation method</td></tr><tr><td style="text-align: right"><code>converged</code></td><td style="text-align: right"><code>Bool</code></td><td style="text-align: right">Convergence indicator</td></tr><tr><td style="text-align: right"><code>iterations</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of iterations</td></tr></table><hr/><h2 id="kalman_mle"><a class="docs-heading-anchor" href="#kalman_mle">Exact MLE via Kalman Filter</a><a id="kalman_mle-1"></a><a class="docs-heading-anchor-permalink" href="#kalman_mle" title="Permalink"></a></h2><h3 id="State-Space-Representation"><a class="docs-heading-anchor" href="#State-Space-Representation">State-Space Representation</a><a id="State-Space-Representation-1"></a><a class="docs-heading-anchor-permalink" href="#State-Space-Representation" title="Permalink"></a></h3><p>For exact maximum likelihood estimation, the ARMA(p,q) model is cast into Harvey&#39;s (1993) state-space form:</p><p><strong>Observation equation</strong>:</p><p class="math-container">\[y_t = c + Z \alpha_t\]</p><p><strong>State equation</strong>:</p><p class="math-container">\[\alpha_{t+1} = T \alpha_t + R \eta_t, \quad \eta_t \sim N(0, Q)\]</p><p>where the state vector <span>$\alpha_t = [a_t, a_{t-1}, \ldots, a_{t-r+1}]&#39;$</span> has dimension <span>$r = \max(p, q+1)$</span>, and:</p><ul><li><span>$Z = [1, \theta_1, \ldots, \theta_{r-1}]$</span> is the observation vector</li><li><span>$T$</span> is the <span>$r \times r$</span> companion matrix with AR coefficients in the first row</li><li><span>$R = [1, 0, \ldots, 0]&#39;$</span> is the selection vector</li><li><span>$Q = [\sigma^2]$</span> is the innovation variance</li></ul><h3 id="Kalman-Filter-Log-Likelihood"><a class="docs-heading-anchor" href="#Kalman-Filter-Log-Likelihood">Kalman Filter Log-Likelihood</a><a id="Kalman-Filter-Log-Likelihood-1"></a><a class="docs-heading-anchor-permalink" href="#Kalman-Filter-Log-Likelihood" title="Permalink"></a></h3><p>The log-likelihood is computed via the prediction error decomposition:</p><p class="math-container">\[\ell(\Theta) = -\frac{n}{2} \log(2\pi) - \frac{1}{2} \sum_{t=1}^n \left( \log f_t + \frac{v_t^2}{f_t} \right)\]</p><p>where</p><ul><li><span>$v_t = y_t - \hat{y}_{t|t-1}$</span> is the one-step prediction error</li><li><span>$f_t = Z P_{t|t-1} Z&#39; + H$</span> is its variance</li><li><span>$n$</span> is the number of observations</li><li><span>$\Theta$</span> denotes the full parameter vector <span>$(\phi_1, \ldots, \phi_p, \theta_1, \ldots, \theta_q, \sigma^2)$</span></li></ul><p><strong>Initialization</strong>: Uses the unconditional (stationary) distribution when the system is stable, falling back to diffuse initialization (<span>$P_0 = 10^6 I$</span>) for non-stationary parameters.</p><p><strong>Reference</strong>: Harvey (1993, Chapters 3–4), Durbin &amp; Koopman (2012, Chapter 2)</p><hr/><h2 id="Forecasting"><a class="docs-heading-anchor" href="#Forecasting">Forecasting</a><a id="Forecasting-1"></a><a class="docs-heading-anchor-permalink" href="#Forecasting" title="Permalink"></a></h2><h3 id="Point-Forecasts"><a class="docs-heading-anchor" href="#Point-Forecasts">Point Forecasts</a><a id="Point-Forecasts-1"></a><a class="docs-heading-anchor-permalink" href="#Point-Forecasts" title="Permalink"></a></h3><p>The optimal <span>$h$</span>-step ahead forecast minimizes mean squared error. For an ARMA(p,q) process, forecasts are computed recursively:</p><p class="math-container">\[\hat{y}_{T+h|T} = c + \sum_{i=1}^p \phi_i \hat{y}_{T+h-i|T} + \sum_{j=1}^q \theta_j \hat{\varepsilon}_{T+h-j}\]</p><p>where <span>$\hat{y}_{T+k|T} = y_{T+k}$</span> for <span>$k \leq 0$</span> and <span>$\hat{\varepsilon}_{T+k} = 0$</span> for <span>$k \geq 1$</span> (future residuals are set to zero as the best linear predictor).</p><h3 id="Forecast-Uncertainty"><a class="docs-heading-anchor" href="#Forecast-Uncertainty">Forecast Uncertainty</a><a id="Forecast-Uncertainty-1"></a><a class="docs-heading-anchor-permalink" href="#Forecast-Uncertainty" title="Permalink"></a></h3><p>Forecast standard errors are derived from the MA(<span>$\infty$</span>) representation. The <span>$\psi$</span>-weights satisfy:</p><p class="math-container">\[\psi_j = \sum_{i=1}^{\min(p,j)} \phi_i \psi_{j-i} + \theta_j \mathbb{1}(j \leq q), \quad \psi_0 = 1\]</p><p>where</p><ul><li><span>$\psi_j$</span> is the <span>$j$</span>-th coefficient in the MA(<span>$\infty$</span>) representation <span>$y_t = \sum_{j=0}^{\infty} \psi_j \varepsilon_{t-j}$</span></li><li><span>$\phi_i$</span> are the AR coefficients (zero for <span>$i &gt; p$</span>)</li><li><span>$\theta_j$</span> are the MA coefficients (zero for <span>$j &gt; q$</span>)</li></ul><p>The <span>$h$</span>-step ahead forecast variance is:</p><p class="math-container">\[\text{Var}(e_{T+h|T}) = \sigma^2 \left(1 + \psi_1^2 + \psi_2^2 + \cdots + \psi_{h-1}^2 \right)\]</p><p>Confidence intervals are symmetric: <span>$\hat{y}_{T+h|T} \pm z_{\alpha/2} \cdot \text{se}_h$</span>.</p><h3 id="ARIMA-Forecasting"><a class="docs-heading-anchor" href="#ARIMA-Forecasting">ARIMA Forecasting</a><a id="ARIMA-Forecasting-1"></a><a class="docs-heading-anchor-permalink" href="#ARIMA-Forecasting" title="Permalink"></a></h3><p>For ARIMA(p,d,q) models, forecasts are computed on the differenced series and then integrated back to the original scale. For <span>$d = 1$</span>:</p><p class="math-container">\[\hat{y}_{T+h} = y_T + \sum_{j=1}^h \widehat{\Delta y}_{T+j|T}\]</p><p>Standard errors are adjusted for the integration via cumulative variance accumulation.</p><pre><code class="language-julia hljs"># Forecast 12 steps ahead
fc = forecast(model, 12)
fc.forecast    # Point forecasts
fc.ci_lower    # Lower 95% confidence bound
fc.ci_upper    # Upper 95% confidence bound
fc.se          # Standard errors

# Forecast with different confidence level
fc99 = forecast(model, 12; conf_level=0.99)</code></pre><h3 id="ARIMAForecast-Return-Values"><a class="docs-heading-anchor" href="#ARIMAForecast-Return-Values">ARIMAForecast Return Values</a><a id="ARIMAForecast-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#ARIMAForecast-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>forecast</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Point forecasts <span>$\hat{y}_{T+1}, \ldots, \hat{y}_{T+h}$</span></td></tr><tr><td style="text-align: right"><code>ci_lower</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Lower confidence bound</td></tr><tr><td style="text-align: right"><code>ci_upper</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Upper confidence bound</td></tr><tr><td style="text-align: right"><code>se</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Forecast standard errors (from psi-weights)</td></tr><tr><td style="text-align: right"><code>horizon</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Forecast horizon <span>$h$</span></td></tr><tr><td style="text-align: right"><code>conf_level</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Confidence level (e.g., 0.95)</td></tr></table><hr/><h2 id="Order-Selection"><a class="docs-heading-anchor" href="#Order-Selection">Order Selection</a><a id="Order-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#Order-Selection" title="Permalink"></a></h2><h3 id="Grid-Search"><a class="docs-heading-anchor" href="#Grid-Search">Grid Search</a><a id="Grid-Search-1"></a><a class="docs-heading-anchor-permalink" href="#Grid-Search" title="Permalink"></a></h3><p><code>select_arima_order</code> evaluates all ARMA(p,q) combinations up to specified maxima and selects the best model by AIC or BIC:</p><pre><code class="language-julia hljs"># Search over p ∈ {0,...,4}, q ∈ {0,...,4}
selection = select_arima_order(y, 4, 4)
selection.best_p_bic    # Optimal AR order (BIC)
selection.best_q_bic    # Optimal MA order (BIC)
selection.best_p_aic    # Optimal AR order (AIC)
selection.best_q_aic    # Optimal MA order (AIC)</code></pre><h3 id="ARIMAOrderSelection-Return-Values"><a class="docs-heading-anchor" href="#ARIMAOrderSelection-Return-Values">ARIMAOrderSelection Return Values</a><a id="ARIMAOrderSelection-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#ARIMAOrderSelection-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>best_p_aic</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Optimal AR order by AIC</td></tr><tr><td style="text-align: right"><code>best_q_aic</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Optimal MA order by AIC</td></tr><tr><td style="text-align: right"><code>best_p_bic</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Optimal AR order by BIC</td></tr><tr><td style="text-align: right"><code>best_q_bic</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Optimal MA order by BIC</td></tr><tr><td style="text-align: right"><code>aic_matrix</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$(p_{max}+1) \times (q_{max}+1)$</span> matrix of AIC values</td></tr><tr><td style="text-align: right"><code>bic_matrix</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$(p_{max}+1) \times (q_{max}+1)$</span> matrix of BIC values</td></tr><tr><td style="text-align: right"><code>best_model_aic</code></td><td style="text-align: right"><code>AbstractARIMAModel</code></td><td style="text-align: right">Best model by AIC</td></tr><tr><td style="text-align: right"><code>best_model_bic</code></td><td style="text-align: right"><code>AbstractARIMAModel</code></td><td style="text-align: right">Best model by BIC</td></tr></table><h3 id="Automatic-Selection"><a class="docs-heading-anchor" href="#Automatic-Selection">Automatic Selection</a><a id="Automatic-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-Selection" title="Permalink"></a></h3><p><code>auto_arima</code> implements an automatic model selection procedure:</p><pre><code class="language-julia hljs">best_model = auto_arima(y)
best_model.p     # Selected AR order
best_model.q     # Selected MA order (for ARMA) or d (for ARIMA)</code></pre><h3 id="Information-Criteria-Table"><a class="docs-heading-anchor" href="#Information-Criteria-Table">Information Criteria Table</a><a id="Information-Criteria-Table-1"></a><a class="docs-heading-anchor-permalink" href="#Information-Criteria-Table" title="Permalink"></a></h3><p><code>ic_table</code> provides a formatted comparison of models:</p><pre><code class="language-julia hljs"># Get IC values for a grid of models
table = ic_table(y, 3, 3)</code></pre><hr/><h2 id="StatsAPI-Interface"><a class="docs-heading-anchor" href="#StatsAPI-Interface">StatsAPI Interface</a><a id="StatsAPI-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#StatsAPI-Interface" title="Permalink"></a></h2><p>All ARIMA models implement the Julia <code>StatsAPI.RegressionModel</code> interface:</p><pre><code class="language-julia hljs">using StatsAPI

model = estimate_arma(y, 1, 1)

# StatsAPI accessors
coef(model)         # Coefficient vector
nobs(model)         # Number of observations
dof(model)          # Degrees of freedom (number of parameters)
dof_residual(model) # Residual degrees of freedom
loglikelihood(model) # Log-likelihood
aic(model)          # AIC
bic(model)          # BIC
residuals(model)    # Residual vector
fitted(model)       # Fitted values

# StatsAPI fit interface
model = fit(ARModel, y, 2)           # AR(2)
model = fit(MAModel, y, 1)           # MA(1)
model = fit(ARMAModel, y, 1, 1)      # ARMA(1,1)
model = fit(ARIMAModel, y, 1, 1, 1)  # ARIMA(1,1,1)

# Prediction
yhat = predict(model, 12)  # 12-step point forecasts</code></pre><hr/><h2 id="Complete-Example"><a class="docs-heading-anchor" href="#Complete-Example">Complete Example</a><a id="Complete-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-Example" title="Permalink"></a></h2><pre><code class="language-julia hljs">using MacroEconometricModels
using Random

Random.seed!(123)

# Generate an ARMA(1,1) process
n = 300
ε = randn(n)
y = zeros(n)
ϕ, θ = 0.7, -0.4
for t in 2:n
    y[t] = ϕ * y[t-1] + ε[t] + θ * ε[t-1]
end

# Step 1: Check for unit root
adf_result = adf_test(y; lags=:aic, regression=:constant)
# (Should reject → stationary, no differencing needed)

# Step 2: Select ARMA order
sel = select_arima_order(y, 4, 4)
println(&quot;Best order: ARMA($(sel.best_p_bic), $(sel.best_q_bic))&quot;)

# Step 3: Estimate the model
model = estimate_arma(y, sel.best_p_bic, sel.best_q_bic)
println(&quot;φ = $(model.phi), θ = $(model.theta)&quot;)
println(&quot;σ² = $(model.sigma2)&quot;)
println(&quot;AIC = $(model.aic), BIC = $(model.bic)&quot;)

# Step 4: Forecast
fc = forecast(model, 20; conf_level=0.95)
println(&quot;1-step forecast: $(fc.forecast[1]) ± $(1.96 * fc.se[1])&quot;)

# Step 5: Diagnostics
println(&quot;Converged: $(model.converged)&quot;)
println(&quot;Log-likelihood: $(model.loglik)&quot;)</code></pre><hr/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><ul><li>Box, George E. P., and Gwilym M. Jenkins. 1976. <em>Time Series Analysis: Forecasting and Control</em>. San Francisco: Holden-Day. ISBN 978-0-816-21104-3.</li><li>Brockwell, Peter J., and Richard A. Davis. 1991. <em>Time Series: Theory and Methods</em>. 2nd ed. New York: Springer. ISBN 978-1-4419-0319-8.</li><li>Durbin, James, and Siem Jan Koopman. 2012. <em>Time Series Analysis by State Space Methods</em>. 2nd ed. Oxford: Oxford University Press. <a href="https://doi.org/10.1093/acprof:oso/9780199641178.001.0001">https://doi.org/10.1093/acprof:oso/9780199641178.001.0001</a></li><li>Hamilton, James D. 1994. <em>Time Series Analysis</em>. Princeton, NJ: Princeton University Press. ISBN 978-0-691-04289-3.</li><li>Harvey, Andrew C. 1993. <em>Time Series Models</em>. 2nd ed. Cambridge, MA: MIT Press. ISBN 978-0-262-08224-2.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../manual/">VAR »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 6 February 2026 03:03">Friday 6 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
